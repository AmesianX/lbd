<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Arithmetic and logic instructions &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Generating object files" href="genobj.html" />
    <link rel="prev" title="Backend structure" href="backendstructure.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Arithmetic and logic instructions</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="backendstructure.html">Backend structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="genobj.html">Generating object files</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="arithmetic-and-logic-instructions">
<span id="sec-addingmoresupport"></span><h1>Arithmetic and logic instructions<a class="headerlink" href="#arithmetic-and-logic-instructions" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#arithmetic" id="id18">Arithmetic</a><ul>
<li><a class="reference internal" href="#and" id="id19"><strong>+, -, *, &lt;&lt;,</strong> and <strong>&gt;&gt;</strong></a></li>
<li><a class="reference internal" href="#display-llvm-ir-nodes-with-graphviz" id="id20">Display llvm IR nodes with Graphviz</a></li>
<li><a class="reference internal" href="#operator-and" id="id21">Operator % and /</a><ul>
<li><a class="reference internal" href="#the-dag-of" id="id22">The DAG of %</a></li>
<li><a class="reference internal" href="#arm-solution" id="id23">Arm solution</a></li>
<li><a class="reference internal" href="#mips-solution" id="id24">Mips solution</a></li>
<li><a class="reference internal" href="#full-support-and" id="id25">Full support %, and /</a></li>
</ul>
</li>
<li><a class="reference internal" href="#rotate-instructions" id="id26">Rotate instructions</a></li>
</ul>
</li>
<li><a class="reference internal" href="#logic" id="id27">Logic</a></li>
<li><a class="reference internal" href="#summary" id="id28">Summary</a></li>
</ul>
</div>
<p>This chapter adds more Cpu0 arithmetic instructions support first.
The <a class="reference external" href="http://jonathan2251.github.io/lbd/otherinst.html#display-llvm-ir-nodes-with-graphviz">section Display llvm IR nodes with Graphviz</a>
will show you the steps of DAG optimization and their corresponding <tt class="docutils literal"><span class="pre">llc</span></tt>
display options.
These DAGs translation in some steps of optimization can be displayed by the
graphic tool of Graphviz which supply useful information with graphic view.
Logic instructions support will come after arithmetic section.
In spite of llvm backend handle the IR only, we get the IR from the
corresponding C operators with designed C example code.
Through compiling with C code, readers can know exactly what C statements are
handled with each chapter&#8217;s appending code.
Instead of focusing on classes relationship in this backend structure of last
chapter, readers should focus on the mapping of C operators and llvm IR and
how to define the mapping relationship of IR and instructions in td.
HILO and C0 register class are defined in this chapter.
Readers will know how to handle other register classes beside general
purpose register class, and why need them, from this chapter.</p>
<div class="section" id="arithmetic">
<h2><a class="toc-backref" href="#id18">Arithmetic</a><a class="headerlink" href="#arithmetic" title="Permalink to this headline">¶</a></h2>
<p>The code added in Chapter4_1/ to support arithmetic instructions as follows,</p>
<p class="rubric">lbdex/chapters/Chapter4_1/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// getCpu0RegisterNumbering - Given the enum value for some register,</span>
<span class="c1">/// return the number that it corresponds to.</span>
<span class="kr">inline</span> <span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">getCpu0RegisterNumbering</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegEnum</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">RegEnum</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">HI</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">18</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LO</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">19</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0Subtarget.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">EnableOverflowOpt</span>
                <span class="p">(</span><span class="s">&quot;cpu0-enable-overflow&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
                 <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Use trigger overflow instructions add and sub \</span>
<span class="s">                 instead of non-overflow instructions addu and subu&quot;</span><span class="p">));</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="n">Cpu0Subtarget</span><span class="p">(</span><span class="k">const</span> <span class="n">Triple</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">CPU</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">little</span><span class="p">,</span> 
                             <span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">_TM</span><span class="p">)</span> <span class="o">:</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">EnableOverflow</span> <span class="o">=</span> <span class="n">EnableOverflowOpt</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Only op DAG can be disabled by ch4_1, data DAG cannot.</span>
<span class="n">def</span> <span class="n">SDT_Cpu0DivRem</span>       <span class="o">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                                         <span class="p">[</span><span class="n">SDTCisInt</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">&gt;</span><span class="p">,</span>
                                          <span class="n">SDTCisSameAs</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// DivRem(u) nodes</span>
<span class="n">def</span> <span class="n">Cpu0DivRem</span>    <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;Cpu0ISD::DivRem&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0DivRem</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">Cpu0DivRemU</span>   <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;Cpu0ISD::DivRemU&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0DivRem</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>let Predicates = [Ch4_1] in {
class shift_rotate_reg&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                       SDNode OpNode, RegisterClass RC&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;),
     [(set GPROut:$ra, (OpNode RC:$rb, RC:$rc))], IIAlu&gt; {
  let shamt = 0;
}
}
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>let Predicates = [Ch4_1] in {
// Mul, Div
class Mult&lt;bits&lt;8&gt; op, string instr_asm, InstrItinClass itin,
           RegisterClass RC, list&lt;Register&gt; DefRegs&gt;:
  FL&lt;op, (outs), (ins RC:$ra, RC:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;), [], itin&gt; {
  let imm16 = 0;
  let isCommutable = 1;
  let Defs = DefRegs;
  let hasSideEffects = 0;
}

class Mult32&lt;bits&lt;8&gt; op, string instr_asm, InstrItinClass itin&gt;:
  Mult&lt;op, instr_asm, itin, CPURegs, [HI, LO]&gt;;

class Div&lt;SDNode opNode, bits&lt;8&gt; op, string instr_asm, InstrItinClass itin,
          RegisterClass RC, list&lt;Register&gt; DefRegs&gt;:
  FL&lt;op, (outs), (ins RC:$ra, RC:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;),
     [(opNode RC:$ra, RC:$rb)], itin&gt; {
  let imm16 = 0;
  let Defs = DefRegs;
}

class Div32&lt;SDNode opNode, bits&lt;8&gt; op, string instr_asm, InstrItinClass itin&gt;:
  Div&lt;opNode, op, instr_asm, itin, CPURegs, [HI, LO]&gt;;

// Move from Lo/Hi
class MoveFromLOHI&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
                   list&lt;Register&gt; UseRegs&gt;:
  FL&lt;op, (outs RC:$ra), (ins),
     !strconcat(instr_asm, &quot;\t$ra&quot;), [], IIHiLo&gt; {
  let rb = 0;
  let imm16 = 0;
  let Uses = UseRegs;
  let hasSideEffects = 0;
}

// Move to Lo/Hi
class MoveToLOHI&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
                 list&lt;Register&gt; DefRegs&gt;:
  FL&lt;op, (outs), (ins RC:$ra),
     !strconcat(instr_asm, &quot;\t$ra&quot;), [], IIHiLo&gt; {
  let rb = 0;
  let imm16 = 0;
  let Defs = DefRegs;
  let hasSideEffects = 0;
}

// Move from C0 (co-processor 0) Register
class MoveFromC0&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FL&lt;op, (outs), (ins RC:$ra, C0Regs:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;), [], IIAlu&gt; {
  let imm16 = 0;
  let hasSideEffects = 0;
}

// Move to C0 Register
class MoveToC0&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FL&lt;op, (outs C0Regs:$ra), (ins RC:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;), [], IIAlu&gt; {
  let imm16 = 0;
  let hasSideEffects = 0;
}

// Move from C0 register to C0 register
class C0Move&lt;bits&lt;8&gt; op, string instr_asm&gt;:
  FL&lt;op, (outs C0Regs:$ra), (ins C0Regs:$rb),
     !strconcat(instr_asm, &quot;\t$ra, $rb&quot;), [], IIAlu&gt; {
  let imm16 = 0;
  let hasSideEffects = 0;
}
} // let Predicates = [Ch4_1]
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">DisableOverflow</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">SUBu</span>    <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x12</span><span class="p">,</span> <span class="s">&quot;subu&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">EnableOverflow</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">ADD</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x13</span><span class="p">,</span> <span class="s">&quot;add&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SUB</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x14</span><span class="p">,</span> <span class="s">&quot;sub&quot;</span><span class="p">,</span> <span class="n">sub</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">def</span> <span class="n">MUL</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x17</span><span class="p">,</span> <span class="s">&quot;mul&quot;</span><span class="p">,</span> <span class="n">mul</span><span class="p">,</span> <span class="n">IIImul</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="c1">// sra is IR node for ashr llvm IR instruction of .bc</span>
<span class="n">def</span> <span class="n">ROL</span>     <span class="o">:</span> <span class="n">shift_rotate_imm32</span><span class="o">&lt;</span><span class="mh">0x1b</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s">&quot;rol&quot;</span><span class="p">,</span> <span class="n">rotl</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">ROR</span>     <span class="o">:</span> <span class="n">shift_rotate_imm32</span><span class="o">&lt;</span><span class="mh">0x1c</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s">&quot;ror&quot;</span><span class="p">,</span> <span class="n">rotr</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SRA</span>     <span class="o">:</span> <span class="n">shift_rotate_imm32</span><span class="o">&lt;</span><span class="mh">0x1d</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s">&quot;sra&quot;</span><span class="p">,</span> <span class="n">sra</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="c1">// srl is IR node for lshr llvm IR instruction of .bc</span>
<span class="n">def</span> <span class="n">SHR</span>     <span class="o">:</span> <span class="n">shift_rotate_imm32</span><span class="o">&lt;</span><span class="mh">0x1f</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s">&quot;shr&quot;</span><span class="p">,</span> <span class="n">srl</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SRAV</span>    <span class="o">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s">&quot;srav&quot;</span><span class="p">,</span> <span class="n">sra</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SHLV</span>    <span class="o">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x21</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s">&quot;shlv&quot;</span><span class="p">,</span> <span class="n">shl</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SHRV</span>    <span class="o">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x22</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="s">&quot;shrv&quot;</span><span class="p">,</span> <span class="n">srl</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">ROLV</span>    <span class="o">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x23</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s">&quot;rolv&quot;</span><span class="p">,</span> <span class="n">rotl</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">RORV</span>    <span class="o">:</span> <span class="n">shift_rotate_reg</span><span class="o">&lt;</span><span class="mh">0x24</span><span class="p">,</span> <span class="mh">0x01</span><span class="p">,</span> <span class="s">&quot;rorv&quot;</span><span class="p">,</span> <span class="n">rotr</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="c1">/// Multiply and Divide Instructions.</span>
<span class="n">def</span> <span class="n">MULT</span>    <span class="o">:</span> <span class="n">Mult32</span><span class="o">&lt;</span><span class="mh">0x41</span><span class="p">,</span> <span class="s">&quot;mult&quot;</span><span class="p">,</span> <span class="n">IIImul</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">MULTu</span>   <span class="o">:</span> <span class="n">Mult32</span><span class="o">&lt;</span><span class="mh">0x42</span><span class="p">,</span> <span class="s">&quot;multu&quot;</span><span class="p">,</span> <span class="n">IIImul</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SDIV</span>    <span class="o">:</span> <span class="n">Div32</span><span class="o">&lt;</span><span class="n">Cpu0DivRem</span><span class="p">,</span> <span class="mh">0x43</span><span class="p">,</span> <span class="s">&quot;div&quot;</span><span class="p">,</span> <span class="n">IIIdiv</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">UDIV</span>    <span class="o">:</span> <span class="n">Div32</span><span class="o">&lt;</span><span class="n">Cpu0DivRemU</span><span class="p">,</span> <span class="mh">0x44</span><span class="p">,</span> <span class="s">&quot;divu&quot;</span><span class="p">,</span> <span class="n">IIIdiv</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">MFHI</span>    <span class="o">:</span> <span class="n">MoveFromLOHI</span><span class="o">&lt;</span><span class="mh">0x46</span><span class="p">,</span> <span class="s">&quot;mfhi&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="p">[</span><span class="n">HI</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">MFLO</span>    <span class="o">:</span> <span class="n">MoveFromLOHI</span><span class="o">&lt;</span><span class="mh">0x47</span><span class="p">,</span> <span class="s">&quot;mflo&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="p">[</span><span class="n">LO</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">MTHI</span>    <span class="o">:</span> <span class="n">MoveToLOHI</span><span class="o">&lt;</span><span class="mh">0x48</span><span class="p">,</span> <span class="s">&quot;mthi&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="p">[</span><span class="n">HI</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">MTLO</span>    <span class="o">:</span> <span class="n">MoveToLOHI</span><span class="o">&lt;</span><span class="mh">0x49</span><span class="p">,</span> <span class="s">&quot;mtlo&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="p">[</span><span class="n">LO</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">MFC0</span>    <span class="o">:</span> <span class="n">MoveFromC0</span><span class="o">&lt;</span><span class="mh">0x50</span><span class="p">,</span> <span class="s">&quot;mfc0&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">MTC0</span>    <span class="o">:</span> <span class="n">MoveToC0</span><span class="o">&lt;</span><span class="mh">0x51</span><span class="p">,</span> <span class="s">&quot;mtc0&quot;</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">C0MOVE</span>  <span class="o">:</span> <span class="n">C0Move</span><span class="o">&lt;</span><span class="mh">0x52</span><span class="p">,</span> <span class="s">&quot;c0mov&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">SDValue</span> <span class="n">PerformDAGCombine</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">DAGCombinerInfo</span> <span class="o">&amp;</span><span class="n">DCI</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SDIV</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SREM</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">UDIV</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">UREM</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">setTargetDAGCombine</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SDIVREM</span><span class="p">);</span>
  <span class="n">setTargetDAGCombine</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">UDIVREM</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">SDValue</span> <span class="nf">performDivRemCombine</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">SelectionDAG</span><span class="o">&amp;</span> <span class="n">DAG</span><span class="p">,</span>
                                    <span class="n">TargetLowering</span><span class="o">::</span><span class="n">DAGCombinerInfo</span> <span class="o">&amp;</span><span class="n">DCI</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DCI</span><span class="p">.</span><span class="n">isBeforeLegalizeOps</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>

  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">LO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">HI</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">ISD</span><span class="o">::</span><span class="n">SDIVREM</span> <span class="o">?</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">DivRem</span> <span class="o">:</span>
                                                  <span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">DivRemU</span><span class="p">;</span>
  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>

  <span class="n">SDValue</span> <span class="n">DivRem</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Opc</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">,</span>
                               <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">InChain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">();</span>
  <span class="n">SDValue</span> <span class="n">InGlue</span> <span class="o">=</span> <span class="n">DivRem</span><span class="p">;</span>

  <span class="c1">// insert MFLO</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">hasAnyUseOfValue</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">CopyFromLo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">InChain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">LO</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span>
                                            <span class="n">InGlue</span><span class="p">);</span>
    <span class="n">DAG</span><span class="p">.</span><span class="n">ReplaceAllUsesOfValueWith</span><span class="p">(</span><span class="n">SDValue</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">CopyFromLo</span><span class="p">);</span>
    <span class="n">InChain</span> <span class="o">=</span> <span class="n">CopyFromLo</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">InGlue</span> <span class="o">=</span> <span class="n">CopyFromLo</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// insert MFHI</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">hasAnyUseOfValue</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">CopyFromHi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">InChain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span>
                                            <span class="n">HI</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">InGlue</span><span class="p">);</span>
    <span class="n">DAG</span><span class="p">.</span><span class="n">ReplaceAllUsesOfValueWith</span><span class="p">(</span><span class="n">SDValue</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">CopyFromHi</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">PerformDAGCombine</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="n">DAGCombinerInfo</span> <span class="o">&amp;</span><span class="n">DCI</span><span class="p">)</span>
  <span class="k">const</span> <span class="p">{</span>
  <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span> <span class="o">=</span> <span class="n">DCI</span><span class="p">.</span><span class="n">DAG</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">Opc</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">SDIVREM</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">UDIVREM</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">performDivRemCombine</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">DCI</span><span class="p">,</span> <span class="n">Subtarget</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0RegisterInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s">&quot;Cpu0&quot;</span> <span class="n">in</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Hi/Lo registers number and name</span>
  <span class="n">def</span> <span class="n">HI</span>   <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;hi&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">LO</span>   <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;lo&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Hi/Lo Registers class</span>
<span class="n">def</span> <span class="n">HILO</span>   <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span> <span class="n">HI</span><span class="p">,</span> <span class="n">LO</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0Schedule.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">IIHiLo</span>             <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="n">def</span> <span class="n">IIImul</span>             <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
<span class="n">def</span> <span class="n">IIIdiv</span>             <span class="o">:</span> <span class="n">InstrItinClass</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">Cpu0GenericItineraries</span> <span class="o">:</span> <span class="n">ProcessorItineraries</span><span class="o">&lt;</span><span class="p">[</span><span class="n">ALU</span><span class="p">,</span> <span class="n">IMULDIV</span><span class="p">],</span> <span class="p">[],</span> <span class="p">[</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIHiLo</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIImul</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">17</span><span class="p">,</span> <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
  <span class="n">InstrItinData</span><span class="o">&lt;</span><span class="n">IIIdiv</span>             <span class="p">,</span> <span class="p">[</span><span class="n">InstrStage</span><span class="o">&lt;</span><span class="mi">38</span><span class="p">,</span> <span class="p">[</span><span class="n">IMULDIV</span><span class="p">]</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0SEISelDAGToDAG.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SDNode</span><span class="o">*</span><span class="p">,</span> <span class="n">SDNode</span><span class="o">*&gt;</span> <span class="n">SelectMULT</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span>
                                         <span class="n">EVT</span> <span class="n">Ty</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">HasLo</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">HasHi</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0SEISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Select multiply instructions.</span>
<span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">SDNode</span><span class="o">*</span><span class="p">,</span> <span class="n">SDNode</span><span class="o">*&gt;</span>
<span class="n">Cpu0SEDAGToDAGISel</span><span class="o">::</span><span class="n">SelectMULT</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">EVT</span> <span class="n">Ty</span><span class="p">,</span>
                             <span class="kt">bool</span> <span class="n">HasLo</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">HasHi</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SDNode</span> <span class="o">*</span><span class="n">Lo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">Hi</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">SDNode</span> <span class="o">*</span><span class="n">Mul</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Opc</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">,</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                       <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">InFlag</span> <span class="o">=</span> <span class="n">SDValue</span><span class="p">(</span><span class="n">Mul</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">HasLo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Lo</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">MFLO</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span>
                                <span class="n">Ty</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">);</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">SDValue</span><span class="p">(</span><span class="n">Lo</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">HasHi</span><span class="p">)</span>
    <span class="n">Hi</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">MFHI</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span>
                                <span class="n">Ty</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Lo</span><span class="p">,</span> <span class="n">Hi</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">SDNode</span><span class="o">*&gt;</span> <span class="n">Cpu0SEDAGToDAGISel</span><span class="o">::</span><span class="n">selectNode</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>
  <span class="n">SDLoc</span> <span class="nf">DL</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span>

  <span class="c1">///</span>
  <span class="c1">// Instruction Selection not handled by the auto-generated</span>
  <span class="c1">// tablegen selection should be handled here.</span>
  <span class="c1">///</span>
  <span class="n">SDNode</span> <span class="o">*</span><span class="n">Result</span><span class="p">;</span>

  <span class="c1">///</span>
  <span class="c1">// Instruction Selection not handled by the auto-generated</span>
  <span class="c1">// tablegen selection should be handled here.</span>
  <span class="c1">///</span>
  <span class="n">EVT</span> <span class="n">NodeTy</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">MultOpc</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">Opcode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">MULHS</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">MULHU</span><span class="o">:</span> <span class="p">{</span>
    <span class="n">MultOpc</span> <span class="o">=</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">ISD</span><span class="o">::</span><span class="n">MULHU</span> <span class="o">?</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MULTu</span> <span class="o">:</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MULT</span><span class="p">);</span>
    <span class="n">Result</span> <span class="o">=</span> <span class="n">SelectMULT</span><span class="p">(</span><span class="n">Node</span><span class="p">,</span> <span class="n">MultOpc</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">NodeTy</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">true</span><span class="p">).</span><span class="n">second</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="n">Result</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">Constant</span><span class="o">:</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">CN</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">Size</span> <span class="o">=</span> <span class="n">CN</span><span class="o">-&gt;</span><span class="n">getValueSizeInBits</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Size</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0SEInstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">copyPhysReg</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                   <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span> <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">,</span>
                   <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span>
                   <span class="kt">bool</span> <span class="n">KillSrc</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0SEInstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0SEInstrInfo</span><span class="o">::</span>
<span class="n">copyPhysReg</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
            <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span> <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="n">KillSrc</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ZeroReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">DestReg</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Copy to CPU Reg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">))</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDu</span><span class="p">,</span> <span class="n">ZeroReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MFHI</span><span class="p">,</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MFLO</span><span class="p">,</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">))</span> <span class="p">{</span> <span class="c1">// Copy from CPU Reg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MTHI</span><span class="p">,</span> <span class="n">DestReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">MTLO</span><span class="p">,</span> <span class="n">DestReg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Cannot copy registers&quot;</span><span class="p">);</span>

  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DestReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">DestReg</span><span class="p">,</span> <span class="n">RegState</span><span class="o">::</span><span class="n">Define</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ZeroReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZeroReg</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">SrcReg</span><span class="p">)</span>
    <span class="n">MIB</span><span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">,</span> <span class="n">getKillRegState</span><span class="p">(</span><span class="n">KillSrc</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="and">
<h3><a class="toc-backref" href="#id19"><strong>+, -, *, &lt;&lt;,</strong> and <strong>&gt;&gt;</strong></a><a class="headerlink" href="#and" title="Permalink to this headline">¶</a></h3>
<p>The ADDu, ADD, SUBu, SUB and MUL defined in Chapter4_1/Cpu0InstrInfo.td are for
operators <strong>+, -, *</strong>.
SHL (defined before) and SHLV are for <strong>&lt;&lt;</strong>.
SRA, SRAV, SHR and SHRV are for <strong>&gt;&gt;</strong>.</p>
<p>In RISC CPU like Mips, the multiply/divide function unit and add/sub/logic unit
are designed from two different hardware circuits, and more, their data path are
separate. Cpu0 is same, so these two function units can be executed at same
time (instruction level parallelism). Reference <a class="footnote-reference" href="#id10" id="id1">[1]</a> for instruction itineraries.</p>
<p>Chapter4_1/ can handle <strong>+, -, *, &lt;&lt;,</strong> and <strong>&gt;&gt;</strong> operators in C
language.
The corresponding llvm IR instructions are <strong>add, sub, mul,
shl, ashr</strong>.
The <strong>&#8216;ashr&#8217;</strong> instruction (arithmetic shift right) returns the first operand
shifted to the right a specified number of bits with sign extension.
In brief, we call <strong>ashr</strong> is “shift with sign extension fill”.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>ashr</strong></p>
<dl class="last docutils">
<dt>Example:</dt>
<dd><p class="first">&lt;result&gt; = ashr i32 4, 1   ; yields {i32}:result = 2</p>
<p>&lt;result&gt; = ashr i8 -2, 1   ; yields {i8}:result = -1</p>
<p class="last">&lt;result&gt; = ashr i32 1, 32  ; undefined</p>
</dd>
</dl>
</div>
<p>The semantic of C operator <strong>&gt;&gt;</strong> for negative operand is dependent on
implementation.
Most compiler translate it into “shift with sign extension fill”, for example,
Mips <strong>sra</strong> is the instruction.
Following is the Micosoft web site explanation,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>&gt;&gt;</strong>, Microsoft Specific</p>
<p class="last">The result of a right shift of a signed negative quantity is implementation
dependent.
Although Microsoft C++ propagates the most-significant bit to fill vacated
bit positions, there is no guarantee that other implementations will do
likewise.</p>
</div>
<p>In addition to <strong>ashr</strong>, the other instruction “shift with zero filled”
<strong>lshr</strong> in llvm (Mips implement lshr with instruction <strong>srl</strong>) has the
following meaning.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>lshr</strong></p>
<p class="last">Example:
&lt;result&gt; = lshr i8 -2, 1   ; yields {i8}:result = 0x7FFFFFFF</p>
</div>
<p>In llvm, IR node <strong>sra</strong> is defined for ashr IR instruction, and node <strong>srl</strong> is
defined for lshr instruction (We don&#8217;t know why don&#8217;t use ashr and lshr as the
IR node name directly). Summary as the Table: C operator &gt;&gt; implementation.</p>
<table border="1" class="docutils">
<caption>C operator &gt;&gt; implementation</caption>
<colgroup>
<col width="40%" />
<col width="22%" />
<col width="38%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Shift with zero filled</th>
<th class="head">Shift with signed extension filled</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>symbol in .bc</td>
<td>lshr</td>
<td>ashr</td>
</tr>
<tr class="row-odd"><td>symbol in IR node</td>
<td>srl</td>
<td>sra</td>
</tr>
<tr class="row-even"><td>Mips instruction</td>
<td>srl</td>
<td>sra</td>
</tr>
<tr class="row-odd"><td>Cpu0 instruction</td>
<td>shr</td>
<td>sra</td>
</tr>
<tr class="row-even"><td>signed example before x &gt;&gt; 1</td>
<td>0xfffffffe i.e. -2</td>
<td>0xfffffffe i.e. -2</td>
</tr>
<tr class="row-odd"><td>signed example after x &gt;&gt; 1</td>
<td>0x7fffffff i.e 2G-1</td>
<td>0xffffffff i.e. -1</td>
</tr>
<tr class="row-even"><td>unsigned example before x &gt;&gt; 1</td>
<td>0xfffffffe i.e. 4G-2</td>
<td>0xfffffffe i.e. 4G-2</td>
</tr>
<tr class="row-odd"><td>unsigned example after x &gt;&gt; 1</td>
<td>0x7fffffff i.e 2G-1</td>
<td>0xffffffff i.e. 4G-1</td>
</tr>
</tbody>
</table>
<p><strong>lshr:</strong> Logical SHift Right</p>
<p><strong>ashr:</strong> Arithmetic SHift right</p>
<p><strong>srl:</strong>  Shift Right Logically</p>
<p><strong>sra:</strong>  Shift Right Arithmetically</p>
<p><strong>shr:</strong>  SHift Right</p>
<p>If we consider the x &gt;&gt; 1 definition is x = x/2 for compiler implementation.
Then as you can see from Table: C operator &gt;&gt; implementation, <strong>lshr</strong> will fail
on some signed value (such as -2). In the same way, <strong>ashr</strong> will fail on some
unsigned value (such as 4G-2). So, in order to satisfy this definition in
both signed and unsigned integers of x, we need these two instructions,
<strong>lshr</strong> and <strong>ashr</strong>.</p>
<table border="1" class="docutils">
<caption>C operator &lt;&lt; implementation</caption>
<colgroup>
<col width="64%" />
<col width="36%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Shift with zero filled</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>symbol in .bc</td>
<td>shl</td>
</tr>
<tr class="row-odd"><td>symbol in IR node</td>
<td>shl</td>
</tr>
<tr class="row-even"><td>Mips instruction</td>
<td>sll</td>
</tr>
<tr class="row-odd"><td>Cpu0 instruction</td>
<td>shl</td>
</tr>
<tr class="row-even"><td>signed example before x &lt;&lt; 1</td>
<td>0x40000000 i.e. 1G</td>
</tr>
<tr class="row-odd"><td>signed example after x &lt;&lt; 1</td>
<td>0x80000000 i.e -2G</td>
</tr>
<tr class="row-even"><td>unsigned example before x &lt;&lt; 1</td>
<td>0x40000000 i.e. 1G</td>
</tr>
<tr class="row-odd"><td>unsigned example after x &lt;&lt; 1</td>
<td>0x80000000 i.e 2G</td>
</tr>
</tbody>
</table>
<p>Again, consider the x &lt;&lt; 1 definition is x = x*2.
From Table: C operator &lt;&lt; implementation, we see <strong>lshr</strong> satisfy &#8220;unsigned
x=1G&#8221; but fails on signed x=1G.
It&#8217;s fine since 2G is out of 32 bits signed integer range (-2G ~ 2G-1).
For the overflow case, no way to keep the correct result in register. So, any
value in register is OK. You can check that <strong>lshr</strong> satisfy x = x*2, for all
x &lt;&lt; 1 and the x result is not out of range, no matter operand x is signed
or unsigned integer.</p>
<p>Micorsoft implementation references here <a class="footnote-reference" href="#id11" id="id2">[2]</a>.</p>
<p>The ‘ashr‘ Instruction&#8221; reference here <a class="footnote-reference" href="#id12" id="id3">[3]</a>, ‘lshr‘ reference here <a class="footnote-reference" href="#id13" id="id4">[4]</a>.</p>
<p>The srav, shlv and shrv are for two virtual input registers instructions while
the sra, ... are for 1 virtual input registers and 1 constant input operands.</p>
<p>Now, let&#8217;s build Chapter4_1/ and run with input file ch4_math.ll as follows,</p>
<p class="rubric">lbdex/input/ch4_math.ll</p>
<div class="highlight-c++"><div class="highlight"><pre>; Function Attrs: nounwind
define i32 @_Z9test_mathv() #0 {
  %a = alloca i32, align 4
  %b = alloca i32, align 4
  %1 = load i32, i32* %a, align 4
  %2 = load i32, i32* %b, align 4

  %3 = add nsw i32 %1, %2
  %4 = sub nsw i32 %1, %2
  %5 = mul nsw i32 %1, %2
  %6 = shl i32 %1, 2
  %7 = ashr i32 %1, 2
  %8 = lshr i32 %1, 30
  %9 = shl i32 1, %2
  %10 = ashr i32 128, %2
  %11 = ashr i32 %1, %2

  %12 = add nsw i32 %3, %4
  %13 = add nsw i32 %12, %5
  %14 = add nsw i32 %13, %6
  %15 = add nsw i32 %14, %7
  %16 = add nsw i32 %15, %8
  %17 = add nsw i32 %16, %9
  %18 = add nsw i32 %17, %10
  %19 = add nsw i32 %18, %11

  ret i32 %19
}
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch4_math.ll -o -
</pre></div>
</div>
<p class="rubric">lbdex/output/ch4_math.s</p>
<div class="highlight-c++"><div class="highlight"><pre>  .text
  .section .mdebug.abiO32
  .previous
  .file  &quot;input/ch4_math.ll&quot;
  .globl  _Z9test_mathv
  .align  2
  .type  _Z9test_mathv,@function
  .ent  _Z9test_mathv           # @_Z9test_mathv
_Z9test_mathv:
  .cfi_startproc
  .frame  $sp,8,$lr
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
# BB#0:
  addiu  $sp, $sp, -8
$tmp0:
  .cfi_def_cfa_offset 8
  ld  $2, 0($sp)
  ld  $3, 4($sp)
  subu  $4, $3, $2
  addu  $5, $3, $2
  addu  $4, $5, $4
  mul  $5, $3, $2
  addu  $4, $4, $5
  shl  $5, $3, 2
  addu  $4, $4, $5
  sra  $5, $3, 2
  addu  $4, $4, $5
  addiu  $5, $zero, 128
  shrv  $5, $5, $2
  addiu  $t9, $zero, 1
  shlv  $t9, $t9, $2
  srav  $2, $3, $2
  shr  $3, $3, 30
  addu  $3, $4, $3
  addu  $3, $3, $t9
  addu  $3, $3, $5
  addu  $2, $3, $2
  addiu  $sp, $sp, 8
  ret  $lr
  nop
  .set  macro
  .set  reorder
  .end  _Z9test_mathv
$func_end0:
  .size  _Z9test_mathv, ($func_end0)-_Z9test_mathv
  .cfi_endproc
</pre></div>
</div>
<p>File ch4_1_1.cpp as the following is the C file which include <strong>+, -, *, &lt;&lt;,</strong>
and <strong>&gt;&gt;</strong> operators. It will generate corresponding llvm IR instructions,
<strong>add, sub, mul, shl, ashr</strong> by clang as Chapter 3 indicated.</p>
<p class="rubric">lbdex/input/ch4_1_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_math</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f1</span><span class="p">,</span> <span class="n">g1</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">i1</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>      <span class="c1">// c = 7</span>
  <span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>      <span class="c1">// d = 3</span>
  <span class="n">e</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">;</span>      <span class="c1">// e = 10</span>
  <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>   <span class="c1">// f = 20</span>
  <span class="n">f1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// f1 = 0xfffffff6 = -10</span>
  <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">);</span>   <span class="c1">// g = 1</span>
  <span class="n">g1</span> <span class="o">=</span> <span class="p">(</span><span class="n">a1</span> <span class="o">&gt;&gt;</span> <span class="mi">30</span><span class="p">);</span> <span class="c1">// g1 = 0x03 = 3</span>
  <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">);</span>   <span class="c1">// h = 0x20 = 32</span>
  <span class="n">h1</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// h1 = 0x04</span>
  <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="mh">0x80</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// i = 0x04</span>
  <span class="n">i1</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span>  <span class="c1">// i1 = 0x0</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="n">f</span><span class="o">+</span><span class="kt">int</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span><span class="o">+</span><span class="n">g</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">g1</span><span class="o">+</span><span class="n">h</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">h1</span><span class="o">+</span><span class="n">i</span><span class="o">+</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">i1</span><span class="p">);</span>
<span class="c1">// 7+3+10+20-10+1+3+32+4+4+0 = 74</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Cpu0 instructions add and sub will trigger overflow exception while addu and subu
truncate overflow value directly. Compile ch4_1_2.cpp with
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-enable-overflow=true</span></tt> will generate add and sub instructions as
follows,</p>
<p class="rubric">lbdex/input/ch4_1_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;debug.h&quot;</span>

<span class="kt">int</span> <span class="nf">test_add_overflow</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x70000000</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_sub_overflow</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="o">-</span><span class="mh">0x70000000</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x20000000</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch4_1_2.cpp -emit-llvm -o ch4_1_2.bc
118-165-78-12:input Jonathan<span class="nv">$ </span>llvm-dis ch4_1_2.bc -o -
...
; Function Attrs: nounwind
define i32 @_Z13test_overflowv<span class="o">()</span> <span class="c">#0 {</span>
  ...
  %3 <span class="o">=</span> add nsw i32 %1, %2
  ...
  %6 <span class="o">=</span> sub nsw i32 %4, %5
  ...
<span class="o">}</span>

118-165-78-12:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
-cpu0-enable-overflow<span class="o">=</span><span class="nb">true </span>ch4_1_2.bc -o -
      ...
      add     <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
      ...
      sub     <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
      ...
</pre></div>
</div>
<p>In modern CPU, programmers are used to using truncate overflow instructions in
C program regard add and sub instructions.
Anyway, through option -cpu0-enable-overflow=true, programmer get the
chance to compile program with overflow exception program. Usually, this option
used in debug purpose. Compile with this option can help to identify the bug and
fix it early.</p>
</div>
<div class="section" id="display-llvm-ir-nodes-with-graphviz">
<h3><a class="toc-backref" href="#id20">Display llvm IR nodes with Graphviz</a><a class="headerlink" href="#display-llvm-ir-nodes-with-graphviz" title="Permalink to this headline">¶</a></h3>
<p>The previous section, display the DAG translation process in text on terminal
by option <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt>.
The <tt class="docutils literal"><span class="pre">llc</span></tt> also supports the graphic displaying.
The <a class="reference external" href="http://jonathan2251.github.io/lbd/install.html#install-other-tools-on-imac">section Install other tools on iMac</a> include the download and installation
of tool Graphivz.
The <tt class="docutils literal"><span class="pre">llc</span></tt> graphic displaying with tool Graphviz is introduced in this section.
The graphic displaying is more readable by eye than displaying text in terminal.
It&#8217;s not a must-have, but helps a lot especially when you are tired in tracking
the DAG translation process.
List the <tt class="docutils literal"><span class="pre">llc</span></tt> graphic support options from the sub-section &#8220;SelectionDAG
Instruction Selection Process&#8221; of web &#8220;The LLVM Target-Independent Code Generator&#8221;
<a class="footnote-reference" href="#id14" id="id5">[5]</a> as follows,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>The <tt class="docutils literal"><span class="pre">llc</span></tt> Graphviz DAG display options</p>
<p>-view-dag-combine1-dags displays the DAG after being built, before the
first optimization pass.</p>
<p>-view-legalize-dags displays the DAG before Legalization.</p>
<p>-view-dag-combine2-dags displays the DAG before the second optimization
pass.</p>
<p>-view-isel-dags displays the DAG before the Select phase.</p>
<p class="last">-view-sched-dags displays the DAG before Scheduling.</p>
</div>
<p>By tracking <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt>, you can see the DAG translation steps as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>Initial selection DAG
Optimized lowered selection DAG
Type-legalized selection DAG
Optimized <span class="nb">type</span>-legalized selection DAG
Legalized selection DAG
Optimized legalized selection DAG
Instruction selection
Selected selection DAG
Scheduling
...
</pre></div>
</div>
<p>Let&#8217;s run <tt class="docutils literal"><span class="pre">llc</span></tt> with option -view-dag-combine1-dags, and open the output
result with Graphviz as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-12-177:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/Debug/bin/llc -view-dag-combine1-dags -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch4_2.bc -o ch4_2.cpu0.s
Writing <span class="s1">&#39;/tmp/llvm_84ibpm/dag.main.dot&#39;</span>...  <span class="k">done</span>.
118-165-12-177:input Jonathan<span class="nv">$ </span>Graphviz /tmp/llvm_84ibpm/dag.main.dot
</pre></div>
</div>
<p>It will show the /tmp/llvm_84ibpm/dag.main.dot as <a class="pageref" href="#otherinst-f1">Figure  1</a>.</p>
<div class="figure align-center" id="otherinst-f1">
<a class="reference internal image-reference" href="_images/17.png"><img alt="_images/17.png" src="_images/17.png" style="width: 687.0px; height: 851.0px;" /></a>
<p class="caption">Figure 1: llc option -view-dag-combine1-dags graphic view</p>
</div>
<p><a class="pageref" href="#otherinst-f1">Figure  1</a> is the stage of &#8220;Initial selection DAG&#8221;.
List the other view options and their corresponding DAG translation stages as
follows,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><tt class="docutils literal"><span class="pre">llc</span></tt> Graphviz options and corresponding DAG translation stage</p>
<p>-view-dag-combine1-dags: Initial selection DAG</p>
<p>-view-legalize-dags: Optimized type-legalized selection DAG</p>
<p>-view-dag-combine2-dags: Legalized selection DAG</p>
<p>-view-isel-dags: Optimized legalized selection DAG</p>
<p class="last">-view-sched-dags: Selected selection DAG</p>
</div>
<p>The -view-isel-dags is important and often used by an llvm backend writer
because it is the DAGs before instruction selection.
In order to writing the pattern match instruction in target description file
.td, backend programmer needs knowing what the DAG nodes are with a given C
operator.</p>
</div>
<div class="section" id="operator-and">
<h3><a class="toc-backref" href="#id21">Operator % and /</a><a class="headerlink" href="#operator-and" title="Permalink to this headline">¶</a></h3>
<div class="section" id="the-dag-of">
<h4><a class="toc-backref" href="#id22">The DAG of %</a><a class="headerlink" href="#the-dag-of" title="Permalink to this headline">¶</a></h4>
<p>Example input code ch4_2.cpp which contains the C operator <strong>“%”</strong> and it&#8217;s
corresponding llvm IR, as follows,</p>
<p class="rubric">lbdex/input/ch4_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_mod</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
<span class="c1">//  unsigned int b = 11;</span>
  
  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="mi">12</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>...
define i32 @_Z8test_modv<span class="o">()</span> <span class="c">#0 {</span>
  %b <span class="o">=</span> alloca i32, align 4
  store i32 11, i32* %b, align 4
  %1 <span class="o">=</span> load i32* %b, align 4
  %2 <span class="o">=</span> add nsw i32 %1, 1
  %3 <span class="o">=</span> srem i32 %2, 12
  store i32 %3, i32* %b, align 4
  %4 <span class="o">=</span> load i32* %b, align 4
  ret i32 %4
<span class="o">}</span>
</pre></div>
</div>
<p>LLVM <strong>srem</strong> is the IR of corresponding <strong>“%”</strong>, reference here <a class="footnote-reference" href="#id15" id="id6">[6]</a>.
Copy the reference as follows,</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p><strong>&#8216;srem&#8217;</strong> Instruction</p>
<p>Syntax:
<strong>&lt;result&gt; = srem &lt;ty&gt; &lt;op1&gt;, &lt;op2&gt;   ; yields {ty}:result</strong></p>
<p>Overview:
The <strong>&#8216;srem&#8217;</strong> instruction returns the remainder from the signed division of its
two operands. This instruction can also take vector versions of the values in
which case the elements must be integers.</p>
<p>Arguments:
The two arguments to the <strong>&#8216;srem&#8217;</strong> instruction must be integer or vector of
integer values. Both arguments must have identical types.</p>
<p>Semantics:
This instruction returns the remainder of a division (where the result is
either zero or has the same sign as the dividend, op1), not the modulo operator
(where the result is either zero or has the same sign as the divisor, op2) of
a value. For more information about the difference, see The Math Forum. For a
table of how this is implemented in various languages, please see Wikipedia:
modulo operation.</p>
<p>Note that signed integer remainder and unsigned integer remainder are distinct
operations; for unsigned integer remainder, use <strong>&#8216;urem&#8217;</strong>.</p>
<p>Taking the remainder of a division by zero leads to undefined behavior.
Overflow also leads to undefined behavior; this is a rare case, but can occur,
for example, by taking the remainder of a 32-bit division of -2147483648 by -1.
(The remainder doesn&#8217;t actually overflow, but this rule lets srem be
implemented using instructions that return both the result of the division and
the remainder.)</p>
<p class="last">Example:
&lt;result&gt; = <strong>srem i32 4, %var</strong>      ; yields {i32}:result = 4 % %var</p>
</div>
<p>Run Chapter3_4/ with input file ch4_2.bc via option <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">–view-isel-dags</span></tt>,
will get the following error message and the llvm DAGs of
<a class="pageref" href="#otherinst-f2">Figure  2</a> below.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-37:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0 -view-isel-dags -relocation-model<span class="o">=</span>
pic -filetype<span class="o">=</span>asm ch4_2.bc -o -
...
LLVM ERROR: Cannot <span class="k">select</span>: 0x7fa73a02ea10: <span class="nv">i32</span> <span class="o">=</span> mulhs 0x7fa73a02c610,
0x7fa73a02e910 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>12<span class="o">]</span>
0x7fa73a02c610: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>
0x7fa73a02e910: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;715827883&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
</pre></div>
</div>
<div class="figure align-center" id="otherinst-f2">
<a class="reference internal image-reference" href="_images/25.png"><img alt="_images/25.png" src="_images/25.png" style="width: 580.0px; height: 629.0px;" /></a>
<p class="caption">Figure 2: ch4_2.bc DAG</p>
</div>
<p>LLVM replaces srem divide operation with multiply operation in DAG optimization
because DIV operation costs more in time than MUL.
Example code <strong>“int b = 11; b=(b+1)%12;”</strong> is translated into DAGs as
<a class="pageref" href="#otherinst-f2">Figure  2</a>.
The DAGs of generated result is verified and explained by calculating the value
in each node.
The 0xC*0x2AAAAAAB=0x2,00000004, (mulhs 0xC, 0x2AAAAAAAB) meaning get the Signed
mul high word (32bits).
Multiply with 2 operands of 1 word size probably generate the 2 word size of
result (0x2, 0xAAAAAAAB).
The high word result, in this case is 0x2.
The final result (sub 12, 12) is 0 which match the statement (11+1)%12.</p>
</div>
<div class="section" id="arm-solution">
<h4><a class="toc-backref" href="#id23">Arm solution</a><a class="headerlink" href="#arm-solution" title="Permalink to this headline">¶</a></h4>
<p>To run with ARM solution, change Cpu0InstrInfo.td and Cpu0ISelDAGToDAG.cpp from
Chapter4_1/ as follows,</p>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Multiply and Divide Instructions.</span>
<span class="n">def</span> <span class="n">SMMUL</span>   <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x41</span><span class="p">,</span> <span class="s">&quot;smmul&quot;</span><span class="p">,</span> <span class="n">mulhs</span><span class="p">,</span> <span class="n">IIImul</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">UMMUL</span>   <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x42</span><span class="p">,</span> <span class="s">&quot;ummul&quot;</span><span class="p">,</span> <span class="n">mulhu</span><span class="p">,</span> <span class="n">IIImul</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">//def MULT    : Mult32&lt;0x41, &quot;mult&quot;, IIImul&gt;;</span>
<span class="c1">//def MULTu   : Mult32&lt;0x42, &quot;multu&quot;, IIImul&gt;;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_1/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#if 0</span><span class="c"></span>
<span class="c">/// Select multiply instructions.</span>
<span class="c">std::pair&lt;SDNode*, SDNode*&gt;</span>
<span class="c">Cpu0DAGToDAGISel::SelectMULT(SDNode *N, unsigned Opc, SDLoc DL, EVT Ty,</span>
<span class="c">                             bool HasLo, bool HasHi) {</span>
<span class="c">  SDNode *Lo = 0, *Hi = 0;</span>
<span class="c">  SDNode *Mul = CurDAG-&gt;getMachineNode(Opc, DL, MVT::Glue, N-&gt;getOperand(0),</span>
<span class="c">                                       N-&gt;getOperand(1));</span>
<span class="c">  SDValue InFlag = SDValue(Mul, 0);</span>

<span class="c">  if (HasLo) {</span>
<span class="c">    Lo = CurDAG-&gt;getMachineNode(Cpu0::MFLO, DL,</span>
<span class="c">                                Ty, MVT::Glue, InFlag);</span>
<span class="c">    InFlag = SDValue(Lo, 1);</span>
<span class="c">  }</span>
<span class="c">  if (HasHi)</span>
<span class="c">    Hi = CurDAG-&gt;getMachineNode(Cpu0::MFHI, DL,</span>
<span class="c">                                Ty, InFlag);</span>

<span class="c">  return std::make_pair(Lo, Hi);</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="c1">/// Select instructions not customized! Used for</span>
<span class="c1">/// expanded, promoted and normal instructions</span>
<span class="n">SDNode</span><span class="o">*</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">Opcode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  case ISD::MULHS:</span>
<span class="c">  case ISD::MULHU: {</span>
<span class="c">    MultOpc = (Opcode == ISD::MULHU ? Cpu0::MULTu : Cpu0::MULT);</span>
<span class="c">    return SelectMULT(Node, MultOpc, DL, NodeTy, false, true).second;</span>
<span class="c">  }</span>
<span class="cp">#endif</span>
 <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Let&#8217;s run above changes with ch4_2.cpp as well as <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-view-sched-dags</span></tt> option
to get <a class="pageref" href="#otherinst-f3">Figure  3</a>.
Instruction SMMUL will get the high word of multiply result.</p>
<div class="figure align-center" id="otherinst-f3">
<a class="reference internal image-reference" href="_images/33.png"><img alt="_images/33.png" src="_images/33.png" style="width: 684.0px; height: 743.0px;" /></a>
<p class="caption">Figure 3: DAG for ch4_2.bc with ARM style SMMUL</p>
</div>
<p>The following is the result of run above changes with ch4_2.bc.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_
debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_2.bc -o -
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;ch4_2.bc&quot;</span>
        .text
        .globl        main
        .align        2
        .type main,@function
        .ent  main                    <span class="c"># @main</span>
main:
        .cfi_startproc
        .frame        <span class="nv">$fp</span>,8,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:                                 # %entry</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
        .cfi_def_cfa_offset 8
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 11
        st    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        lui   <span class="nv">$2</span>, 10922
        ori   <span class="nv">$3</span>, <span class="nv">$2</span>, 43691
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 12
        smmul <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        shr   <span class="nv">$4</span>, <span class="nv">$3</span>, 31
        sra   <span class="nv">$3</span>, <span class="nv">$3</span>, 1
        addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        mul   <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        subu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        st    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  main
<span class="nv">$tmp2</span>:
        .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
        .cfi_endproc
</pre></div>
</div>
<p>The other instruction UMMUL and llvm IR mulhu are unsigned int type for
operator %.
You can check it by unmark the <strong>“unsigned int b = 11;”</strong> in ch4_2.cpp.</p>
<p>Uses SMMUL instruction to get the high word of multiplication result is adopted
in ARM.</p>
</div>
<div class="section" id="mips-solution">
<h4><a class="toc-backref" href="#id24">Mips solution</a><a class="headerlink" href="#mips-solution" title="Permalink to this headline">¶</a></h4>
<p>Mips uses MULT instruction and save the high &amp; low part to registers HI and LO,
respectively.
After that, uses mfhi/mflo to move register HI/LO to your general purpose
registers.
ARM SMMUL is fast if you only need the HI part of result (it ignores the LO part
of operation). ARM also provides SMULL (signed multiply long) to get the whole
64 bits result.
If you need the LO part of result, you can use Cpu0 MUL instruction to get the
LO part of result only.
Chapter4_1/ is implemented with Mips MULT style.
We choose it as the implementation of this book for adding instructions as less
as possible. This approach make Cpu0 better both as a tutorial architecture
for school teaching purpose material, and an engineer learning
materials in compiler design.
The MULT, MULTu, MFHI, MFLO, MTHI, MTLO added in Chapter4_1/Cpu0InstrInfo.td;
HI, LO registers in Chapter4_1/Cpu0RegisterInfo.td and Chapter4_1/MCTargetDesc/
Cpu0BaseInfo.h; IIHiLo, IIImul in Chapter4_1/Cpu0Schedule.td; SelectMULT() in
Chapter4_1/Cpu0ISelDAGToDAG.cpp are for Mips style implementation.</p>
<p>The related DAG nodes, mulhs and mulhu, both are used in Chapter4_1/, which
come from TargetSelectionDAG.td as follows,</p>
<p class="rubric">include/llvm/Target/TargetSelectionDAG.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">mulhs</span>    <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;ISD::MULHS&quot;</span>     <span class="p">,</span> <span class="n">SDTIntBinOp</span><span class="p">,</span> <span class="p">[</span><span class="n">SDNPCommutative</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">mulhu</span>    <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;ISD::MULHU&quot;</span>     <span class="p">,</span> <span class="n">SDTIntBinOp</span><span class="p">,</span> <span class="p">[</span><span class="n">SDNPCommutative</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Except the custom type, llvm IR operations of type expand and promote will call
Cpu0DAGToDAGISel::Select() during instruction selection of DAG translation.
The SelectMULT() which called by Select() return the HI part of
multiplication result to HI register for IR operations of mulhs or mulhu.
After that, MFHI instruction moves the HI register to Cpu0 field &#8220;a&#8221; register,
$ra.
MFHI instruction is FL format and only use Cpu0 field &#8220;a&#8221; register, we set
the $rb and imm16 to 0.
<a class="pageref" href="#otherinst-f4">Figure  4</a> and ch4_2.cpu0.s are the results of compile ch4_2.bc.</p>
<div class="figure align-center" id="otherinst-f4">
<a class="reference internal image-reference" href="_images/43.png"><img alt="_images/43.png" src="_images/43.png" style="width: 498.6px; height: 753.3px;" /></a>
<p class="caption">Figure 4: DAG for ch4_2.bc with Mips style MULT</p>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:input Jonathan<span class="nv">$ </span>cat ch4_2.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch4_2.bc&quot;</span>
  .text
  .globl  _Z8test_modv
  .align  2
  .type _Z8test_modv,@function
  .ent  _Z8test_modv            <span class="c"># @_Z8test_modv</span>
_Z8test_modv:
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 11
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lui <span class="nv">$2</span>, 10922
  ori <span class="nv">$3</span>, <span class="nv">$2</span>, 43691
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 12
  mult  <span class="nv">$2</span>, <span class="nv">$3</span>
  mfhi  <span class="nv">$3</span>
  shr <span class="nv">$4</span>, <span class="nv">$3</span>, 31
  sra <span class="nv">$3</span>, <span class="nv">$3</span>, 1
  addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  mul <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  subu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z8test_modv
<span class="nv">$tmp1</span>:
  .size _Z8test_modv, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z8test_modv
</pre></div>
</div>
</div>
<div class="section" id="full-support-and">
<h4><a class="toc-backref" href="#id25">Full support %, and /</a><a class="headerlink" href="#full-support-and" title="Permalink to this headline">¶</a></h4>
<p>The sensitive readers may find llvm using <strong>“multiplication”</strong> instead
of <strong>“div”</strong> to get the <strong>“%”</strong> result just because our example uses
constant as divider, <strong>“(b+1)%12”</strong> in our example.
If programmer uses variable as the divider like <strong>“(b+1)%a”</strong>, then: what will
happen next?
The answer is our code will has error in handling this.</p>
<p>Cpu0 just like Mips uses LO and HI registers to hold the <strong>&#8220;quotient&#8221;</strong> and
<strong>&#8220;remainder&#8221;</strong>. And
uses instructions <strong>“mflo”</strong> and <strong>“mfhi”</strong> to get the result from LO or HI
registers furthermore.
With this solution, the <strong>“c = a / b”</strong> can be finished by <strong>“div a, b”</strong> and
<strong>“mflo c”</strong>; the <strong>“c = a % b”</strong> can be finished by <strong>“div a, b”</strong> and
<strong>“mfhi c”</strong>.</p>
<p>To supports operators <strong>“%”</strong> and <strong>“/”</strong>, the following code added in
Chapter4_1.</p>
<ol class="arabic simple">
<li>SDIV, UDIV and it&#8217;s reference class, nodes in Cpu0InstrInfo.td.</li>
<li>The copyPhysReg() declared and defined in Cpu0InstrInfo.h and
Cpu0InstrInfo.cpp.</li>
<li>The setOperationAction(ISD::SDIV, MVT::i32, Expand), ...,
setTargetDAGCombine(ISD::SDIVREM) in constructore of Cpu0ISelLowering.cpp;
PerformDivRemCombine() and PerformDAGCombine() in Cpu0ISelLowering.cpp.</li>
</ol>
<p>The IR instruction <strong>sdiv</strong> stands for signed div while <strong>udiv</strong> stands for
unsigned div.</p>
<p class="rubric">lbdex/input/ch4_2_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_mod</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>

  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">a</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we run with ch4_2_1.cpp, the <strong>“div”</strong> cannot be gotten for operator
<strong>“%”</strong>.
It still uses <strong>&#8220;multiplication&#8221;</strong> instead of <strong>&#8220;div&#8221;</strong> in ch4_2_1.cpp because
llvm do <strong>“Constant Propagation Optimization”</strong> in this.
The ch4_2_2.cpp will get the &#8220;div&#8221; result for operator <strong>“%”</strong> but it cannot
be compiled at this point. It needs &#8220;function call argument support&#8221; in Chapter
9 of Function call.
The ch4_2_2.cpp can get the <strong>“div”</strong> for <strong>“%”</strong> result since it makes
llvm <strong>“Constant Propagation Optimization”</strong> useless in it.</p>
<p class="rubric">lbdex/input/ch4_2_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_mod</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
  
  <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">c</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-77-79:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch4_2_2.cpp -emit-llvm -o ch4_2_2.bc
118-165-77-79:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_
debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_2_2.bc -o -
...
div <span class="nv">$zero</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
mflo  <span class="nv">$2</span>
...
</pre></div>
</div>
<p>To explains how work with <strong>“div”</strong>, let&#8217;s run Chapter9_3 with
ch4_2_2.cpp as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-83-58:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch4_2_2.cpp -I/Applications/Xcode.app/Contents/Developer/Platforms/
MacOSX.platform/Developer/SDKs/MacOSX10.8.sdk/usr/include/ -emit-llvm -o
ch4_2_2.bc
118-165-83-58:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch4_2_2.bc -o -
Args: /Users/Jonathan/llvm/test/cmake_debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch4_2_2.bc -o -

<span class="o">===</span> _Z8test_modi
Initial selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 21 nodes:
  0x7fed68410bc8: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882cb10: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882cd10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882ce10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt;

  0x7fed6882d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

      0x7fed68410bc8: &lt;multiple use&gt;
        0x7fed68410bc8: &lt;multiple use&gt;
        0x7fed6882ca10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;-1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

        0x7fed6882cb10: &lt;multiple use&gt;
      0x7fed6882cc10: i32,ch <span class="o">=</span> load 0x7fed68410bc8, 0x7fed6882ca10,
      0x7fed6882cb10&lt;LD4<span class="o">[</span>FixedStack-1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7fed6882cd10: &lt;multiple use&gt;
      0x7fed6882cb10: &lt;multiple use&gt;
    0x7fed6882cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed68410bc8, 0x7fed6882cc10, 0x7fed6882cd10,
    0x7fed6882cb10&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

    0x7fed6882d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;11&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

    0x7fed6882d110: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882d210: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed6882cf10, 0x7fed6882d010, 0x7fed6882d110,
  0x7fed6882cb10&lt;ST4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

    0x7fed6882d210: &lt;multiple use&gt;
    0x7fed6882d110: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882d310: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882d110,
  0x7fed6882cb10&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span>

    0x7fed6882d210: &lt;multiple use&gt;
    0x7fed6882cd10: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882d610: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882cd10,
  0x7fed6882cb10&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

      0x7fed6882d310: &lt;multiple use&gt;
      0x7fed6882d610: &lt;multiple use&gt;
    0x7fed6882d810: <span class="nv">ch</span> <span class="o">=</span> TokenFactor 0x7fed6882d310:1, 0x7fed6882d610:1 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

        0x7fed6882d310: &lt;multiple use&gt;
        0x7fed6882d410: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

      0x7fed6882d510: <span class="nv">i32</span> <span class="o">=</span> add 0x7fed6882d310, 0x7fed6882d410 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

      0x7fed6882d610: &lt;multiple use&gt;
    0x7fed6882d710: <span class="nv">i32</span> <span class="o">=</span> srem 0x7fed6882d510, 0x7fed6882d610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

    0x7fed6882d110: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882fc10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed6882d810, 0x7fed6882d710, 0x7fed6882d110,
  0x7fed6882cb10&lt;ST4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

  0x7fed6882fe10: <span class="nv">i32</span> <span class="o">=</span> Register %V0

    0x7fed6882fc10: &lt;multiple use&gt;
    0x7fed6882fe10: &lt;multiple use&gt;
      0x7fed6882fc10: &lt;multiple use&gt;
      0x7fed6882d110: &lt;multiple use&gt;
      0x7fed6882cb10: &lt;multiple use&gt;
    0x7fed6882fd10: i32,ch <span class="o">=</span> load 0x7fed6882fc10, 0x7fed6882d110,
    0x7fed6882cb10&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>8<span class="o">]</span>

  0x7fed6882ff10: ch,glue <span class="o">=</span> CopyToReg 0x7fed6882fc10, 0x7fed6882fe10,
  0x7fed6882fd10

    0x7fed6882ff10: &lt;multiple use&gt;
    0x7fed6882fe10: &lt;multiple use&gt;
    0x7fed6882ff10: &lt;multiple use&gt;
  0x7fed68830010: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fed6882ff10, 0x7fed6882fe10,
  0x7fed6882ff10:1

Replacing.1 0x7fed6882fd10: i32,ch <span class="o">=</span> load 0x7fed6882fc10, 0x7fed6882d110,
0x7fed6882cb10&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>8<span class="o">]</span>

With: 0x7fed6882d710: <span class="nv">i32</span> <span class="o">=</span> srem 0x7fed6882d510, 0x7fed6882d610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>
 and 1 other values

Replacing.1 0x7fed6882d310: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882d110,
0x7fed6882cb10&lt;LD4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span>

With: 0x7fed6882d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;11&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>
 and 1 other values

Replacing.3 0x7fed6882d810: <span class="nv">ch</span> <span class="o">=</span> TokenFactor 0x7fed6882d210,
0x7fed6882d610:1 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

With: 0x7fed6882d610: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882cd10,
0x7fed6882cb10&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>


Replacing.3 0x7fed6882d510: <span class="nv">i32</span> <span class="o">=</span> add 0x7fed6882d010, 0x7fed6882d410 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

With: 0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt;


Replacing.1 0x7fed6882cc10: i32,ch <span class="o">=</span> load 0x7fed68410bc8, 0x7fed6882ca10,
0x7fed6882cb10&lt;LD4<span class="o">[</span>FixedStack-1<span class="o">](</span><span class="nv">align</span><span class="o">=</span>8<span class="o">)</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

With: 0x7fed6882cc10: i32,ch <span class="o">=</span> load 0x7fed68410bc8, 0x7fed6882ca10,
0x7fed6882cb10&lt;LD4<span class="o">[</span>FixedStack-1<span class="o">](</span><span class="nv">align</span><span class="o">=</span>8<span class="o">)</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>
 and 1 other values
Optimized lowered selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 16 nodes:
  0x7fed68410bc8: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882cb10: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882cd10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

  0x7fed6882d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

        0x7fed68410bc8: &lt;multiple use&gt;
          0x7fed68410bc8: &lt;multiple use&gt;
          0x7fed6882ca10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;-1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

          0x7fed6882cb10: &lt;multiple use&gt;
        0x7fed6882cc10: i32,ch <span class="o">=</span> load 0x7fed68410bc8, 0x7fed6882ca10,
        0x7fed6882cb10&lt;LD4<span class="o">[</span>FixedStack-1<span class="o">](</span><span class="nv">align</span><span class="o">=</span>8<span class="o">)</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

        0x7fed6882cd10: &lt;multiple use&gt;
        0x7fed6882cb10: &lt;multiple use&gt;
      0x7fed6882cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed68410bc8, 0x7fed6882cc10, 0x7fed6882cd10,
      0x7fed6882cb10&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7fed6882d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;11&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

      0x7fed6882d110: &lt;multiple use&gt;
      0x7fed6882cb10: &lt;multiple use&gt;
    0x7fed6882d210: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed6882cf10, 0x7fed6882d010, 0x7fed6882d110,
    0x7fed6882cb10&lt;ST4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

    0x7fed6882cd10: &lt;multiple use&gt;
    0x7fed6882cb10: &lt;multiple use&gt;
  0x7fed6882d610: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882cd10,
  0x7fed6882cb10&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

    0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt;

    0x7fed6882d610: &lt;multiple use&gt;
  0x7fed6882d710: <span class="nv">i32</span> <span class="o">=</span> srem 0x7fed6882d810, 0x7fed6882d610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

  0x7fed6882fe10: <span class="nv">i32</span> <span class="o">=</span> Register %V0

      0x7fed6882d610: &lt;multiple use&gt;
      0x7fed6882d710: &lt;multiple use&gt;
      0x7fed6882d110: &lt;multiple use&gt;
      0x7fed6882cb10: &lt;multiple use&gt;
    0x7fed6882fc10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fed6882d610:1, 0x7fed6882d710, 0x7fed6882d110,
    0x7fed6882cb10&lt;ST4<span class="o">[</span>%b<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span>

    0x7fed6882fe10: &lt;multiple use&gt;
    0x7fed6882d710: &lt;multiple use&gt;
  0x7fed6882ff10: ch,glue <span class="o">=</span> CopyToReg 0x7fed6882fc10, 0x7fed6882fe10,
  0x7fed6882d710

    0x7fed6882ff10: &lt;multiple use&gt;
    0x7fed6882fe10: &lt;multiple use&gt;
    0x7fed6882ff10: &lt;multiple use&gt;
  0x7fed68830010: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fed6882ff10, 0x7fed6882fe10,
  0x7fed6882ff10:1

Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 16 nodes:
  ...
  0x7fed6882d610: i32,ch <span class="o">=</span> load 0x7fed6882d210, 0x7fed6882cd10,
  0x7fed6882cb10&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fed6882d610: &lt;multiple use&gt;
  0x7fed6882d710: <span class="nv">i32</span> <span class="o">=</span> srem 0x7fed6882d810, 0x7fed6882d610 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>
  ...

Legalized selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 16 nodes:
  0x7fed68410bc8: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>

  0x7fed6882cb10: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>2<span class="o">]</span>

  0x7fed6882cd10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>3<span class="o">]</span>

  0x7fed6882d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

  0x7fed6882fe10: <span class="nv">i32</span> <span class="o">=</span> Register %V0 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>
  ...
    0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

    0x7fed6882d610: &lt;multiple use&gt;
  0x7fed6882ce10: i32,i32 <span class="o">=</span> sdivrem 0x7fed6882d810, 0x7fed6882d610


Optimized legalized selection DAG: BB#0 <span class="s1">&#39;_Z8test_modi:&#39;</span>
SelectionDAG has 18 nodes:
  ...
    0x7fed6882d510: <span class="nv">i32</span> <span class="o">=</span> Register %HI

      0x7fed6882d810: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;12&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

      0x7fed6882d610: &lt;multiple use&gt;
    0x7fed6882d410: <span class="nv">glue</span> <span class="o">=</span> Cpu0ISD::DivRem 0x7fed6882d810, 0x7fed6882d610

  0x7fed6882d310: i32,ch,glue <span class="o">=</span> CopyFromReg 0x7fed68410bc8, 0x7fed6882d510,
  0x7fed6882d410
  ...

<span class="o">=====</span> Instruction selection begins: BB#0 <span class="s1">&#39;&#39;</span>
...
Selecting: 0x7fed6882d410: <span class="nv">glue</span> <span class="o">=</span> Cpu0ISD::DivRem 0x7fed6882d810,
0x7fed6882d610 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>13<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fed6882d410: <span class="nv">glue</span> <span class="o">=</span>
Cpu0ISD::DivRem 0x7fed6882d810, 0x7fed6882d610 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>13<span class="o">]</span>

  Initial Opcode index to 1355
  Morphed node: 0x7fed6882d410: i32,glue <span class="o">=</span> SDIV 0x7fed6882d810, 0x7fed6882d610

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fed6882d410: i32,glue <span class="o">=</span> SDIV 0x7fed6882d810, 0x7fed6882d610
...
</pre></div>
</div>
<p>According above DAGs translation messages, llvm do the following things:</p>
<ol class="arabic simple">
<li>Reduce DAG nodes in stage &#8220;Optimized lowered selection DAG&#8221; (Replacing ...
displayed before &#8220;Optimized lowered selection DAG: BB#0 &#8216;_Z8test_modi:entry&#8217;
&#8221;).
Since SSA form has some redundant nodes for store and load, them can be
removed.</li>
<li>Change DAG srem to sdivrem in stage &#8220;Legalized selection DAG&#8221;.</li>
<li>Change DAG sdivrem to Cpu0ISD::DivRem and in stage &#8220;Optimized legalized
selection DAG&#8221;.</li>
<li>Add DAG &#8220;0x7fd25b830710: i32 = Register %HI&#8221; and &#8220;CopyFromReg 0x7fd25b410e18,
0x7fd25b830710, 0x7fd25b830910&#8221; in stage &#8220;Optimized legalized selection DAG&#8221;.</li>
</ol>
<p>Summary as Table: Stages for C operator % and Table: Functions handle the DAG
translation and pattern match for C operator %.</p>
<table border="1" class="docutils">
<caption>Stages for C operator %</caption>
<colgroup>
<col width="43%" />
<col width="26%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">IR/DAG/instruction</th>
<th class="head">IR/DAG/instruction</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>.bc</td>
<td>srem</td>
<td>&nbsp;</td>
</tr>
<tr class="row-odd"><td>Legalized selection DAG</td>
<td>sdivrem</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>Optimized legalized selection DAG</td>
<td>Cpu0ISD::DivRem</td>
<td>CopyFromReg xx, Hi, xx</td>
</tr>
<tr class="row-odd"><td>pattern match</td>
<td>div</td>
<td>mfhi</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption>Functions handle the DAG translation and pattern match for C operator %</caption>
<colgroup>
<col width="43%" />
<col width="57%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Translation</th>
<th class="head">Do by</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>srem =&gt; sdivrem</td>
<td>setOperationAction(ISD::SREM, MVT::i32, Expand);</td>
</tr>
<tr class="row-odd"><td>sdivrem =&gt; Cpu0ISD::DivRem</td>
<td>setTargetDAGCombine(ISD::SDIVREM);</td>
</tr>
<tr class="row-even"><td>sdivrem =&gt; CopyFromReg xx, Hi, xx</td>
<td>PerformDivRemCombine();</td>
</tr>
<tr class="row-odd"><td>Cpu0ISD::DivRem =&gt; div</td>
<td>SDIV (Cpu0InstrInfo.td)</td>
</tr>
<tr class="row-even"><td>CopyFromReg xx, Hi, xx =&gt; mfhi</td>
<td>MFLO (Cpu0InstrInfo.td)</td>
</tr>
</tbody>
</table>
<p>Item 2 as above, is triggered by code
&#8220;setOperationAction(ISD::SREM, MVT::i32, Expand);&#8221; in Cpu0ISelLowering.cpp.
About <strong>Expand</strong> please ref. <a class="footnote-reference" href="#id16" id="id7">[7]</a> and <a class="footnote-reference" href="#id17" id="id8">[8]</a>. Item 3 is triggered by code
&#8220;setTargetDAGCombine(ISD::SDIVREM);&#8221; in Cpu0ISelLowering.cpp.
Item 4 is did by PerformDivRemCombine() which called by PerformDAGCombine()
since the <strong>%</strong> corresponding <strong>srem</strong>
makes the &#8220;N-&gt;hasAnyUseOfValue(1)&#8221; to true in PerformDivRemCombine().
Then, it creates &#8220;CopyFromReg 0x7fd25b410e18, 0x7fd25b830710, 0x7fd25b830910&#8221;.
When using <strong>&#8220;/&#8221;</strong> in C, it will make &#8220;N-&gt;hasAnyUseOfValue(0)&#8221; to ture.
For sdivrem, <strong>sdiv</strong> makes &#8220;N-&gt;hasAnyUseOfValue(0)&#8221; true while <strong>srem</strong> makes
&#8220;N-&gt;hasAnyUseOfValue(1)&#8221; ture.</p>
<p>Above items will change the DAG when <tt class="docutils literal"><span class="pre">llc</span></tt> running. After that, the pattern
match defined in Chapter4_1/Cpu0InstrInfo.td will translate <strong>Cpu0ISD::DivRem</strong>
into <strong>div</strong>; and <strong>&#8220;CopyFromReg 0x7fd25b410e18, Register %H, 0x7fd25b830910&#8221;</strong>
to <strong>mfhi</strong>.</p>
<p>The ch4_3.cpp is for <strong>/</strong> div operator test.</p>
</div>
</div>
<div class="section" id="rotate-instructions">
<h3><a class="toc-backref" href="#id26">Rotate instructions</a><a class="headerlink" href="#rotate-instructions" title="Permalink to this headline">¶</a></h3>
<p>Chapter4_1 include the rotate operations translation. The instructions &#8220;rol&#8221;,
&#8220;ror&#8221;, &#8220;rolv&#8221; and &#8220;rorv&#8221; defined in Cpu0InstrInfo.td handle the translation.
Compile ch4_1_3.cpp will get Cpu0 &#8220;rol&#8221; instruction.</p>
<p class="rubric">lbdex/input/ch4_1_3.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_rotate_left</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">));</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef TEST_ROXV</span>

<span class="kt">int</span> <span class="nf">test_rotate_left1</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">n</span><span class="p">)));</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_rotate_right</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">((</span><span class="n">a</span> <span class="o">&gt;&gt;</span> <span class="n">n</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="mi">32</span> <span class="o">-</span> <span class="n">n</span><span class="p">)));</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>114-43-200-122:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch4_1_3.cpp -emit-llvm -o ch4_1_3.bc
114-43-200-122:input Jonathan<span class="nv">$ </span>llvm-dis ch4_1_3.bc -o -

define i32 @_Z16test_rotate_leftv<span class="o">()</span> <span class="c">#0 {</span>
  %a <span class="o">=</span> alloca i32, align 4
  %result <span class="o">=</span> alloca i32, align 4
  store i32 8, i32* %a, align 4
  %1 <span class="o">=</span> load i32* %a, align 4
  %2 <span class="o">=</span> shl i32 %1, 30
  %3 <span class="o">=</span> load i32* %a, align 4
  %4 <span class="o">=</span> ashr i32 %3, 2
  %5 <span class="o">=</span> or i32 %2, %4
  store i32 %5, i32* %result, align 4
  %6 <span class="o">=</span> load i32* %result, align 4
  ret i32 %6
<span class="o">}</span>

114-43-200-122:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/Debug/
bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch4_1_3.bc -o -
  ...
  rol <span class="nv">$2</span>, <span class="nv">$2</span>, 30
  ...
</pre></div>
</div>
<p>Instructions &#8220;rolv&#8221; and &#8220;rorv&#8221; cannot be tested at this moment, they need
function argument passing support.
The &#8220;#ifdef TEST_ROXV&#8221; part of ch4_1_3.cpp can be tested
after Chapter Function call. Like the previous subsection mentioned at this
chapter, some IRs in function &#64;_Z16test_rotate_leftv() will be combined into
one one IR <strong>rotl</strong> during DAGs translation.</p>
</div>
</div>
<div class="section" id="logic">
<h2><a class="toc-backref" href="#id27">Logic</a><a class="headerlink" href="#logic" title="Permalink to this headline">¶</a></h2>
<p>Chapter4_2 supports logic operators <strong>&amp;, |, ^, !, ==, !=, &lt;, &lt;=, &gt; and &gt;=</strong>.
They are trivial and easy. Listing the added code with comments and table for
these operators IR, DAG and instructions as below. Please check them with the
run result of bc and asm instructions for ch4_5.cpp as below.</p>
<p class="rubric">lbdex/chapters/Chapter4_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre>let Predicates = [Ch4_2] in {
class CmpInstr&lt;bits&lt;8&gt; op, string instr_asm, 
               InstrItinClass itin, RegisterClass RC, RegisterClass RD, 
               bit isComm = 0&gt;:
  FA&lt;op, (outs RD:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;), [], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;
//#if CH &gt;= CH10_1
  let DecoderMethod = &quot;DecodeCMPInstruction&quot;;
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>// SetCC
let Predicates = [Ch4_2] in {
class SetCC_R&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op,
              RegisterClass RC&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $rc&quot;),
     [(set GPROut:$ra, (cond_op RC:$rb, RC:$rc))],
     IIAlu&gt;, Requires&lt;[HasSlt]&gt; {
  let shamt = 0;
}

class SetCC_I&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op, Operand Od,
              PatLeaf imm_type, RegisterClass RC&gt;:
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, &quot;\t$ra, $rb, $imm16&quot;),
     [(set GPROut:$ra, (cond_op RC:$rb, imm_type:$imm16))],
     IIAlu&gt;, Requires&lt;[HasSlt]&gt; {
}
}
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">ANDi</span>    <span class="o">:</span> <span class="n">ArithLogicI</span><span class="o">&lt;</span><span class="mh">0x0c</span><span class="p">,</span> <span class="s">&quot;andi&quot;</span><span class="p">,</span> <span class="n">and</span><span class="p">,</span> <span class="n">uimm16</span><span class="p">,</span> <span class="n">immZExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">XORi</span>    <span class="o">:</span> <span class="n">ArithLogicI</span><span class="o">&lt;</span><span class="mh">0x0e</span><span class="p">,</span> <span class="s">&quot;xori&quot;</span><span class="p">,</span> <span class="n">xor</span><span class="p">,</span> <span class="n">uimm16</span><span class="p">,</span> <span class="n">immZExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">HasCmp</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">CMP</span>     <span class="o">:</span> <span class="n">CmpInstr</span><span class="o">&lt;</span><span class="mh">0x10</span><span class="p">,</span> <span class="s">&quot;cmp&quot;</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">SR</span><span class="p">,</span> <span class="mi">0</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">AND</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x18</span><span class="p">,</span> <span class="s">&quot;and&quot;</span><span class="p">,</span> <span class="n">and</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">OR</span>      <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x19</span><span class="p">,</span> <span class="s">&quot;or&quot;</span><span class="p">,</span> <span class="n">or</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">XOR</span>     <span class="o">:</span> <span class="n">ArithLogicR</span><span class="o">&lt;</span><span class="mh">0x1a</span><span class="p">,</span> <span class="s">&quot;xor&quot;</span><span class="p">,</span> <span class="n">xor</span><span class="p">,</span> <span class="n">IIAlu</span><span class="p">,</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="mi">1</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch4_2</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">HasSlt</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">SLTi</span>    <span class="o">:</span> <span class="n">SetCC_I</span><span class="o">&lt;</span><span class="mh">0x26</span><span class="p">,</span> <span class="s">&quot;slti&quot;</span><span class="p">,</span> <span class="n">setlt</span><span class="p">,</span> <span class="n">simm16</span><span class="p">,</span> <span class="n">immSExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SLTiu</span>   <span class="o">:</span> <span class="n">SetCC_I</span><span class="o">&lt;</span><span class="mh">0x27</span><span class="p">,</span> <span class="s">&quot;sltiu&quot;</span><span class="p">,</span> <span class="n">setult</span><span class="p">,</span> <span class="n">simm16</span><span class="p">,</span> <span class="n">immSExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SLT</span>     <span class="o">:</span> <span class="n">SetCC_R</span><span class="o">&lt;</span><span class="mh">0x28</span><span class="p">,</span> <span class="s">&quot;slt&quot;</span><span class="p">,</span> <span class="n">setlt</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SLTu</span>    <span class="o">:</span> <span class="n">SetCC_R</span><span class="o">&lt;</span><span class="mh">0x29</span><span class="p">,</span> <span class="s">&quot;sltu&quot;</span><span class="p">,</span> <span class="n">setult</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>let Predicates = [Ch4_2] in {
def : Pat&lt;(not CPURegs:$in),
// 1: in == 0; 0: in != 0
          (XORi CPURegs:$in, 1)&gt;;
}
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>// setcc patterns

let Predicates = [Ch4_2] in {
// setcc for cmp instruction
multiclass SeteqPatsCmp&lt;RegisterClass RC&gt; {
// a == b
  def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
            (SHR (ANDi (CMP RC:$lhs, RC:$rhs), 2), 1)&gt;;
// a != b
  def : Pat&lt;(setne RC:$lhs, RC:$rhs),
            (XORi (SHR (ANDi (CMP RC:$lhs, RC:$rhs), 2), 1), 1)&gt;;
}

// a &lt; b
multiclass SetltPatsCmp&lt;RegisterClass RC&gt; {
  def : Pat&lt;(setlt RC:$lhs, RC:$rhs),
            (ANDi (CMP RC:$lhs, RC:$rhs), 1)&gt;;
// if cpu0  `define N    `SW[31]  instead of `SW[0] // Negative flag, then need
// 2 more instructions as follows,
//          (XORi (ANDi (SHR (CMP RC:$lhs, RC:$rhs), (LUi 0x8000), 31), 1), 1)&gt;;
  def : Pat&lt;(setult RC:$lhs, RC:$rhs),
            (ANDi (CMP RC:$lhs, RC:$rhs), 1)&gt;;
}

// a &lt;= b
multiclass SetlePatsCmp&lt;RegisterClass RC&gt; {
  def : Pat&lt;(setle RC:$lhs, RC:$rhs),
// a &lt;= b is equal to (XORi (b &lt; a), 1)
            (XORi (ANDi (CMP RC:$rhs, RC:$lhs), 1), 1)&gt;;
  def : Pat&lt;(setule RC:$lhs, RC:$rhs),
            (XORi (ANDi (CMP RC:$rhs, RC:$lhs), 1), 1)&gt;;
}

// a &gt; b
multiclass SetgtPatsCmp&lt;RegisterClass RC&gt; {
  def : Pat&lt;(setgt RC:$lhs, RC:$rhs),
// a &gt; b is equal to b &lt; a is equal to setlt(b, a)
            (ANDi (CMP RC:$rhs, RC:$lhs), 1)&gt;;
  def : Pat&lt;(setugt RC:$lhs, RC:$rhs),
            (ANDi (CMP RC:$rhs, RC:$lhs), 1)&gt;;
}

// a &gt;= b
multiclass SetgePatsCmp&lt;RegisterClass RC&gt; {
  def : Pat&lt;(setge RC:$lhs, RC:$rhs),
// a &gt;= b is equal to b &lt;= a
            (XORi (ANDi (CMP RC:$lhs, RC:$rhs), 1), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, RC:$rhs),
            (XORi (ANDi (CMP RC:$lhs, RC:$rhs), 1), 1)&gt;;
}

// setcc for slt instruction
multiclass SeteqPatsSlt&lt;RegisterClass RC, Instruction SLTiuOp, Instruction XOROp,
                     Instruction SLTuOp, Register ZEROReg&gt; {
// a == b
  def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
                (SLTiuOp (XOROp RC:$lhs, RC:$rhs), 1)&gt;;
// a != b
  def : Pat&lt;(setne RC:$lhs, RC:$rhs),
                (SLTuOp ZEROReg, (XOROp RC:$lhs, RC:$rhs))&gt;;
}

// a &lt;= b
multiclass SetlePatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setle RC:$lhs, RC:$rhs),
// a &lt;= b is equal to (XORi (b &lt; a), 1)
                (XORi (SLTOp RC:$rhs, RC:$lhs), 1)&gt;;
  def : Pat&lt;(setule RC:$lhs, RC:$rhs),
                (XORi (SLTuOp RC:$rhs, RC:$lhs), 1)&gt;;
}

// a &gt; b
multiclass SetgtPatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setgt RC:$lhs, RC:$rhs),
// a &gt; b is equal to b &lt; a is equal to setlt(b, a)
                (SLTOp RC:$rhs, RC:$lhs)&gt;;
  def : Pat&lt;(setugt RC:$lhs, RC:$rhs),
                (SLTuOp RC:$rhs, RC:$lhs)&gt;;
}

// a &gt;= b
multiclass SetgePatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setge RC:$lhs, RC:$rhs),
// a &gt;= b is equal to b &lt;= a
                (XORi (SLTOp RC:$lhs, RC:$rhs), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, RC:$rhs),
                (XORi (SLTuOp RC:$lhs, RC:$rhs), 1)&gt;;
}

multiclass SetgeImmPatsSlt&lt;RegisterClass RC, Instruction SLTiOp,
                        Instruction SLTiuOp&gt; {
  def : Pat&lt;(setge RC:$lhs, immSExt16:$rhs),
                (XORi (SLTiOp RC:$lhs, immSExt16:$rhs), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, immSExt16:$rhs),
                (XORi (SLTiuOp RC:$lhs, immSExt16:$rhs), 1)&gt;;
}

let Predicates = [HasSlt] in {
defm : SeteqPatsSlt&lt;CPURegs, SLTiu, XOR, SLTu, ZERO&gt;;
defm : SetlePatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgtPatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgePatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgeImmPatsSlt&lt;CPURegs, SLTi, SLTiu&gt;;
}

let Predicates = [HasCmp] in {
defm : SeteqPatsCmp&lt;CPURegs&gt;;
defm : SetltPatsCmp&lt;CPURegs&gt;;
defm : SetlePatsCmp&lt;CPURegs&gt;;
defm : SetgtPatsCmp&lt;CPURegs&gt;;
defm : SetgePatsCmp&lt;CPURegs&gt;;
}
} // let Predicates = [Ch4_2]
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter4_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Cpu0 doesn&#39;t have sext_inreg, replace them with shl/sra.</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i1</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i8</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i16</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SIGN_EXTEND_INREG</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span> <span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch4_5.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_andorxornot</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&amp;</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// c = 1</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">|</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// d = 7</span>
  <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">^</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// e = 6</span>
  <span class="n">b</span> <span class="o">=</span> <span class="o">!</span><span class="n">a</span><span class="p">;</span>       <span class="c1">// b = 0</span>
  
  <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 14</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_setxx</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">h</span><span class="p">;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// seq, c = 0</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// sne, d = 1</span>
  <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// slt, e = 0</span>
  <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// sle, f = 0</span>
  <span class="n">g</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">);</span>  <span class="c1">// sgt, g = 1</span>
  <span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">);</span> <span class="c1">// sge, g = 1</span>
  
  <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="o">+</span><span class="n">e</span><span class="o">+</span><span class="n">f</span><span class="o">+</span><span class="n">g</span><span class="o">+</span><span class="n">h</span><span class="p">);</span> <span class="c1">// 3</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>114-43-204-152:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch4_5.cpp -emit-llvm -o ch4_5.bc
114-43-204-152:input Jonathan<span class="nv">$ </span>llvm-dis ch4_5.bc -o -
...
; Function Attrs: nounwind uwtable
define i32 @_Z16test_andorxornotv<span class="o">()</span> <span class="c">#0 {</span>
entry:
  ...
  %and <span class="o">=</span> and i32 %0, %1
  ...
  %or <span class="o">=</span> or i32 %2, %3
  ...
  %xor <span class="o">=</span> xor i32 %4, %5
  ...
  %tobool <span class="o">=</span> icmp ne i32 %6, 0
  %lnot <span class="o">=</span> xor i1 %tobool, <span class="nb">true</span>
  %conv <span class="o">=</span> zext i1 %lnot to i32
  ...
<span class="o">}</span>

; Function Attrs: nounwind uwtable
define i32 @_Z10test_setxxv<span class="o">()</span> <span class="c">#0 {</span>
entry:
  ...
  %cmp <span class="o">=</span> icmp eq i32 %0, %1
  %conv <span class="o">=</span> zext i1 %cmp to i32
  store i32 %conv, i32* %c, align 4
  ...
  %cmp1 <span class="o">=</span> icmp ne i32 %2, %3
  %conv2 <span class="o">=</span> zext i1 %cmp1 to i32
  store i32 %conv2, i32* %d, align 4
  ...
  %cmp3 <span class="o">=</span> icmp slt i32 %4, %5
  %conv4 <span class="o">=</span> zext i1 %cmp3 to i32
  store i32 %conv4, i32* %e, align 4
  ...
  %cmp5 <span class="o">=</span> icmp sle i32 %6, %7
  %conv6 <span class="o">=</span> zext i1 %cmp5 to i32
  store i32 %conv6, i32* %f, align 4
  ...
  %cmp7 <span class="o">=</span> icmp sgt i32 %8, %9
  %conv8 <span class="o">=</span> zext i1 %cmp7 to i32
  store i32 %conv8, i32* %g, align 4
  ...
  %cmp9 <span class="o">=</span> icmp sge i32 %10, %11
  %conv10 <span class="o">=</span> zext i1 %cmp9 to i32
  store i32 %conv10, i32* %h, align 4
  ...
<span class="o">}</span>

114-43-204-152:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_5.bc -o -

  .globl  _Z16test_andorxornotv
  ...
  and <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  ...
  or  <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  ...
  xor <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  ...
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 2
  shr <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  ...

  .globl  _Z10test_setxxv
  ...
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 2
  shr <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  ...
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 2
  shr <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  xori  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  ...
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 1
  ...
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 1
  xori  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  ...
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 1
  ...
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 1
  xori  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  ...

114-43-204-152:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch4_5.bc -o -
  ...
      sltiu   <span class="nv">$2</span>, <span class="nv">$2</span>, 1
      andi    <span class="nv">$2</span>, <span class="nv">$2</span>, 1
      ...
</pre></div>
</div>
<table border="1" class="docutils">
<caption>Logic operators for cpu032I</caption>
<colgroup>
<col width="10%" />
<col width="32%" />
<col width="35%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">C</th>
<th class="head">.bc</th>
<th class="head">Optimized legalized selection DAG</th>
<th class="head">cpu032I</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&amp;, &amp;&amp;</td>
<td>and</td>
<td>and</td>
<td>and</td>
</tr>
<tr class="row-odd"><td>|, ||</td>
<td>or</td>
<td>or</td>
<td>or</td>
</tr>
<tr class="row-even"><td>^</td>
<td>xor</td>
<td>xor</td>
<td>xor</td>
</tr>
<tr class="row-odd"><td>!</td>
<td><ul class="first last simple">
<li>%tobool = icmp ne i32 %6, 0</li>
<li>%lnot = xor i1 %tobool, true</li>
<li>%conv = zext i1 %lnot to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%lnot = (setcc %tobool, 0, seteq)</li>
<li>%conv = (and %lnot, 1)</li>
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li>xor $3, $4, $3</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>==</td>
<td><ul class="first last simple">
<li>%cmp = icmp eq i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%cmp = (setcc %0, %1, seteq)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>cmp $sw, $3, $2</li>
<li>andi  $2, $sw, 2</li>
<li>shr $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>!=</td>
<td><ul class="first last simple">
<li>%cmp = icmp ne i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%cmp = (setcc %0, %1, setne)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>cmp $sw, $3, $2</li>
<li>andi  $2, $sw, 2</li>
<li>shr $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>&lt;</td>
<td><ul class="first last simple">
<li>%cmp = icmp lt i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>(setcc %0, %1, setlt)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>cmp $sw, $3, $2</li>
<li>andi  $2, $sw, 2</li>
<li>andi $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>&lt;=</td>
<td><ul class="first last simple">
<li>%cmp = icmp le i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>(setcc %0, %1, setle)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>cmp $sw, $2, $3</li>
<li>andi  $2, $sw, 1</li>
<li>xori  $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>&gt;</td>
<td><ul class="first last simple">
<li>%cmp = icmp gt i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>(setcc %0, %1, setgt)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>cmp $sw, $2, $3</li>
<li>andi  $2, $sw, 2</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>&gt;=</td>
<td><ul class="first last simple">
<li>%cmp = icmp le i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>(setcc %0, %1, setle)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>cmp $sw, $3, $2</li>
<li>andi  $2, $sw, 1</li>
<li>xori  $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption>Logic operators for cpu032II</caption>
<colgroup>
<col width="10%" />
<col width="32%" />
<col width="35%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">C</th>
<th class="head">.bc</th>
<th class="head">Optimized legalized selection DAG</th>
<th class="head">cpu032II</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&amp;, &amp;&amp;</td>
<td>and</td>
<td>and</td>
<td>and</td>
</tr>
<tr class="row-odd"><td>|, ||</td>
<td>or</td>
<td>or</td>
<td>or</td>
</tr>
<tr class="row-even"><td>^</td>
<td>xor</td>
<td>xor</td>
<td>xor</td>
</tr>
<tr class="row-odd"><td>!</td>
<td><ul class="first last simple">
<li>%tobool = icmp ne i32 %6, 0</li>
<li>%lnot = xor i1 %tobool, true</li>
<li>%conv = zext i1 %lnot to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%lnot = (setcc %tobool, 0, seteq)</li>
<li>%conv = (and %lnot, 1)</li>
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li>xor $3, $4, $3</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>==</td>
<td><ul class="first last simple">
<li>%cmp = icmp eq i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%cmp = (setcc %0, %1, seteq)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>xor $2, $3, $2</li>
<li>sltiu  $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>!=</td>
<td><ul class="first last simple">
<li>%cmp = icmp ne i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%cmp = (setcc %0, %1, setne)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>xor $2, $3, $2</li>
<li>sltu  $2, $zero, 2</li>
<li>shr $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>&lt;</td>
<td><ul class="first last simple">
<li>%cmp = icmp lt i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>(setcc %0, %1, setlt)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>slt $2, $3, $2</li>
<li>andi  $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>&lt;=</td>
<td><ul class="first last simple">
<li>%cmp = icmp le i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>(setcc %0, %1, setle)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>slt $2, $3, $2</li>
<li>xori  $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>&gt;</td>
<td><ul class="first last simple">
<li>%cmp = icmp gt i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>(setcc %0, %1, setgt)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>slt $2, $3, $2</li>
<li>andi  $2, $2, 1</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>&gt;=</td>
<td><ul class="first last simple">
<li>%cmp = icmp le i32 %0, %1</li>
<li>%conv = zext i1 %cmp to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>(setcc %0, %1, setle)</li>
<li>and %cmp, 1</li>
</ul>
</td>
<td><ul class="first last simple">
<li>slt $2, $3, $2</li>
<li>xori  $2, $2, 1</li>
<li>andi $2, $2, 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>In relation operators ==, !=, ..., %0 = $3 = 5, %1 = $2 = 3 for ch4_5.cpp.</p>
<p>The &#8220;Optimized legalized selection DAG&#8221; is the last DAG stage just before the
&#8220;instruction selection&#8221; as the section mentioned in this chapter. You can see
the whole DAG stages by <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> option.</p>
<p>From above result, slt spend less instructions than cmp for relation
operators translation. Beyond that, slt uses general purpose register while
cmp uses $sw dedicated register.</p>
<p class="rubric">lbdex/input/ch4_6.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_OptSlt</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">e</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-10:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -O2
-c ch4_6.cpp -emit-llvm -o ch4_6.bc
118-165-78-10:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch4_6.bc -o -
  ...
  ld  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 1
  andi  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  ld  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 1
  andi  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  ...
118-165-78-10:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch4_6.bc -o -
  ...
  ld  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  andi  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 2
  andi  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ...
</pre></div>
</div>
<p>Run these two <cite>llc -mcpu</cite> option for Chapter4_2 with ch4_6.cpp get the
above result. Regardless of the move between $sw and general purpose register
in <cite>llc -mcpu=cpu032I</cite>, the two cmp instructions in it will has hazard in
instruction reorder since both of them use $sw register but
<cite>llc -mcpu=cpu032II</cite> has not <a class="footnote-reference" href="#quantitative" id="id9">[9]</a>.
The slti version can reorder as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>...
ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 2
andi  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
ld  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
andi  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
...
</pre></div>
</div>
<p>Chapter4_2 include instructions cmp and slt. Even cpu032II include both of
these two instructions, the slt takes the priority since
&#8220;let Predicates = [HasSlt]&#8221; appeared before &#8220;let Predicates = [HasCmp]&#8221; in
Cpu0InstrInfo.td.</p>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id28">Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>List C operators, IR of .bc, Optimized legalized selection DAG and Cpu0
instructions implemented in this chapter in Table: Chapter 4 mathmetic
operators. There are over 20 operators totally in mathmetic and logic support in
this chapter and spend 4xx lines of source code.</p>
<table border="1" class="docutils">
<caption>Chapter 4 mathmetic operators</caption>
<colgroup>
<col width="15%" />
<col width="30%" />
<col width="33%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">C</th>
<th class="head">.bc</th>
<th class="head">Optimized legalized selection DAG</th>
<th class="head">Cpu0</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>+</td>
<td>add</td>
<td>add</td>
<td>addu</td>
</tr>
<tr class="row-odd"><td>-</td>
<td>sub</td>
<td>sub</td>
<td>subu</td>
</tr>
<tr class="row-even"><td>*</td>
<td>mul</td>
<td>mul</td>
<td>mul</td>
</tr>
<tr class="row-odd"><td>/</td>
<td>sdiv</td>
<td>Cpu0ISD::DivRem</td>
<td>div</td>
</tr>
<tr class="row-even"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>udiv</td>
<td>Cpu0ISD::DivRemU</td>
<td>divu</td>
</tr>
<tr class="row-odd"><td>&lt;&lt;</td>
<td>shl</td>
<td>shl</td>
<td>shl</td>
</tr>
<tr class="row-even"><td>&gt;&gt;</td>
<td><ul class="first last simple">
<li>ashr</li>
<li>lshr</li>
</ul>
</td>
<td><ul class="first last simple">
<li>sra</li>
<li>srl</li>
</ul>
</td>
<td><ul class="first last simple">
<li>sra</li>
<li>shr</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>!</td>
<td><ul class="first last simple">
<li>%tobool = icmp ne i32 %0, 0</li>
<li>%lnot = xor i1 %tobool, true</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%lnot = (setcc %tobool, 0, seteq)</li>
<li>%conv = (and %lnot, 1)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%1 = (xor %tobool, 0)</li>
<li>%true = (addiu $r0, 1)</li>
<li>%lnot = (xor %1, %true)</li>
</ul>
</td>
</tr>
<tr class="row-even"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td><ul class="first last simple">
<li>%conv = zext i1 %lnot to i32</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%conv = (and %lnot, 1)</li>
</ul>
</td>
<td><ul class="first last simple">
<li>%conv = (and %lnot, 1)</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>%</td>
<td><ul class="first last simple">
<li>srem</li>
<li>sremu</li>
</ul>
</td>
<td><ul class="first last simple">
<li>Cpu0ISD::DivRem</li>
<li>Cpu0ISD::DivRemU</li>
</ul>
</td>
<td><ul class="first last simple">
<li>div</li>
<li>divu</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>(x&lt;&lt;n)|(x&gt;&gt;32-n)</td>
<td>shl + lshr</td>
<td>rotl, rotr</td>
<td>rol, rolv, ror, rorv</td>
</tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html">http://llvm.org/docs/doxygen/html/structllvm_1_1InstrStage.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://msdn.microsoft.com/en-us/library/336xbhcz%28v=vs.80%29.aspx">http://msdn.microsoft.com/en-us/library/336xbhcz%28v=vs.80%29.aspx</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#ashr-instruction">http://llvm.org/docs/LangRef.html#ashr-instruction</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#lshr-instruction">http://llvm.org/docs/LangRef.html#lshr-instruction</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process">http://llvm.org/docs/CodeGenerator.html#selectiondag-instruction-selection-process</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#srem-instruction">http://llvm.org/docs/LangRef.html#srem-instruction</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#expand">http://llvm.org/docs/WritingAnLLVMBackend.html#expand</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html#selectiondag-legalizetypes-phase">http://llvm.org/docs/CodeGenerator.html#selectiondag-legalizetypes-phase</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[9]</a></td><td>See book Computer Architecture: A Quantitative Approach (The Morgan
Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="backendstructure.html">Backend structure</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="genobj.html">Generating object files</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>