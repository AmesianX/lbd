<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generating object files &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.7.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Global variables" href="globalvar.html" />
    <link rel="prev" title="Arithmetic and logic instructions" href="otherinst.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Generating object files</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="otherinst.html">Arithmetic and logic instructions</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="globalvar.html">Global variables</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="generating-object-files">
<span id="sec-genobjfiles"></span><h1>Generating object files<a class="headerlink" href="#generating-object-files" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#translate-into-obj-file" id="id3">Translate into obj file</a></li>
<li><a class="reference internal" href="#elf-obj-related-code" id="id4">ELF obj related code</a></li>
<li><a class="reference internal" href="#backend-target-registration-structure" id="id5">Backend Target Registration Structure</a></li>
</ul>
</div>
<p>The previous chapters introducing the assembly code generation only.
This chapter adding the elf obj support and verify the generated obj by
objdump utility. With LLVM support, the Cpu0 backend can generate both big
endian and little endian obj files with only a few code added.
The Target Registration mechanism and their structure are introduced in
this chapter.</p>
<div class="section" id="translate-into-obj-file">
<h2><a class="toc-backref" href="#id3">Translate into obj file</a><a class="headerlink" href="#translate-into-obj-file" title="Permalink to this headline">¶</a></h2>
<p>Currently, we only support translation of llvm IR code into assembly code.
If you try to run Chapter4_2/ to translate it into obj code will get the error
message as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Gamma@localhost 3<span class="o">]</span><span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/
llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>obj ch4_1.bc -o ch4_1.cpu0.o
~/llvm/test/cmake_debug_build/bin/llc: target does not
support generation of this file <span class="nb">type</span>!
</pre></div>
</div>
<p>Chapter5_1/ support obj file generation.
It produces obj files both for big endian and little endian with command
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-march=cpu0</span></tt> and <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-march=cpu0el</span></tt>, respectively.
Run with them will get the obj files as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Gamma@localhost input<span class="o">]</span><span class="nv">$ </span>cat ch4_1.cpu0.s
...
  .set  nomacro
<span class="c"># BB#0:                                 # %entry</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 40
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
...

<span class="o">[</span>Gamma@localhost 3<span class="o">]</span><span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/
llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>obj ch4_1.bc -o ch4_1.cpu0.o
<span class="o">[</span>Gamma@localhost input<span class="o">]</span><span class="nv">$ </span>objdump -s ch4_1.cpu0.o

ch4_1.cpu0.o:     file format elf32-big

Contents of section .text:
 0000 09ddffc8 09200005 022d0034 09200002  ..... ...-.4. ..
 0010 022d0030 0920fffb 022d002c 012d0030  .-.0. ...-.,.-.0
 0020 013d0034 11232000 022d0028 012d0030  .<span class="o">=</span>.4.# ..-.<span class="o">(</span>.-.0
 0030 013d0034 12232000 022d0024 012d0030  .<span class="o">=</span>.4.# ..-.<span class="nv">$.</span>-.0
 0040 013d0034 17232000 022d0020 012d0034  .<span class="o">=</span>.4.# ..-. .-.4
 0050 1e220002 022d001c 012d002c 1e220001  .<span class="s2">&quot;...-...-.,.&quot;</span>..
 0060 022d000c 012d0034 1d220002 022d0018  .-...-.4.<span class="s2">&quot;...-..</span>
<span class="s2"> 0070 012d002c 1f22001e 022d0008 09200001  .-.,.&quot;</span>...-... ..
 0080 013d0034 21323000 023d0014 013d0030  .<span class="o">=</span>.4!20..<span class="o">=</span>...<span class="o">=</span>.0
 0090 21223000 022d0004 09200080 013d0034  !<span class="s2">&quot;0..-... ...=.4</span>
<span class="s2"> 00a0 22223000 022d0010 012d0034 013d0030  &quot;&quot;0..-...-.4.=.0</span>
<span class="s2"> 00b0 20232000 022d0000 09dd0038 3ce00000   # ..-.....8&lt;...</span>

<span class="s2">[Gamma@localhost input]$ ~/llvm/test/</span>
<span class="s2">cmake_debug_build/bin/llc -march=cpu0el -relocation-model=pic -filetype=obj</span>
<span class="s2">ch4_1.bc -o ch4_1.cpu0el.o</span>
<span class="s2">[Gamma@localhost input]$ objdump -s ch4_1.cpu0el.o</span>

<span class="s2">ch4_1.cpu0el.o:     file format elf32-little</span>

<span class="s2">Contents of section .text:</span>
<span class="s2"> 0000 c8ffdd09 05002009 34002d02 02002009  ...... .4.-... .</span>
<span class="s2"> 0010 30002d02 fbff2009 2c002d02 30002d01  0.-... .,.-.0.-.</span>
<span class="s2"> 0020 34003d01 00202311 28002d02 30002d01  4.=.. #.(.-.0.-.</span>
<span class="s2"> 0030 34003d01 00202312 24002d02 30002d01  4.=.. #.$.-.0.-.</span>
<span class="s2"> 0040 34003d01 00202317 20002d02 34002d01  4.=.. #. .-.4.-.</span>
<span class="s2"> 0050 0200221e 1c002d02 2c002d01 0100221e  ..&quot;</span>...-.,.-...<span class="s2">&quot;.</span>
<span class="s2"> 0060 0c002d02 34002d01 0200221d 18002d02  ..-.4.-...&quot;</span>...-.
 0070 2c002d01 1e00221f 08002d02 01002009  ,.-...<span class="s2">&quot;...-... .</span>
<span class="s2"> 0080 34003d01 00303221 14003d02 30003d01  4.=..02!..=.0.=.</span>
<span class="s2"> 0090 00302221 04002d02 80002009 34003d01  .0&quot;</span>!..-... .4.<span class="o">=</span>.
 00a0 00302222 10002d02 34002d01 30003d01  .0<span class="s2">&quot;&quot;</span>..-.4.-.0.<span class="o">=</span>.
 00b0 00202320 00002d02 3800dd09 0000e03c  . <span class="c"># ..-.8......&lt;</span>
</pre></div>
</div>
<p>The first instruction is <strong>“addiu  $sp, -56”</strong> and its corresponding obj is
0x09ddffc8.
The opcode of addiu is 0x09, 8 bits; $sp register number is 13(0xd), 4bits; and
the immediate is 16 bits -56(=0xffc8), so it is correct.
The third instruction <strong>“st  $2, 52($fp)”</strong> and it&#8217;s corresponding obj
is 0x022b0034. The <strong>st</strong> opcode is <strong>0x02</strong>, $2 is 0x2, $fp is 0xb and
immediate is 52(0x0034).
Thanks to Cpu0 instruction format which opcode, register operand and
offset(imediate value) size are multiple of 4 bits.
Base on the 4 bits multiple, the obj format is easy to check by eyes.
The big endian (B0, B1, B2, B3) = (09, dd, ff, c8), objdump from B0 to B3 is
0x09ddffc8 and the little endian is (B3, B2, B1, B0) = (09, dd, ff, c8),
objdump from B0 to B3 is 0xc8ffdd09.</p>
</div>
<div class="section" id="elf-obj-related-code">
<h2><a class="toc-backref" href="#id4">ELF obj related code</a><a class="headerlink" href="#elf-obj-related-code" title="Permalink to this headline">¶</a></h2>
<p>To support elf obj generation, the following code changed and added to
Chapter5_1.</p>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Cpu0AsmBackend</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0MCCodeEmitter</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0ELFObjectWriter</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0TargetStreamer</span><span class="p">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0AsmBackend.h</p>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0FixupKinds.h&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0MCCodeEmitter.h</p>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0MCTargetDesc.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCCodeEmitter</span> <span class="o">*</span><span class="nf">createCpu0MCCodeEmitterEB</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MCII</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                         <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">);</span>
<span class="n">MCCodeEmitter</span> <span class="o">*</span><span class="nf">createCpu0MCCodeEmitterEL</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MCII</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                         <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">);</span>

<span class="n">MCAsmBackend</span> <span class="o">*</span><span class="nf">createCpu0AsmBackendEB32</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">Triple</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">);</span>
<span class="n">MCAsmBackend</span> <span class="o">*</span><span class="nf">createCpu0AsmBackendEL32</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">Triple</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">);</span>

<span class="n">MCObjectWriter</span> <span class="o">*</span><span class="nf">createCpu0ELFObjectWriter</span><span class="p">(</span><span class="n">raw_pwrite_stream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span>
                                          <span class="kt">uint8_t</span> <span class="n">OSABI</span><span class="p">,</span>
                                          <span class="kt">bool</span> <span class="n">IsLittleEndian</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter5_1/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">MCStreamer</span> <span class="o">*</span><span class="nf">createMCStreamer</span><span class="p">(</span><span class="k">const</span> <span class="n">Triple</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">,</span> 
                                    <span class="n">MCAsmBackend</span> <span class="o">&amp;</span><span class="n">MAB</span><span class="p">,</span> <span class="n">raw_pwrite_stream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span> 
                                    <span class="n">MCCodeEmitter</span> <span class="o">*</span><span class="n">Emitter</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">RelaxAll</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">createELFStreamer</span><span class="p">(</span><span class="n">Context</span><span class="p">,</span> <span class="n">MAB</span><span class="p">,</span> <span class="n">OS</span><span class="p">,</span> <span class="n">Emitter</span><span class="p">,</span> <span class="n">RelaxAll</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCTargetStreamer</span> <span class="o">*</span><span class="nf">createCpu0AsmTargetStreamer</span><span class="p">(</span><span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">S</span><span class="p">,</span>
                                                     <span class="n">formatted_raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span>
                                                     <span class="n">MCInstPrinter</span> <span class="o">*</span><span class="n">InstPrint</span><span class="p">,</span>
                                                     <span class="kt">bool</span> <span class="n">isVerboseAsm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0TargetAsmStreamer</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">OS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>     <span class="c1">// Register the elf streamer.</span>
    <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterELFStreamer</span><span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">,</span> <span class="n">createMCStreamer</span><span class="p">);</span>

    <span class="c1">// Register the asm target streamer.</span>
    <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterAsmTargetStreamer</span><span class="p">(</span><span class="o">*</span><span class="n">T</span><span class="p">,</span> <span class="n">createCpu0AsmTargetStreamer</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#if CH &gt;= CH5_1 </span><span class="c1">//3</span>
  <span class="c1">// Register the MC Code Emitter</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeEmitter</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeEmitterEB</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeEmitter</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeEmitterEL</span><span class="p">);</span>

  <span class="c1">// Register the asm backend.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCAsmBackend</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                       <span class="n">createCpu0AsmBackendEB32</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCAsmBackend</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                       <span class="n">createCpu0AsmBackendEL32</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The applyFixup() of Cpu0AsmBackend.cpp will fix up the <strong>jeq</strong>, <strong>jub</strong>, ...
instructions of &#8220;address control flow statements&#8221; or &#8220;function call statements&#8221;
used in later chapters.
The setting of true or false for each relocation record in
needsRelocateWithSymbol() of Cpu0ELFObjectWriter.cpp depends on whethor this
relocation record is needed to adjust address value during link or not.
If set true, then linker has chance to adjust this address value with correct
information. On the other hand, if set false, then linker has no correct
information to adjust this relocation record. About relocation record, it will
be introduced in later chapter ELF Support.</p>
<p>When emit elf obj format instruction, the EncodeInstruction() of
Cpu0MCCodeEmitter.cpp will be called since it override the same name of
function in parent class MCCodeEmitter.</p>
<p class="rubric">lbdex/chapters/Chapter2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Address operand</span>
<span class="n">def</span> <span class="n">mem</span> <span class="o">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">i32</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">PrintMethod</span> <span class="o">=</span> <span class="s">&quot;printMemOperand&quot;</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">MIOperandInfo</span> <span class="o">=</span> <span class="p">(</span><span class="n">ops</span> <span class="n">CPURegs</span><span class="p">,</span> <span class="n">simm16</span><span class="p">);</span>
  <span class="n">let</span> <span class="n">EncoderMethod</span> <span class="o">=</span> <span class="s">&quot;getMemEncoding&quot;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>multiclass LoadM32&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode,
                   bit Pseudo = 0&gt; {
  def #NAME# : LoadM&lt;op, instr_asm, OpNode, GPROut, mem, Pseudo&gt;;
}

// 32-bit store.
multiclass StoreM32&lt;bits&lt;8&gt; op, string instr_asm, PatFrag OpNode,
                    bit Pseudo = 0&gt; {
  def #NAME# : StoreM&lt;op, instr_asm, OpNode, CPURegs, mem, Pseudo&gt;;
}
</pre></div>
</div>
<p>The &#8220;let EncoderMethod = &#8220;getMemEncoding&#8221;;&#8221; in Cpu0InstrInfo.td as above will
making llvm call function getMemEncoding() when either <strong>ld</strong> or <strong>st</strong>
instruction is issued in elf obj since these two instructions use <strong>mem</strong>
Operand.</p>
<p>The other functions in Cpu0MCCodeEmitter.cpp are called by these two functions.</p>
</div>
<div class="section" id="backend-target-registration-structure">
<h2><a class="toc-backref" href="#id5">Backend Target Registration Structure</a><a class="headerlink" href="#backend-target-registration-structure" title="Permalink to this headline">¶</a></h2>
<p>Now, let&#8217;s examine Cpu0MCTargetDesc.cpp.
Cpu0MCTargetDesc.cpp do the target registration as mentioned in
&#8220;section Target Registration&#8221; <a class="footnote-reference" href="#id2" id="id1">[1]</a> of the last chapter.
Drawing the register functions and those classes it registered from
<a class="pageref" href="#genobj-f1">Figure  1</a> to <a class="pageref" href="#genobj-f9">Figure  9</a> for explanation.</p>
<div class="figure align-center" id="genobj-f1">
<a class="reference internal image-reference" href="_images/15.png"><img alt="_images/15.png" src="_images/15.png" style="width: 731.0px; height: 634.0px;" /></a>
<p class="caption">Figure 1: Register Cpu0MCAsmInfo</p>
</div>
<div class="figure align-center" id="genobj-f2">
<a class="reference internal image-reference" href="_images/22.png"><img alt="_images/22.png" src="_images/22.png" style="width: 685.0px; height: 450.0px;" /></a>
<p class="caption">Figure 2: Register MCCodeGenInfo</p>
</div>
<div class="figure align-center" id="genobj-f3">
<a class="reference internal image-reference" href="_images/31.png"><img alt="_images/31.png" src="_images/31.png" style="width: 606.0px; height: 313.0px;" /></a>
<p class="caption">Figure 3: Register MCInstrInfo</p>
</div>
<div class="figure align-center" id="genobj-f4">
<a class="reference internal image-reference" href="_images/42.png"><img alt="_images/42.png" src="_images/42.png" style="width: 615.0px; height: 678.0px;" /></a>
<p class="caption">Figure 4: Register MCRegisterInfo</p>
</div>
<div class="figure align-center" id="genobj-f5">
<a class="reference internal image-reference" href="_images/52.png"><img alt="_images/52.png" src="_images/52.png" style="width: 750.0px; height: 635.0px;" /></a>
<p class="caption">Figure 5: Register Cpu0MCCodeEmitter</p>
</div>
<div class="figure align-center" id="genobj-f6">
<a class="reference internal image-reference" href="_images/61.png"><img alt="_images/61.png" src="_images/61.png" style="width: 776.0px; height: 617.0px;" /></a>
<p class="caption">Figure 6: Register MCELFStreamer</p>
</div>
<div class="figure align-center" id="genobj-f7">
<a class="reference internal image-reference" href="_images/7.png"><img alt="_images/7.png" src="_images/7.png" style="width: 810.0px; height: 570.0px;" /></a>
<p class="caption">Figure 7: Register Cpu0AsmBackend</p>
</div>
<div class="figure align-center" id="genobj-f8">
<a class="reference internal image-reference" href="_images/8.png"><img alt="_images/8.png" src="_images/8.png" style="width: 621.0px; height: 483.0px;" /></a>
<p class="caption">Figure 8: Register Cpu0MCSubtargetInfo</p>
</div>
<div class="figure align-center" id="genobj-f9">
<a class="reference internal image-reference" href="_images/9.png"><img alt="_images/9.png" src="_images/9.png" style="width: 794.0px; height: 569.0px;" /></a>
<p class="caption">Figure 9: Register Cpu0InstPrinter</p>
</div>
<div class="figure align-center" id="genobj-f10">
<a class="reference internal image-reference" href="_images/101.png"><img alt="_images/101.png" src="_images/101.png" style="width: 783.0px; height: 596.0px;" /></a>
<p class="caption">Figure 10: MCELFStreamer inherit tree</p>
</div>
<p><a class="pageref" href="#genobj-f1">Figure  1</a> to <a class="pageref" href="#genobj-f4">Figure  4</a> had been defined
in Chapter4_2/ for assembly file generated support.</p>
<p>In <a class="pageref" href="#genobj-f1">Figure  1</a>, registering the object of class Cpu0MCAsmInfo for
target TheCpu0Target and TheCpu0elTarget.
TheCpu0Target is for big endian and TheCpu0elTarget is for little endian.
Cpu0MCAsmInfo is derived from MCAsmInfo which is an llvm built-in class.
Most code is implemented in it&#8217;s parent, back end reuses those code by inheritance.</p>
<p>In <a class="pageref" href="#genobj-f2">Figure  2</a>, instancing MCCodeGenInfo, and initialize it by
pass RM=Roloc::PIC when user compiling with position-independent code mode
through command <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=pic</span></tt> or <tt class="docutils literal"><span class="pre">llc</span></tt> (default relocation
mode is pic).
Recall there are two addressing mode in system program book, one is PIC
mode, the other is absolute addressing mode.
MC stands for Machine Code.</p>
<p>In <a class="pageref" href="#genobj-f3">Figure  3</a>, instancing MCInstrInfo object X, and initialize it
by InitCpu0MCInstrInfo(X).
Since InitCpu0MCInstrInfo(X) is defined in Cpu0GenInstrInfo.inc, this function
will add the information from Cpu0InstrInfo.td we specified.
<a class="pageref" href="#genobj-f4">Figure  4</a> is similar to <a class="pageref" href="#genobj-f3">Figure  3</a>, but it
initialize the register information specified in Cpu0RegisterInfo.td.
They share some values from instruction/register td description.
No need to specify them again in Initilize routine if they are consistant with
td description files.</p>
<p><a class="pageref" href="#genobj-f5">Figure  5</a>, instancing two objects Cpu0MCCodeEmitter, one is for
big endian and the other is for little endian.
They take care the obj format generated.
These funstions are not defined in Chapter4_2/ which support assembly code only.</p>
<p><a class="pageref" href="#genobj-f6">Figure  6</a>, MCELFStreamer takes care the obj format also.
<a class="pageref" href="#genobj-f5">Figure  5</a> Cpu0MCCodeEmitter takes care code emitter while
MCELFStreamer takes care the obj output streamer.
<a class="pageref" href="#genobj-f10">Figure  10</a> is MCELFStreamer inheritance tree.
You can find a lot of operations in that inheritance tree.</p>
<p>Reader maybe has the question: &#8220;What are the actual arguments in
createCpu0MCCodeEmitterEB(const MCInstrInfo &amp;MCII,  const MCSubtargetInfo &amp;STI,
MCContext &amp;Ctx)?&#8221; and &#8220;When they are assigned?&#8221;
Yes, we didn&#8217;t assign it at this point, we register the createXXX() function by
function pointer only (according C, TargetRegistry::RegisterXXX(TheCpu0Target,
createXXX()) where createXXX is function pointer).
LLVM keeps a function pointer to createXXX() when we call target registry, and
will call these createXXX() function back at proper time with arguments
assigned during the target registration process, RegisterXXX().</p>
<p><a class="pageref" href="#genobj-f7">Figure  7</a>, Cpu0AsmBackend class is the bridge for asm to obj.
Two objects take care big endian and little endian, respectively.
It derived from MCAsmBackend.
Most of code for object file generated is implemented by MCELFStreamer and it&#8217;s
parent, MCAsmBackend.</p>
<p><a class="pageref" href="#genobj-f8">Figure  8</a>, instancing MCSubtargetInfo object and initialize with
Cpu0.td information.
<a class="pageref" href="#genobj-f9">Figure  9</a>, instancing Cpu0InstPrinter to take care printing
function for instructions.
Like <a class="pageref" href="#genobj-f1">Figure  1</a> to <a class="pageref" href="#genobj-f4">Figure  4</a>, it has been defined
before in Chapter4_2/ code for assembly file generated support.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="otherinst.html">Arithmetic and logic instructions</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="globalvar.html">Global variables</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>