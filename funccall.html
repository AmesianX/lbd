<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Function call &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.7.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="ELF Support" href="elf.html" />
    <link rel="prev" title="Control flow statements" href="ctrlflow.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Function call</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statements</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="elf.html">ELF Support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="function-call">
<span id="sec-funccall"></span><h1>Function call<a class="headerlink" href="#function-call" title="Permalink to this headline">¶</a></h1>
<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#mips-stack-frame" id="id15">Mips stack frame</a></li>
<li><a class="reference internal" href="#load-incoming-arguments-from-stack-frame" id="id16">Load incoming arguments from stack frame</a></li>
<li><a class="reference internal" href="#store-outgoing-arguments-to-stack-frame" id="id17">Store outgoing arguments to stack frame</a><ul>
<li><a class="reference internal" href="#pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup" id="id18">Pseudo hook instruction ADJCALLSTACKDOWN and ADJCALLSTACKUP</a></li>
<li><a class="reference internal" href="#read-lowercall-with-graphivz-s-help" id="id19">Read Lowercall() with Graphivz&#8217;s help</a></li>
<li><a class="reference internal" href="#long-and-short-string-initialization" id="id20">Long and short string initialization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#structure-type-support" id="id21">Structure type support</a><ul>
<li><a class="reference internal" href="#ordinary-struct-type" id="id22">Ordinary struct type</a></li>
<li><a class="reference internal" href="#byval-struct-type" id="id23">byval struct type</a></li>
</ul>
</li>
<li><a class="reference internal" href="#function-call-optiomization" id="id24">Function call optiomization</a><ul>
<li><a class="reference internal" href="#tail-call-optimization" id="id25">Tail call optimization</a></li>
<li><a class="reference internal" href="#recursion-optimization" id="id26">Recursion optimization</a></li>
</ul>
</li>
<li><a class="reference internal" href="#other-features-supporting" id="id27">Other features supporting</a><ul>
<li><a class="reference internal" href="#the-gp-register-caller-saved-register-in-pic-addressing-mode" id="id28">The $gp register caller saved register in PIC addressing mode</a></li>
<li><a class="reference internal" href="#variable-number-of-arguments" id="id29">Variable number of arguments</a></li>
<li><a class="reference internal" href="#dynamic-stack-allocation-support" id="id30">Dynamic stack allocation support</a></li>
<li><a class="reference internal" href="#variable-sized-array-support" id="id31">Variable sized array support</a></li>
<li><a class="reference internal" href="#function-related-intrinsics-support" id="id32">Function related Intrinsics support</a><ul>
<li><a class="reference internal" href="#frameaddress-and-returnaddress-intrinsics" id="id33">frameaddress and returnaddress intrinsics</a></li>
<li><a class="reference internal" href="#eh-return-intrinsic" id="id34">eh.return intrinsic</a></li>
<li><a class="reference internal" href="#eh-dwarf-intrinsic" id="id35">eh.dwarf intrinsic</a></li>
<li><a class="reference internal" href="#bswap-intrinsic" id="id36">bswap intrinsic</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#summary" id="id37">Summary</a></li>
</ul>
</div>
<p>The subroutine/function call of backend translation is supported in this
chapter.
A lot of code needed to support function call. They are added according llvm
supplied interface for easy to explanation.
This chapter starts from introducing the Mips stack frame structure since we
borrow many part of ABI from it.
Although each CPU has it&#8217;s own ABI, most of ABI for RISC CPUs are similar.
In addition to support fixed number of arguments in function call, Cpu0
supports variable number of arguments either, since C/C++ support this feature.
The section “4.5 DAG Lowering” of tricore_llvm.pdf contains knowledge
about Lowering process. Section “4.5.1 Calling Conventions” of tricore_llvm.pdf
is the related materials you can reference furth.</p>
<p>If you have problem in reading the stack frame illustrated in the first three
sections of this chapter, you can read the appendix B of “Procedure Call
Convention” of book “Computer Organization and Design, 1st Edition”
<a class="footnote-reference" href="#computer-arch-interface" id="id1">[1]</a>,
“Run Time Memory” of compiler book, or “Function Call Sequence”  and
“Stack Frame” of Mips ABI <a class="footnote-reference" href="#abi" id="id2">[3]</a>.</p>
<div class="section" id="mips-stack-frame">
<h2><a class="toc-backref" href="#id15">Mips stack frame</a><a class="headerlink" href="#mips-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>The first thing for designing the Cpu0 function call is deciding how to pass
arguments in function call. There are two options.
The first is pass arguments all in stack.
Second is pass arguments in the registers which are reserved for function
arguments, and put the other arguments in stack if it over the number of
registers reserved for function call. For example, Mips pass the first 4
arguments in register $a0, $a1, $a2, $a3, and the other arguments in stack
if it over 4 arguments. <a class="pageref" href="#funccall-f1">Figure  1</a> is the Mips stack frame.</p>
<div class="figure align-center" id="funccall-f1">
<a class="reference internal image-reference" href="_images/14.png"><img alt="_images/14.png" src="_images/14.png" style="width: 344.0px; height: 265.5px;" /></a>
<p class="caption">Figure 1: Mips stack frame</p>
</div>
<p>Run <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-march=mips</span></tt> for ch9_1.bc, you will get the following result.
See comment <strong>&#8220;//&#8221;</strong>.</p>
<p class="rubric">lbdex/input/ch9_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">gI</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">gI</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>  
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_1.cpp -emit-llvm -o ch9_1.bc
118-165-78-230:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>mips -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o
ch9_1.mips.s
118-165-78-230:input Jonathan<span class="nv">$ </span>cat ch9_1.mips.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch9_1.bc&quot;</span>
  .text
  .globl  _Z5sum_iiiiiii
  .align  2
  .type _Z5sum_iiiiiii,@function
  .set  nomips16                <span class="c"># @_Z5sum_iiiiiii</span>
  .ent  _Z5sum_iiiiiii
_Z5sum_iiiiiii:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,32,<span class="nv">$ra</span>
  .mask   0x00000000,0
  .fmask  0x00000000,0
  .set  noreorder
  .set  nomacro
  .set  noat
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 32
  sw  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sw  <span class="nv">$5</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sw  <span class="nv">$t9</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sw  <span class="nv">$7</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$1</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // load argument 5
  sw  <span class="nv">$1</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$1</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // load argument 6
  sw  <span class="nv">$1</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$3</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  lw  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  lw  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  lw  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$1</span>
  sw  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jr  <span class="nv">$ra</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
  .set  at
  .set  macro
  .set  reorder
  .end  _Z5sum_iiiiiii
<span class="nv">$tmp2</span>:
  .size _Z5sum_iiiiiii, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-_Z5sum_iiiiiii
  .cfi_endproc

  .globl  main
  .align  2
  .type main,@function
  .set  nomips16                <span class="c"># @main</span>
  .ent  main
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,40,<span class="nv">$ra</span>
  .mask   0x80000000,-4
  .fmask  0x00000000,0
  .set  noreorder
  .set  nomacro
  .set  noat
<span class="c"># BB#0:</span>
  lui <span class="nv">$2</span>, %hi<span class="o">(</span>_gp_disp<span class="o">)</span>
  ori <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>_gp_disp<span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
<span class="nv">$tmp5</span>:
  .cfi_def_cfa_offset 40
  sw  <span class="nv">$ra</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp6</span>:
  .cfi_offset 31, -4
  addu  <span class="nv">$gp</span>, <span class="nv">$2</span>, <span class="nv">$25</span>
  sw  <span class="nv">$zero</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$1</span>, <span class="nv">$zero</span>, 6
  sw  <span class="nv">$1</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // Save argument 6 to 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$1</span>, <span class="nv">$zero</span>, 5
  sw  <span class="nv">$1</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // Save argument 5 to 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$25</span>, %call16<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 1    // Pass argument 1 to <span class="nv">$4</span> <span class="o">(=</span><span class="nv">$a0</span><span class="o">)</span>
  addiu <span class="nv">$5</span>, <span class="nv">$zero</span>, 2    // Pass argument 2 to <span class="nv">$5</span> <span class="o">(=</span><span class="nv">$a1</span><span class="o">)</span>
  addiu <span class="nv">$t9</span>, <span class="nv">$zero</span>, 3
  jalr  <span class="nv">$25</span>
  addiu <span class="nv">$7</span>, <span class="nv">$zero</span>, 4
  sw  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$ra</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  jr  <span class="nv">$ra</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 40
  .set  at
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp7</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>From the mips assembly code generated as above, we see it saves the first 4
arguments to $a0..$a3 and last 2 arguments to 16($sp) and 20($sp).
<a class="pageref" href="#funccall-f2">Figure  2</a> is the arguments location for example code
ch9_1.cpp.
It loads argument 5 from 48($sp) in sum_i() since the argument 5 is saved to
16($sp) in main().
The stack size of sum_i() is 32, so 16+32($sp) is the location of incoming
argument 5.</p>
<div class="figure align-center" id="funccall-f2">
<a class="reference internal image-reference" href="_images/21.png"><img alt="_images/21.png" src="_images/21.png" style="width: 370.0px; height: 288.5px;" /></a>
<p class="caption">Figure 2: Mips arguments location in stack frame</p>
</div>
<p>The 007-2418-003.pdf in here <a class="footnote-reference" href="#mipsasm" id="id3">[2]</a> is the Mips assembly language manual.
Here <a class="footnote-reference" href="#abi" id="id4">[3]</a> is Mips Application Binary Interface which include the
<a class="pageref" href="#funccall-f1">Figure  1</a>.</p>
</div>
<div class="section" id="load-incoming-arguments-from-stack-frame">
<h2><a class="toc-backref" href="#id16">Load incoming arguments from stack frame</a><a class="headerlink" href="#load-incoming-arguments-from-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>From last section, to support function call, we need implementing the arguments
pass mechanism with stack frame. Before do that, let&#8217;s run the old version of
code Chapter8_2/ with ch9_1.cpp and see what happens.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-31:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch9_1.bc -o ch9_1.cpu0.s
Assertion failed: <span class="o">(</span>InVals.size<span class="o">()</span> <span class="o">==</span> Ins.size<span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="s2">&quot;LowerFormalArguments didn&#39;t</span>
<span class="s2">emit the correct number of values!&quot;</span><span class="o">)</span>, <span class="k">function </span>LowerArguments, file /Users/
Jonathan/llvm/test/src/lib/CodeGen/SelectionDAG/
SelectionDAGBuilder.cpp, ...
...
0.  Program arguments: /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o
ch9_1.cpu0.s
1.  Running pass <span class="s1">&#39;Function Pass Manager&#39;</span> on module <span class="s1">&#39;ch9_1.bc&#39;</span>.
2.  Running pass <span class="s1">&#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39;</span> on <span class="k">function</span>
<span class="s1">&#39;@_Z5sum_iiiiiii&#39;</span>
Illegal instruction: 4
</pre></div>
</div>
<p>Since Chapter8_2/ define the LowerFormalArguments() with empty, we get the error
message as above.
Before define LowerFormalArguments(), we have to choose how to pass arguments
in function call.
For demonstration, Cpu0 passes first two arguments in registers as
default setting of <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></tt>.
When <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></tt>, Cpu0 pass all it&#8217;s arguments in stack.</p>
<p>Function LowerFormalArguments() is in charge of incoming arguments creation.
We define it as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">/// Cpu0CC - This class provides methods used to analyze formal and call</span>
    <span class="c1">/// arguments and inquire about calling convention information.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="kt">void</span> <span class="nf">analyzeFormalArguments</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                  <span class="kt">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span>
                                  <span class="n">Function</span><span class="o">::</span><span class="n">const_arg_iterator</span> <span class="n">FuncArg</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="c1">/// regSize - Size (in number of bits) of integer registers.</span>
      <span class="kt">unsigned</span> <span class="n">regSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">IsO32</span> <span class="o">?</span> <span class="mi">4</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span> <span class="p">}</span>
      <span class="c1">/// numIntArgRegs - Number of integer registers available for calls.</span>
      <span class="kt">unsigned</span> <span class="n">numIntArgRegs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="c1">/// Return pointer to array of integer argument registers.</span>
      <span class="k">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">intArgRegs</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="kt">void</span> <span class="nf">handleByValArg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ValNo</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">LocVT</span><span class="p">,</span>
                          <span class="n">CCValAssign</span><span class="o">::</span><span class="n">LocInfo</span> <span class="n">LocInfo</span><span class="p">,</span>
                          <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">ArgFlags</span><span class="p">);</span>

      <span class="c1">/// useRegsForByval - Returns true if the calling convention allows the</span>
      <span class="c1">/// use of registers to pass byval arguments.</span>
      <span class="kt">bool</span> <span class="n">useRegsForByval</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">CallConv</span> <span class="o">!=</span> <span class="n">CallingConv</span><span class="o">::</span><span class="n">Fast</span><span class="p">;</span> <span class="p">}</span>

      <span class="c1">/// Return the function that analyzes fixed argument list functions.</span>
      <span class="n">llvm</span><span class="o">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">fixedArgFn</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="kt">void</span> <span class="nf">allocateRegs</span><span class="p">(</span><span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ByValSize</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="n">Align</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">};</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">/// isEligibleForTailCallOptimization - Check whether the call is eligible</span>
    <span class="c1">/// for tail call optimization.</span>
    <span class="k">virtual</span> <span class="kt">bool</span>
    <span class="n">isEligibleForTailCallOptimization</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">Cpu0CCInfo</span><span class="p">,</span>
                                      <span class="kt">unsigned</span> <span class="n">NextStackOffset</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">Cpu0FunctionInfo</span><span class="o">&amp;</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">/// copyByValArg - Copy argument registers which were used to pass a byval</span>
    <span class="c1">/// argument to the stack. Create a stack frame object for the byval</span>
    <span class="c1">/// argument.</span>
    <span class="kt">void</span> <span class="n">copyByValRegs</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span>
                       <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span>
                       <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">Argument</span> <span class="o">*</span><span class="n">FuncArg</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="k">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">SDValue</span> <span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                      <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// addLiveIn - This helper function adds the specified physical register to the</span>
<span class="c1">// MachineFunction as a live in value.  It also creates a corresponding</span>
<span class="c1">// virtual register for it.</span>
<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">addLiveIn</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">PReg</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">VReg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">createVirtualRegister</span><span class="p">(</span><span class="n">RC</span><span class="p">);</span>
  <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">PReg</span><span class="p">,</span> <span class="n">VReg</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">VReg</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// TODO: Implement a generic logic using tblgen that can support this.</span>
<span class="c1">// Cpu0 32 ABI rules:</span>
<span class="c1">// ---</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">// Passed in stack only.</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">CC_Cpu0S32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ValNo</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">LocVT</span><span class="p">,</span>
                       <span class="n">CCValAssign</span><span class="o">::</span><span class="n">LocInfo</span> <span class="n">LocInfo</span><span class="p">,</span> <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">ArgFlags</span><span class="p">,</span>
                       <span class="n">CCState</span> <span class="o">&amp;</span><span class="n">State</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Do not process byval args here.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// Promote i8 and i16</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LocVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i8</span> <span class="o">||</span> <span class="n">LocVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i16</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LocVT</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">isSExt</span><span class="p">())</span>
      <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">SExt</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">isZExt</span><span class="p">())</span>
      <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">ZExt</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">AExt</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="n">OrigAlign</span> <span class="o">=</span> <span class="n">ArgFlags</span><span class="p">.</span><span class="n">getOrigAlign</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">AllocateStack</span><span class="p">(</span><span class="n">ValVT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span>
                                        <span class="n">OrigAlign</span><span class="p">);</span>
  <span class="n">State</span><span class="p">.</span><span class="n">addLoc</span><span class="p">(</span><span class="n">CCValAssign</span><span class="o">::</span><span class="n">getMem</span><span class="p">(</span><span class="n">ValNo</span><span class="p">,</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">LocInfo</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Passed first two i32 arguments in registers and others in stack.</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">CC_Cpu0O32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ValNo</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">LocVT</span><span class="p">,</span>
                       <span class="n">CCValAssign</span><span class="o">::</span><span class="n">LocInfo</span> <span class="n">LocInfo</span><span class="p">,</span> <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">ArgFlags</span><span class="p">,</span>
                       <span class="n">CCState</span> <span class="o">&amp;</span><span class="n">State</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">MCPhysReg</span> <span class="n">IntRegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">A0</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">A1</span> <span class="p">};</span>

  <span class="c1">// Do not process byval args here.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="c1">// Promote i8 and i16</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LocVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i8</span> <span class="o">||</span> <span class="n">LocVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i16</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">LocVT</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">isSExt</span><span class="p">())</span>
      <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">SExt</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">isZExt</span><span class="p">())</span>
      <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">ZExt</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="n">LocInfo</span> <span class="o">=</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">AExt</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="n">Reg</span><span class="p">;</span>

  <span class="c1">// f32 and f64 are allocated in A0, A1 when either of the following</span>
  <span class="c1">// is true: function is vararg, argument is 3rd or higher, there is previous</span>
  <span class="c1">// argument which is not f32 or f64.</span>
  <span class="kt">bool</span> <span class="n">AllocateFloatsInIntReg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">OrigAlign</span> <span class="o">=</span> <span class="n">ArgFlags</span><span class="p">.</span><span class="n">getOrigAlign</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">isI64</span> <span class="o">=</span> <span class="p">(</span><span class="n">ValVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span> <span class="o">&amp;&amp;</span> <span class="n">OrigAlign</span> <span class="o">==</span> <span class="mi">8</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ValVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span> <span class="o">||</span> <span class="p">(</span><span class="n">ValVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f32</span> <span class="o">&amp;&amp;</span> <span class="n">AllocateFloatsInIntReg</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Reg</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">AllocateReg</span><span class="p">(</span><span class="n">IntRegs</span><span class="p">);</span>
    <span class="c1">// If this is the first part of an i64 arg,</span>
    <span class="c1">// the allocated register must be A0.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isI64</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Reg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">A1</span><span class="p">))</span>
      <span class="n">Reg</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">AllocateReg</span><span class="p">(</span><span class="n">IntRegs</span><span class="p">);</span>
    <span class="n">LocVT</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ValVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f64</span> <span class="o">&amp;&amp;</span> <span class="n">AllocateFloatsInIntReg</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Allocate int register. If first</span>
    <span class="c1">// available register is Cpu0::A1, shadow it too.</span>
    <span class="n">Reg</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">AllocateReg</span><span class="p">(</span><span class="n">IntRegs</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Reg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">A1</span><span class="p">)</span>
      <span class="n">Reg</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">AllocateReg</span><span class="p">(</span><span class="n">IntRegs</span><span class="p">);</span>
    <span class="n">State</span><span class="p">.</span><span class="n">AllocateReg</span><span class="p">(</span><span class="n">IntRegs</span><span class="p">);</span>
    <span class="n">LocVT</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Cannot handle this ValVT.&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">State</span><span class="p">.</span><span class="n">AllocateStack</span><span class="p">(</span><span class="n">ValVT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span> <span class="o">&gt;&gt;</span> <span class="mi">3</span><span class="p">,</span>
                                          <span class="n">OrigAlign</span><span class="p">);</span>
    <span class="n">State</span><span class="p">.</span><span class="n">addLoc</span><span class="p">(</span><span class="n">CCValAssign</span><span class="o">::</span><span class="n">getMem</span><span class="p">(</span><span class="n">ValNo</span><span class="p">,</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">LocInfo</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="n">State</span><span class="p">.</span><span class="n">addLoc</span><span class="p">(</span><span class="n">CCValAssign</span><span class="o">::</span><span class="n">getReg</span><span class="p">(</span><span class="n">ValNo</span><span class="p">,</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">LocInfo</span><span class="p">));</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//                  Call Calling Convention Implementation</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">MCPhysReg</span> <span class="n">O32IntRegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">Cpu0</span><span class="o">::</span><span class="n">A0</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">A1</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//@LowerCall {</span>
<span class="c1">/// LowerCall - functions arguments are copied from virtual regs to</span>
<span class="c1">/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//@LowerCall {</span>
<span class="c1">/// LowerCall - functions arguments are copied from virtual regs to</span>
<span class="c1">/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">return</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Chain</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//@LowerFormalArguments {</span>
<span class="c1">/// LowerFormalArguments - transform physical registers into virtual registers</span>
<span class="c1">/// and generate load operations for arguments places on the stack.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setVarArgsFrameIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Assign locations to all of the incoming arguments.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">ArgLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="nf">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
                 <span class="n">ArgLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>
  <span class="n">Cpu0CC</span> <span class="nf">Cpu0CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">ABI</span><span class="p">.</span><span class="n">IsO32</span><span class="p">(),</span> 
                    <span class="n">CCInfo</span><span class="p">);</span>
  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setFormalArgInfo</span><span class="p">(</span><span class="n">CCInfo</span><span class="p">.</span><span class="n">getNextStackOffset</span><span class="p">(),</span>
                           <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">hasByValArg</span><span class="p">());</span>

  <span class="n">Function</span><span class="o">::</span><span class="n">const_arg_iterator</span> <span class="n">FuncArg</span> <span class="o">=</span>
    <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">arg_begin</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">UseSoftFloat</span> <span class="o">=</span> <span class="n">Subtarget</span><span class="p">.</span><span class="n">abiUsesSoftFloat</span><span class="p">();</span>

  <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">analyzeFormalArguments</span><span class="p">(</span><span class="n">Ins</span><span class="p">,</span> <span class="n">UseSoftFloat</span><span class="p">,</span> <span class="n">FuncArg</span><span class="p">);</span>

  <span class="c1">// Used with vargs to acumulate store chains.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="n">OutChains</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="n">CurArgIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">Cpu0CC</span><span class="o">::</span><span class="n">byval_iterator</span> <span class="n">ByValArg</span> <span class="o">=</span> <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">byval_begin</span><span class="p">();</span>

  <span class="c1">//@2 {</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//@2 }</span>
    <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">FuncArg</span><span class="p">,</span> <span class="n">Ins</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OrigArgIndex</span> <span class="o">-</span> <span class="n">CurArgIdx</span><span class="p">);</span>
    <span class="n">CurArgIdx</span> <span class="o">=</span> <span class="n">Ins</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">OrigArgIndex</span><span class="p">;</span>
    <span class="n">EVT</span> <span class="n">ValVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getValVT</span><span class="p">();</span>
    <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">Flags</span> <span class="o">=</span> <span class="n">Ins</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">IsRegLoc</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">isRegLoc</span><span class="p">();</span>

    <span class="c1">//@byval pass {</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">ByValArg</span> <span class="o">!=</span> <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">byval_end</span><span class="p">());</span>
      <span class="n">copyByValRegs</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">OutChains</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Flags</span><span class="p">,</span> <span class="n">InVals</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">FuncArg</span><span class="p">,</span>
                    <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">ByValArg</span><span class="p">);</span>
      <span class="o">++</span><span class="n">ByValArg</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//@byval pass }</span>
    <span class="c1">// Arguments stored on registers</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ABI</span><span class="p">.</span><span class="n">IsO32</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">IsRegLoc</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">MVT</span> <span class="n">RegVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocVT</span><span class="p">();</span>
      <span class="kt">unsigned</span> <span class="n">ArgReg</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocReg</span><span class="p">();</span>
      <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">RegVT</span><span class="p">);</span>

      <span class="c1">// Transform the arguments stored on</span>
      <span class="c1">// physical registers into virtual ones</span>
      <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">addLiveIn</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span> <span class="n">ArgReg</span><span class="p">,</span> <span class="n">RC</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">ArgValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">RegVT</span><span class="p">);</span>

      <span class="c1">// If this is an 8 or 16-bit value, it has been passed promoted</span>
      <span class="c1">// to 32 bits.  Insert an assert[sz]ext to capture this, then</span>
      <span class="c1">// truncate to the right size.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">getLocInfo</span><span class="p">()</span> <span class="o">!=</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">Full</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">getLocInfo</span><span class="p">()</span> <span class="o">==</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">SExt</span><span class="p">)</span>
          <span class="n">Opcode</span> <span class="o">=</span> <span class="n">ISD</span><span class="o">::</span><span class="n">AssertSext</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">getLocInfo</span><span class="p">()</span> <span class="o">==</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">ZExt</span><span class="p">)</span>
          <span class="n">Opcode</span> <span class="o">=</span> <span class="n">ISD</span><span class="o">::</span><span class="n">AssertZext</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span><span class="p">)</span>
          <span class="n">ArgValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Opcode</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegVT</span><span class="p">,</span> <span class="n">ArgValue</span><span class="p">,</span>
                                 <span class="n">DAG</span><span class="p">.</span><span class="n">getValueType</span><span class="p">(</span><span class="n">ValVT</span><span class="p">));</span>
        <span class="n">ArgValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TRUNCATE</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">ArgValue</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="c1">// Handle floating point arguments passed in integer registers.</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">RegVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span> <span class="o">&amp;&amp;</span> <span class="n">ValVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f32</span><span class="p">)</span> <span class="o">||</span>
          <span class="p">(</span><span class="n">RegVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i64</span> <span class="o">&amp;&amp;</span> <span class="n">ValVT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f64</span><span class="p">))</span>
        <span class="n">ArgValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">BITCAST</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">ArgValue</span><span class="p">);</span>
      <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ArgValue</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// VA.isRegLoc()</span>

      <span class="c1">// sanity check</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isMemLoc</span><span class="p">());</span>

      <span class="c1">// The stack pointer offset is relative to the caller stack frame.</span>
      <span class="kt">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">ValVT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span>
                                      <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>

      <span class="c1">// Create load nodes to retrieve arguments from the stack</span>
      <span class="n">SDValue</span> <span class="n">FIN</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()));</span>
      <span class="n">SDValue</span> <span class="n">Load</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">ValVT</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">FIN</span><span class="p">,</span>
                                 <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getFixedStack</span><span class="p">(</span><span class="n">FI</span><span class="p">),</span>
                                 <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
      <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Load</span><span class="p">);</span>
      <span class="n">OutChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Load</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span>

<span class="c1">//@Ordinary struct type: 1 {</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The cpu0 ABIs for returning structs by value requires that we copy</span>
    <span class="c1">// the sret argument into $v0 for the return. Save the argument into</span>
    <span class="c1">// a virtual register so that we can access it from the return points.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Ins</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">.</span><span class="n">isSRet</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getSRetReturnReg</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Reg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">createVirtualRegister</span><span class="p">(</span>
            <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>
        <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setSRetReturnReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">SDValue</span> <span class="n">Copy</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">InVals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Copy</span><span class="p">,</span> <span class="n">Chain</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="c1">//@Ordinary struct type: 1 }</span>

  <span class="c1">// All stores are grouped in one node to allow the matching between</span>
  <span class="c1">// the size of Ins and InVals. This only happens when on varg functions</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OutChains</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">OutChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">);</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">OutChains</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// @LowerFormalArguments }</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span>
<span class="n">analyzeFormalArguments</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Args</span><span class="p">,</span>
                       <span class="kt">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span> <span class="n">Function</span><span class="o">::</span><span class="n">const_arg_iterator</span> <span class="n">FuncArg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">NumArgs</span> <span class="o">=</span> <span class="n">Args</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">FixedFn</span> <span class="o">=</span> <span class="n">fixedArgFn</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">CurArgIdx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">NumArgs</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MVT</span> <span class="n">ArgVT</span> <span class="o">=</span> <span class="n">Args</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">VT</span><span class="p">;</span>
    <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">ArgFlags</span> <span class="o">=</span> <span class="n">Args</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">Flags</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">FuncArg</span><span class="p">,</span> <span class="n">Args</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">OrigArgIndex</span> <span class="o">-</span> <span class="n">CurArgIdx</span><span class="p">);</span>
    <span class="n">CurArgIdx</span> <span class="o">=</span> <span class="n">Args</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">OrigArgIndex</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">handleByValArg</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">ArgVT</span><span class="p">,</span> <span class="n">ArgVT</span><span class="p">,</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">Full</span><span class="p">,</span> <span class="n">ArgFlags</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">MVT</span> <span class="n">RegVT</span> <span class="o">=</span> <span class="n">getRegVT</span><span class="p">(</span><span class="n">ArgVT</span><span class="p">,</span> <span class="n">FuncArg</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(),</span> <span class="n">nullptr</span><span class="p">,</span> <span class="n">IsSoftFloat</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FixedFn</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">ArgVT</span><span class="p">,</span> <span class="n">RegVT</span><span class="p">,</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">Full</span><span class="p">,</span> <span class="n">ArgFlags</span><span class="p">,</span> <span class="n">CCInfo</span><span class="p">))</span>
      <span class="k">continue</span><span class="p">;</span>

<span class="cp">#ifndef NDEBUG</span>
    <span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Formal Arg #&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">I</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; has unhandled type &quot;</span>
           <span class="o">&lt;&lt;</span> <span class="n">EVT</span><span class="p">(</span><span class="n">ArgVT</span><span class="p">).</span><span class="n">getEVTString</span><span class="p">();</span>
<span class="cp">#endif</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span><span class="n">handleByValArg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">ValNo</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">ValVT</span><span class="p">,</span>
                                                <span class="n">MVT</span> <span class="n">LocVT</span><span class="p">,</span>
                                                <span class="n">CCValAssign</span><span class="o">::</span><span class="n">LocInfo</span> <span class="n">LocInfo</span><span class="p">,</span>
                                                <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">ArgFlags</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Byval argument&#39;s size shouldn&#39;t be 0.&quot;</span><span class="p">);</span>

  <span class="k">struct</span> <span class="n">ByValArgInfo</span> <span class="n">ByVal</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">RegSize</span> <span class="o">=</span> <span class="n">regSize</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">ByValSize</span> <span class="o">=</span> <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">(),</span> <span class="n">RegSize</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">Align</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">getByValAlign</span><span class="p">(),</span> <span class="n">RegSize</span><span class="p">),</span>
                            <span class="n">RegSize</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">useRegsForByval</span><span class="p">())</span>
    <span class="n">allocateRegs</span><span class="p">(</span><span class="n">ByVal</span><span class="p">,</span> <span class="n">ByValSize</span><span class="p">,</span> <span class="n">Align</span><span class="p">);</span>

  <span class="c1">// Allocate space on caller&#39;s stack.</span>
  <span class="n">ByVal</span><span class="p">.</span><span class="n">Address</span> <span class="o">=</span> <span class="n">CCInfo</span><span class="p">.</span><span class="n">AllocateStack</span><span class="p">(</span><span class="n">ByValSize</span> <span class="o">-</span> <span class="n">RegSize</span> <span class="o">*</span> <span class="n">ByVal</span><span class="p">.</span><span class="n">NumRegs</span><span class="p">,</span>
                                       <span class="n">Align</span><span class="p">);</span>
  <span class="n">CCInfo</span><span class="p">.</span><span class="n">addLoc</span><span class="p">(</span><span class="n">CCValAssign</span><span class="o">::</span><span class="n">getMem</span><span class="p">(</span><span class="n">ValNo</span><span class="p">,</span> <span class="n">ValVT</span><span class="p">,</span> <span class="n">ByVal</span><span class="p">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span>
                                    <span class="n">LocInfo</span><span class="p">));</span>
  <span class="n">ByValArgs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">ByVal</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span><span class="n">numIntArgRegs</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">IsO32</span> <span class="o">?</span> <span class="n">array_lengthof</span><span class="p">(</span><span class="n">O32IntRegs</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span><span class="n">intArgRegs</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">makeArrayRef</span><span class="p">(</span><span class="n">O32IntRegs</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">llvm</span><span class="o">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span><span class="n">fixedArgFn</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsO32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CC_Cpu0O32</span><span class="p">;</span>
  <span class="k">else</span> <span class="c1">// IsS32</span>
    <span class="k">return</span> <span class="n">CC_Cpu0S32</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span><span class="n">allocateRegs</span><span class="p">(</span><span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">ByValSize</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">Align</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">RegSize</span> <span class="o">=</span> <span class="n">regSize</span><span class="p">(),</span> <span class="n">NumIntArgRegs</span> <span class="o">=</span> <span class="n">numIntArgRegs</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">IntArgRegs</span> <span class="o">=</span> <span class="n">intArgRegs</span><span class="p">();</span>
  <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ByValSize</span> <span class="o">%</span> <span class="n">RegSize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">Align</span> <span class="o">%</span> <span class="n">RegSize</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Byval argument&#39;s size and alignment should be a multiple of&quot;</span>
         <span class="s">&quot;RegSize.&quot;</span><span class="p">);</span>

  <span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span> <span class="o">=</span> <span class="n">CCInfo</span><span class="p">.</span><span class="n">getFirstUnallocated</span><span class="p">(</span><span class="n">IntArgRegs</span><span class="p">);</span>

  <span class="c1">// If Align &gt; RegSize, the first arg register must be even.</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">Align</span> <span class="o">&gt;</span> <span class="n">RegSize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span> <span class="o">%</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">CCInfo</span><span class="p">.</span><span class="n">AllocateReg</span><span class="p">(</span><span class="n">IntArgRegs</span><span class="p">[</span><span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span><span class="p">]);</span>
    <span class="o">++</span><span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Mark the registers allocated.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span><span class="p">;</span> <span class="n">ByValSize</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">I</span> <span class="o">&lt;</span> <span class="n">NumIntArgRegs</span><span class="p">);</span>
       <span class="n">ByValSize</span> <span class="o">-=</span> <span class="n">RegSize</span><span class="p">,</span> <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="o">++</span><span class="n">ByVal</span><span class="p">.</span><span class="n">NumRegs</span><span class="p">)</span>
    <span class="n">CCInfo</span><span class="p">.</span><span class="n">AllocateReg</span><span class="p">(</span><span class="n">IntArgRegs</span><span class="p">[</span><span class="n">I</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Refresh &#8220;section Global variable&#8221; <a class="footnote-reference" href="#secglobal" id="id5">[4]</a>, we handled global
variable translation by creating the IR DAG in LowerGlobalAddress() first, and
then finish the Instruction Selection according their corresponding machine
instruction DAGs in Cpu0InstrInfo.td.
LowerGlobalAddress() is called when <tt class="docutils literal"><span class="pre">llc</span></tt> meets the global variable access.
LowerFormalArguments() work in the same way.
It is called when function is entered.
It get incoming arguments information by CCInfo(CallConv,..., ArgLocs, ...)
before enter <strong>“for loop”</strong>. In ch9_1.cpp, there are 6 arguments in sum_i(...)
function call.
So ArgLocs.size() is 6, each argument information is in ArgLocs[i].
When VA.isRegLoc() is true, meaning the arguement pass in register. On the
contrary, when VA.isMemLoc() is true, meaning the arguement pass in memory
stack.
When passing in registers, it marks the registers &#8220;live in&#8221; and copy directly
from the registers.
When passing in memory stack, it creates stack offset for this frame index
object and load node with the created stack offset, and then puts the load node
into vector InVals.</p>
<p>When <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></tt> it passes first two arguments registers
and the other arguments in stack frame. When <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></tt> it
passes all arguments in stack frame.</p>
<p>Before taking care the arguemnts as above, it calls analyzeFormalArguments().
In analyzeFormalArguments() it calls fixedArgFn() which return the function
pointer of CC_Cpu0O32() or CC_Cpu0S32().
ArgFlags.isByVal() will be true if it meets &#8220;struct pointer byval&#8221; keyword,
such as &#8220;%struct.S* byval&#8221; in tailcall.ll.
When <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></tt> the stack offset begin from 8 (in case the
arguement registers need spill out) while <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></tt> stack
offset begin from 0.</p>
<p>For instance of example code ch9_1.cpp with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></tt> (use
memory stack only to pass arguments), LowerFormalArguments()
will be called twice. First time is for sum_i() which will create 6 &#8220;load DAGs&#8221;
for 6 incoming arguments passing into this function.
Second time is for main() which won&#8217;t create any &#8220;load DAG&#8221; for no incoming
argument passing into main().
In addition to LowerFormalArguments() which creates the &#8220;load DAG&#8221;, we need
loadRegFromStackSlot() (defined in the early chapter) to issue the machine
instruction
<strong>“ld $r, offset($sp)”</strong> to load incoming arguments from stack frame offset.
GetMemOperand(..., FI, ...) return the Memory location of the frame index
variable, which is the offset.</p>
<p>For input ch9_incoming.cpp as below, LowerFormalArguments() will generate the
red circled parts of DAG nodes as <a class="pageref" href="#funccall-f-incoming-arg1">Figure  3</a> and
<a class="pageref" href="#funccall-f-incoming-arg2">Figure  4</a> for <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></tt> and
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></tt>, respectively.
The root node at bottom is created by</p>
<p class="rubric">lbdex/input/ch9_incoming.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>clang -O3 -target mips-unknown-linux-gnu -c
ch9_incoming.cpp -emit-llvm -o ch9_incoming.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llvm-dis ch9_incoming.bc -o -
...
define i32 @_Z5sum_iiii<span class="o">(</span>i32 %x1, i32 %x2, i32 %x3<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> add nsw i32 %x2, %x1
  %2 <span class="o">=</span> add nsw i32 %1, %x3
  ret i32 %2
<span class="o">}</span>
</pre></div>
</div>
<div class="figure align-center" id="funccall-f-incoming-arg1">
<a class="reference internal image-reference" href="_images/incoming-arg-S32.png"><img alt="_images/incoming-arg-S32.png" src="_images/incoming-arg-S32.png" style="width: 699.3px; height: 803.6px;" /></a>
<p class="caption">Figure 3: Incoming arguments DAG created for ch9_incoming.cpp with -cpu0-s32-calls=true</p>
</div>
<div class="figure align-center" id="funccall-f-incoming-arg2">
<a class="reference internal image-reference" href="_images/incoming-arg-O32.png"><img alt="_images/incoming-arg-O32.png" src="_images/incoming-arg-O32.png" style="width: 609.7px; height: 803.6px;" /></a>
<p class="caption">Figure 4: Incoming arguments DAG created for ch9_incoming.cpp with -cpu0-s32-calls=false</p>
</div>
<p>In addition to Calling Convention and LowerFormalArguments(), Chapter9_1/ adds
the following code for the instruction selection and printing of Cpu0
instructions <strong>swi</strong> (Software Interrupt), <strong>jsub</strong> and <strong>jalr</strong> (function call).</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">SDT_Cpu0JmpLink</span>      <span class="o">:</span> <span class="n">SDTypeProfile</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">iPTR</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Call</span>
<span class="n">def</span> <span class="n">Cpu0JmpLink</span> <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;Cpu0ISD::JmpLink&quot;</span><span class="p">,</span><span class="n">SDT_Cpu0JmpLink</span><span class="p">,</span>
                         <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span>
                          <span class="n">SDNPVariadic</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">IsTailCall</span> <span class="p">{</span>
  <span class="n">bit</span> <span class="n">isCall</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isTerminator</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isReturn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isBarrier</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">hasExtraSrcRegAllocReq</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isCodeGenOnly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">calltarget</span>  <span class="o">:</span> <span class="n">Operand</span><span class="o">&lt;</span><span class="n">iPTR</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">EncoderMethod</span> <span class="o">=</span> <span class="s">&quot;getJumpTargetOpValue&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><pre>let Predicates = [Ch9_1] in {
// Jump and Link (Call)
let isCall=1, hasDelaySlot=1 in {
  //@JumpLink {
  class JumpLink&lt;bits&lt;8&gt; op, string instr_asm&gt;:
    FJ&lt;op, (outs), (ins calltarget:$target, variable_ops),
       !strconcat(instr_asm, "\t$target"), [(Cpu0JmpLink imm:$target)],
       IIBranch&gt; {
//#if CH &gt;= CH10_1 2
       let DecoderMethod = "DecodeJumpTarget";
//#endif
       }
  //@JumpLink }

  class JumpLinkReg&lt;bits&lt;8&gt; op, string instr_asm,
                    RegisterClass RC&gt;:
    FA&lt;op, (outs), (ins RC:$rb, variable_ops),
       !strconcat(instr_asm, "\t$rb"), [(Cpu0JmpLink RC:$rb)], IIBranch&gt; {
    let rc = 0;
    let ra = 14;
    let shamt = 0;
  }
}

</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Jump &amp; link and Return Instructions</span>
<span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">JSUB</span>    <span class="o">:</span> <span class="n">JumpLink</span><span class="o">&lt;</span><span class="mh">0x3b</span><span class="p">,</span> <span class="s">&quot;jsub&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">JALR</span>    <span class="o">:</span> <span class="n">JumpLinkReg</span><span class="o">&lt;</span><span class="mh">0x39</span><span class="p">,</span> <span class="s">&quot;jalr&quot;</span><span class="p">,</span> <span class="n">GPROut</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><pre>let Predicates = [Ch9_1] in {
def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0JmpLink (i32 texternalsym:$dst)),
          (JSUB texternalsym:$dst)&gt;;

</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">Kind</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT_CALL</span><span class="o">:</span>  <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
<span class="p">.</span> <span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_ExternalSymbol</span><span class="o">:</span>
    <span class="n">Symbol</span> <span class="o">=</span> <span class="n">AsmPrinter</span><span class="p">.</span><span class="n">GetExternalSymbolSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getSymbolName</span><span class="p">());</span>
    <span class="n">Offset</span> <span class="o">+=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getOffset</span><span class="p">();</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineOperandType</span> <span class="n">MOTy</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//@2</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_ExternalSymbol</span><span class="o">:</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="k">return</span> <span class="nf">LowerSymbolOperand</span><span class="p">(</span><span class="n">MO</span><span class="p">,</span> <span class="n">MOTy</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">printExpr</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">MAI</span><span class="p">,</span>
                      <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">.</span> <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span>:<span class="o">:</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="o">:</span>  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%call16(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Prepare value for the target space for it</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">adjustFixupValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">Value</span><span class="p">,</span>
                                 <span class="n">MCContext</span> <span class="o">*</span><span class="n">Ctx</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>

  <span class="kt">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">Fixup</span><span class="p">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="c1">// Add/subtract and shift</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">fixup_Cpu0_CALL16</span><span class="o">:</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="o">::</span><span class="n">GetRelocType</span><span class="p">(</span><span class="k">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="kt">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// determine the type of the relocation</span>
  <span class="kt">unsigned</span> <span class="n">Type</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_NONE</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">Fixup</span><span class="p">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">fixup_Cpu0_CALL16</span><span class="o">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_CALL16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// resulting in - R_CPU0_CALL16.</span>
    <span class="n">fixup_Cpu0_CALL16</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="p">...</span>
<span class="p">.</span> <span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getJumpTargetOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JMP</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">BAL</span><span class="p">)</span>
<span class="cp">#elif CH &gt;= CH8_2 </span><span class="c1">//1</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JMP</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">BAL</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">Fixups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MCFixup</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span>
                                     <span class="n">MCFixupKind</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">fixup_Cpu0_PC24</span><span class="p">)));</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getExprOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="k">switch</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="k">case</span> <span class="n">MCSymbolRefExpr</span>:<span class="o">:</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="o">:</span>
      <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Cpu0FunctionInfo - This class is derived from MachineFunction private</span>
<span class="c1">/// Cpu0 target-specific information for each MachineFunction.</span>
<span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">MF</span><span class="p">(</span><span class="n">MF</span><span class="p">),</span> 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">InArgFIRange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="n">OutArgFIRange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">GPFI</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DynAllocFI</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">bool</span> <span class="n">isInArgFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FI</span> <span class="o">&lt;=</span> <span class="n">InArgFIRange</span><span class="p">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span> <span class="o">&gt;=</span> <span class="n">InArgFIRange</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setLastInArgFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="p">{</span> <span class="n">InArgFIRange</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isOutArgFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FI</span> <span class="o">&lt;=</span> <span class="n">OutArgFIRange</span><span class="p">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span> <span class="o">&gt;=</span> <span class="n">OutArgFIRange</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">int</span> <span class="n">getGPFI</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GPFI</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setGPFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="p">{</span> <span class="n">GPFI</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isGPFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GPFI</span> <span class="o">&amp;&amp;</span> <span class="n">GPFI</span> <span class="o">==</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">bool</span> <span class="n">isDynAllocFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">DynAllocFI</span> <span class="o">&amp;&amp;</span> <span class="n">DynAllocFI</span> <span class="o">==</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Range of frame object indices.</span>
  <span class="c1">// InArgFIRange: Range of indices of all frame objects created during call to</span>
  <span class="c1">//               LowerFormalArguments.</span>
  <span class="c1">// OutArgFIRange: Range of indices of all frame objects created during call to</span>
  <span class="c1">//                LowerCall except for the frame object for restoring $gp.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">InArgFIRange</span><span class="p">,</span> <span class="n">OutArgFIRange</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">mutable</span> <span class="kt">int</span> <span class="n">DynAllocFI</span><span class="p">;</span> <span class="c1">// Frame index of dynamically allocated stack area.</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEFrameLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">bool</span> <span class="n">spillCalleeSavedRegisters</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span>
<span class="n">spillCalleeSavedRegisters</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                          <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineBasicBlock</span> <span class="o">*</span><span class="n">EntryBlock</span> <span class="o">=</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span> <span class="o">=</span> <span class="o">*</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getSubtarget</span><span class="p">().</span><span class="n">getInstrInfo</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Add the callee-saved register as live-in. Do not add if the register is</span>
    <span class="c1">// LR and return address is taken, because it has already been added in</span>
    <span class="c1">// method Cpu0TargetLowering::LowerRETURNADDR.</span>
    <span class="c1">// It&#39;s killed at the spill, unless the register is LR and return address</span>
    <span class="c1">// is taken.</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getReg</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">IsRAAndRetAddrIsTaken</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isReturnAddressTaken</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsRAAndRetAddrIsTaken</span><span class="p">)</span>
      <span class="n">EntryBlock</span><span class="o">-&gt;</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>

    <span class="c1">// Insert the spill to the stack frame.</span>
    <span class="kt">bool</span> <span class="n">IsKill</span> <span class="o">=</span> <span class="o">!</span><span class="n">IsRAAndRetAddrIsTaken</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="n">TRI</span><span class="o">-&gt;</span><span class="n">getMinimalPhysRegClass</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="n">TII</span><span class="p">.</span><span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="o">*</span><span class="n">EntryBlock</span><span class="p">,</span> <span class="n">MI</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">IsKill</span><span class="p">,</span>
                            <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">(),</span> <span class="n">RC</span><span class="p">,</span> <span class="n">TRI</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">void</span> <span class="nf">storeRegToStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                           <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span><span class="p">,</span>
                           <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isKill</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">storeRegToStack</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="n">isKill</span><span class="p">,</span> <span class="n">FrameIndex</span><span class="p">,</span> <span class="n">RC</span><span class="p">,</span> <span class="n">TRI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                            <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span><span class="p">,</span>
                            <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span> <span class="p">{</span>
    <span class="n">loadRegFromStack</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">DestReg</span><span class="p">,</span> <span class="n">FrameIndex</span><span class="p">,</span> <span class="n">RC</span><span class="p">,</span> <span class="n">TRI</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">storeRegToStack</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                               <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                               <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isKill</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                               <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">loadRegFromStack</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                                <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">MachineMemOperand</span> <span class="o">*</span><span class="n">GetMemOperand</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                                   <span class="kt">unsigned</span> <span class="n">Flag</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MachineMemOperand</span> <span class="o">*</span><span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">GetMemOperand</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                                                <span class="kt">unsigned</span> <span class="n">Flag</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="o">*</span><span class="n">MBB</span><span class="p">.</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span> <span class="o">=</span> <span class="o">*</span><span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">Align</span> <span class="o">=</span> <span class="n">MFI</span><span class="p">.</span><span class="n">getObjectAlignment</span><span class="p">(</span><span class="n">FI</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MF</span><span class="p">.</span><span class="n">getMachineMemOperand</span><span class="p">(</span><span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getFixedStack</span><span class="p">(</span><span class="n">FI</span><span class="p">),</span> <span class="n">Flag</span><span class="p">,</span>
                                 <span class="n">MFI</span><span class="p">.</span><span class="n">getObjectSize</span><span class="p">(</span><span class="n">FI</span><span class="p">),</span> <span class="n">Align</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEInstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">storeRegToStack</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                       <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                       <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isKill</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                       <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>

  <span class="kt">void</span> <span class="n">loadRegFromStack</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                        <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                        <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0SEInstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0SEInstrInfo</span><span class="o">::</span>
<span class="n">storeRegToStack</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isKill</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span>
                <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">MachineMemOperand</span> <span class="o">*</span><span class="n">MMO</span> <span class="o">=</span> <span class="n">GetMemOperand</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">MachineMemOperand</span><span class="o">::</span><span class="n">MOStore</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ST</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Register class not handled!&quot;</span><span class="p">);</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">)).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">,</span> <span class="n">getKillRegState</span><span class="p">(</span><span class="n">isKill</span><span class="p">))</span>
    <span class="p">.</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">).</span><span class="n">addMemOperand</span><span class="p">(</span><span class="n">MMO</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0SEInstrInfo</span><span class="o">::</span>
<span class="n">loadRegFromStack</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                 <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                 <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">MachineMemOperand</span> <span class="o">*</span><span class="n">MMO</span> <span class="o">=</span> <span class="n">GetMemOperand</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">MachineMemOperand</span><span class="o">::</span><span class="n">MOLoad</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LD</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Register class not handled!&quot;</span><span class="p">);</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">),</span> <span class="n">DestReg</span><span class="p">).</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">)</span>
    <span class="p">.</span><span class="n">addMemOperand</span><span class="p">(</span><span class="n">MMO</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Functions storeRegToStack() Cpu0SEInstrInfo.cpp,
storeRegToStackSlot() of Cpu0InstrInfo.cpp are
handling the registers spill during register allocation process.
Since each local variable connecting to a frame index,  &#8221;.addFrameIndex(FI).
addImm(Offset).addMemOperand(MMO); where Offset is 0&#8221; in storeRegToStack().
The loadRegFromStackSlot() and loadRegFromStack() will be used in future and
we add them at this point in advance.</p>
<p>The JSUB and JALR defined in Cpu0InstrInfo.td as above all use Cpu0JmpLink
node. They are distinguishable since JSUB use &#8220;imm&#8221; operand while
JALR uses register operand.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>let Predicates = [Ch9_1] in {
def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0JmpLink (i32 texternalsym:$dst)),
          (JSUB texternalsym:$dst)&gt;;

</pre>
</div>
<p>The code tells TableGen generating pattern match code that matching the &#8220;imm&#8221; for
&#8220;tglobaladdr&#8221; pattern first. If it fails then trying to match &#8220;texternalsym&#8221; next.
The function you declared belongs to &#8220;tglobaladdr&#8221;, (for instance the function
sum_i(...) defined in ch9_1.cpp belongs to &#8220;tglobaladdr&#8221;); the function which
implicitly used by llvm belongs to &#8220;texternalsym&#8221; (for instance the function
&#8220;memcpy&#8221; belongs to &#8220;texternalsym&#8221;). The &#8220;memcpy&#8221; will be generated when
defining a long string. The ch9_1_2.cpp is an example for generating &#8220;memcpy&#8221;
function call. It will be shown in next section with Chapter9_2 example code.
The Cpu0GenDAGISel.inc contains the TablGen
generated information about JSUB and JALR pattern match information as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre>          <span class="cm">/*SwitchOpcode*/</span> <span class="mi">74</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">JmpLink</span><span class="p">),</span><span class="c1">// -&gt;734</span>
<span class="cm">/*660*/</span>     <span class="n">OPC_RecordNode</span><span class="p">,</span>   <span class="c1">// #0 = &#39;Cpu0JmpLink&#39; chained node</span>
<span class="cm">/*661*/</span>     <span class="n">OPC_CaptureGlueInput</span><span class="p">,</span>
<span class="cm">/*662*/</span>     <span class="n">OPC_RecordChild1</span><span class="p">,</span> <span class="c1">// #1 = $target</span>
<span class="cm">/*663*/</span>     <span class="n">OPC_Scope</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="cm">/*-&gt;722*/</span> <span class="c1">// 2 children in Scope</span>
<span class="cm">/*665*/</span>       <span class="n">OPC_MoveChild</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/*667*/</span>       <span class="n">OPC_SwitchOpcode</span> <span class="cm">/*3 cases */</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">Constant</span><span class="p">),</span>
<span class="c1">// -&gt;693</span>
<span class="cm">/*671*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*672*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*673*/</span>         <span class="n">OPC_EmitConvertToTarget</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/*675*/</span>         <span class="n">OPC_Scope</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/*-&gt;684*/</span> <span class="c1">// 2 children in Scope</span>
<span class="cm">/*684*/</span>         <span class="cm">/*Scope*/</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/*-&gt;692*/</span>
<span class="cm">/*685*/</span>           <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                      <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                  <span class="c1">// Src: (Cpu0JmpLink (imm:iPTR):$target) - Complexity = 6</span>
                  <span class="c1">// Dst: (JSUB (imm:iPTR):$target)</span>
<span class="cm">/*692*/</span>         <span class="mi">0</span><span class="p">,</span> <span class="cm">/*End of Scope*/</span>
              <span class="cm">/*SwitchOpcode*/</span> <span class="mi">11</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TargetGlobalAddress</span><span class="p">),</span><span class="c1">// -&gt;707</span>
<span class="cm">/*696*/</span>         <span class="n">OPC_CheckType</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*698*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*699*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*700*/</span>         <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                    <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                <span class="c1">// Src: (Cpu0JmpLink (tglobaladdr:i32):$dst) - Complexity = 6</span>
                <span class="c1">// Dst: (JSUB (tglobaladdr:i32):$dst)</span>
              <span class="cm">/*SwitchOpcode*/</span> <span class="mi">11</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TargetExternalSymbol</span><span class="p">),</span><span class="c1">// -&gt;721</span>
<span class="cm">/*710*/</span>         <span class="n">OPC_CheckType</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*712*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*713*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*714*/</span>         <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                    <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                <span class="c1">// Src: (Cpu0JmpLink (texternalsym:i32):$dst) - Complexity = 6</span>
                <span class="c1">// Dst: (JSUB (texternalsym:i32):$dst)</span>
              <span class="mi">0</span><span class="p">,</span> <span class="c1">// EndSwitchOpcode</span>
<span class="cm">/*722*/</span>     <span class="cm">/*Scope*/</span> <span class="mi">10</span><span class="p">,</span> <span class="cm">/*-&gt;733*/</span>
<span class="cm">/*723*/</span>       <span class="n">OPC_CheckChild1Type</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*725*/</span>       <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*726*/</span>       <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JALR</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                  <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
              <span class="c1">// Src: (Cpu0JmpLink CPURegs:i32:$rb) - Complexity = 3</span>
              <span class="c1">// Dst: (JALR CPURegs:i32:$rb)</span>
<span class="cm">/*733*/</span>     <span class="mi">0</span><span class="p">,</span> <span class="cm">/*End of Scope*/</span>
</pre></div>
</div>
<p>After above changes, you can run Chapter9_1/ with ch9_1.cpp and see what happens
in the following,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-83:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch9_1.bc -o ch9_1.cpu0.s
Assertion failed: <span class="o">((</span>CLI.IsTailCall <span class="o">||</span> InVals.size<span class="o">()</span> <span class="o">==</span> CLI.Ins.size<span class="o">())</span> <span class="o">&amp;&amp;</span>
<span class="s2">&quot;LowerCall didn&#39;t emit the correct number of values!&quot;</span><span class="o">)</span>, <span class="k">function </span>LowerCallTo,
file /Users/Jonathan/llvm/test/src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.
cpp, ...
...
0.  Program arguments: /Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o
ch9_1.cpu0.s
1.  Running pass <span class="s1">&#39;Function Pass Manager&#39;</span> on module <span class="s1">&#39;ch9_1.bc&#39;</span>.
2.  Running pass <span class="s1">&#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39;</span> on <span class="k">function</span>
<span class="s1">&#39;@main&#39;</span>
Illegal instruction: 4
</pre></div>
</div>
<p>Now, the LowerFormalArguments() has the correct number, but LowerCall() has not
the correct number of values!</p>
</div>
<div class="section" id="store-outgoing-arguments-to-stack-frame">
<h2><a class="toc-backref" href="#id17">Store outgoing arguments to stack frame</a><a class="headerlink" href="#store-outgoing-arguments-to-stack-frame" title="Permalink to this headline">¶</a></h2>
<p><a class="pageref" href="#funccall-f2">Figure  2</a> depicts two steps to take care arguments passing.
One is store outgoing arguments in caller function, and the other is load
incoming arguments in callee function.
We defined LowerFormalArguments() for <strong>“load incoming arguments”</strong> in callee
function last section.
Now, we will finish <strong>“store outgoing arguments”</strong> in caller function.
LowerCall() is responsible to do this. The implementation as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">/// \brief Create a MachinePointerInfo that has a Cpu0CallEntr object</span>
  <span class="c1">/// representing a GOT entry for an external function.</span>
  <span class="n">MachinePointerInfo</span> <span class="nf">callPtrInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">);</span>

  <span class="c1">/// \brief Create a MachinePointerInfo that has a Cpu0CallEntr object</span>
  <span class="c1">/// representing a GOT entry for a global function.</span>
  <span class="n">MachinePointerInfo</span> <span class="nf">callPtrInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">Val</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0MachineFunction.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MachinePointerInfo</span> <span class="n">Cpu0FunctionInfo</span><span class="o">::</span><span class="n">callPtrInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0CallEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">E</span> <span class="o">=</span> <span class="n">ExternalCallEntries</span><span class="p">[</span><span class="n">Name</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">E</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0CallEntry</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Name</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">MachinePointerInfo</span><span class="p">(</span><span class="n">E</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="p">}</span>

<span class="n">MachinePointerInfo</span> <span class="n">Cpu0FunctionInfo</span><span class="o">::</span><span class="n">callPtrInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">Val</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0CallEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">E</span> <span class="o">=</span> <span class="n">GlobalCallEntries</span><span class="p">[</span><span class="n">Val</span><span class="p">];</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">E</span><span class="p">)</span>
    <span class="n">E</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Cpu0CallEntry</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Val</span><span class="p">);</span>

  <span class="k">return</span> <span class="nf">MachinePointerInfo</span><span class="p">(</span><span class="n">E</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">/// This function fills Ops, which is the list of operands that will later</span>
    <span class="c1">/// be used when a function call node is created. It also generates</span>
    <span class="c1">/// copyToReg nodes to set up argument registers.</span>
    <span class="k">virtual</span> <span class="kt">void</span>
    <span class="n">getOpndList</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
                <span class="kt">bool</span> <span class="n">IsPICCall</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">GlobalOrExternal</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">InternalLinkage</span><span class="p">,</span>
                <span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Callee</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">/// Cpu0CC - This class provides methods used to analyze formal and call</span>
    <span class="c1">/// arguments and inquire about calling convention information.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="kt">void</span> <span class="nf">analyzeCallOperands</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                               <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                               <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ArgListEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FuncArgs</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">.</span>  <span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">Cpu0CC</span><span class="o">::</span><span class="n">SpecialCallingConvType</span> <span class="n">getSpecialCallingConv</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Callee</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// Lower Operand helpers</span>
    <span class="n">SDValue</span> <span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                            <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                            <span class="n">SDLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span> <span class="k">const</span> <span class="n">Type</span> <span class="o">*</span><span class="n">RetTy</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">/// passByValArg - Pass a byval argument in registers or on stack.</span>
    <span class="kt">void</span> <span class="n">passByValArg</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span>
                      <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
                      <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">MemOpChains</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span>
                      <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="k">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span>
                      <span class="k">const</span> <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">SDValue</span> <span class="n">passArgOnStack</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                           <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsTailCall</span><span class="p">,</span>
                           <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="kt">bool</span> <span class="n">CanLowerReturn</span><span class="p">(</span><span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                        <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                        <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                        <span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">passArgOnStack</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">,</span>
                                   <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span>
                                   <span class="kt">bool</span> <span class="n">IsTailCall</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsTailCall</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">PtrOff</span> <span class="o">=</span>
        <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()),</span> <span class="n">StackPtr</span><span class="p">,</span>
                    <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">Offset</span><span class="p">,</span> <span class="n">DL</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">PtrOff</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span>
                        <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">Arg</span><span class="p">.</span><span class="n">getValueSizeInBits</span><span class="p">()</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">Offset</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FIN</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">FIN</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="p">(),</span>
                      <span class="cm">/*isVolatile=*/</span> <span class="nb">true</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">getOpndList</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="n">IsPICCall</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">GlobalOrExternal</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">InternalLinkage</span><span class="p">,</span>
            <span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Callee</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// T9 should contain the address of the callee function if</span>
  <span class="c1">// -reloction-model=pic or it is an indirect call.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPICCall</span> <span class="o">||</span> <span class="o">!</span><span class="n">GlobalOrExternal</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">T9Reg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">T9</span><span class="p">;</span>
    <span class="n">RegsToPass</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">T9Reg</span><span class="p">,</span> <span class="n">Callee</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span>
    <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Callee</span><span class="p">);</span>

  <span class="c1">// Insert node &quot;GP copy globalreg&quot; before call to function.</span>
  <span class="c1">//</span>
  <span class="c1">// R_CPU0_CALL* operators (emitted when non-internal functions are called</span>
  <span class="c1">// in PIC mode) allow symbols to be resolved via lazy binding.</span>
  <span class="c1">// The lazy binding stub requires GP to point to the GOT.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPICCall</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">InternalLinkage</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">GPReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">;</span>
    <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">;</span>
    <span class="n">RegsToPass</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">GPReg</span><span class="p">,</span> <span class="n">getGlobalReg</span><span class="p">(</span><span class="n">CLI</span><span class="p">.</span><span class="n">DAG</span><span class="p">,</span> <span class="n">Ty</span><span class="p">)));</span>
  <span class="p">}</span>

  <span class="c1">// Build a sequence of copy-to-reg nodes chained together with token</span>
  <span class="c1">// chain and flag operands which copy the outgoing args into registers.</span>
  <span class="c1">// The InFlag in necessary since all emitted instructions must be</span>
  <span class="c1">// stuck together.</span>
  <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">RegsToPass</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">CLI</span><span class="p">.</span><span class="n">DL</span><span class="p">,</span> <span class="n">RegsToPass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span>
                                 <span class="n">RegsToPass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">);</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Add argument registers to the end of the list so that they are</span>
  <span class="c1">// known live into the call.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">RegsToPass</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">CLI</span><span class="p">.</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">RegsToPass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span>
                                      <span class="n">RegsToPass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">getValueType</span><span class="p">()));</span>

  <span class="c1">// Add a register mask operand representing the call-preserved registers.</span>
  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span> <span class="o">=</span> <span class="n">Subtarget</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">Mask</span> <span class="o">=</span> 
      <span class="n">TRI</span><span class="o">-&gt;</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CLI</span><span class="p">.</span><span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span> <span class="n">CLI</span><span class="p">.</span><span class="n">CallConv</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Mask</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Missing call preserved mask for calling convention&quot;</span><span class="p">);</span>
  <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">CLI</span><span class="p">.</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegisterMask</span><span class="p">(</span><span class="n">Mask</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">InFlag</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span>
    <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">InFlag</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerCall - functions arguments are copied from virtual regs to</span>
<span class="c1">/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span>                     <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">DAG</span><span class="p">;</span>
  <span class="n">SDLoc</span> <span class="n">DL</span>                              <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">DL</span><span class="p">;</span>
  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span> <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Outs</span><span class="p">;</span>
  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span>     <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">OutVals</span><span class="p">;</span>
  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span>   <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Ins</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">Chain</span>                         <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Chain</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">Callee</span>                        <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Callee</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">IsTailCall</span>                      <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">IsTailCall</span><span class="p">;</span>
  <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span>              <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">CallConv</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">IsVarArg</span>                         <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">IsVarArg</span><span class="p">;</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">TFL</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getSubtarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">FuncInfo</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">IsPIC</span> <span class="o">=</span> <span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">;</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// Analyze operands of the call, assigning locations to each operand.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">ArgLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="nf">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
                 <span class="n">ArgLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>
  <span class="n">Cpu0CC</span><span class="o">::</span><span class="n">SpecialCallingConvType</span> <span class="n">SpecialCallingConv</span> <span class="o">=</span>
    <span class="n">getSpecialCallingConv</span><span class="p">(</span><span class="n">Callee</span><span class="p">);</span>
  <span class="n">Cpu0CC</span> <span class="nf">Cpu0CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">ABI</span><span class="p">.</span><span class="n">IsO32</span><span class="p">(),</span> 
                    <span class="n">CCInfo</span><span class="p">,</span> <span class="n">SpecialCallingConv</span><span class="p">);</span>

  <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">analyzeCallOperands</span><span class="p">(</span><span class="n">Outs</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                 <span class="n">Subtarget</span><span class="p">.</span><span class="n">abiUsesSoftFloat</span><span class="p">(),</span>
                                 <span class="n">Callee</span><span class="p">.</span><span class="n">getNode</span><span class="p">(),</span> <span class="n">CLI</span><span class="p">.</span><span class="n">getArgs</span><span class="p">());</span>

  <span class="c1">// Get a count of how many bytes are to be pushed on the stack.</span>
  <span class="kt">unsigned</span> <span class="n">NextStackOffset</span> <span class="o">=</span> <span class="n">CCInfo</span><span class="p">.</span><span class="n">getNextStackOffset</span><span class="p">();</span>

  <span class="c1">//@TailCall 1 {</span>
  <span class="c1">// Check if it&#39;s really possible to do a tail call.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="n">IsTailCall</span> <span class="o">=</span>
      <span class="n">isEligibleForTailCallOptimization</span><span class="p">(</span><span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="n">NextStackOffset</span><span class="p">,</span>
                                        <span class="o">*</span><span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsTailCall</span> <span class="o">&amp;&amp;</span> <span class="n">CLI</span><span class="p">.</span><span class="n">CS</span> <span class="o">&amp;&amp;</span> <span class="n">CLI</span><span class="p">.</span><span class="n">CS</span><span class="o">-&gt;</span><span class="n">isMustTailCall</span><span class="p">())</span>
    <span class="n">report_fatal_error</span><span class="p">(</span><span class="s">&quot;failed to perform tail call elimination on a call &quot;</span>
                       <span class="s">&quot;site marked musttail&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="o">++</span><span class="n">NumTailCalls</span><span class="p">;</span>
  <span class="c1">//@TailCall 1 }</span>

  <span class="c1">// Chain is the output chain of the last Load/Store or CopyToReg node.</span>
  <span class="c1">// ByValChain is the output chain of the last Memcpy node created for copying</span>
  <span class="c1">// byval arguments to the stack.</span>
  <span class="kt">unsigned</span> <span class="n">StackAlignment</span> <span class="o">=</span> <span class="n">TFL</span><span class="o">-&gt;</span><span class="n">getStackAlignment</span><span class="p">();</span>
  <span class="n">NextStackOffset</span> <span class="o">=</span> <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">NextStackOffset</span><span class="p">,</span> <span class="n">StackAlignment</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">NextStackOffsetVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">NextStackOffset</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

  <span class="c1">//@TailCall 2 {</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCALLSEQ_START</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">NextStackOffsetVal</span><span class="p">,</span> <span class="n">DL</span><span class="p">);</span>
  <span class="c1">//@TailCall 2 }</span>

  <span class="n">SDValue</span> <span class="n">StackPtr</span> <span class="o">=</span>
      <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span>
                         <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()));</span>

  <span class="c1">// With EABI is it possible to have 16 args on registers.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">RegsToPass</span><span class="p">;</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">MemOpChains</span><span class="p">;</span>
  <span class="n">Cpu0CC</span><span class="o">::</span><span class="n">byval_iterator</span> <span class="n">ByValArg</span> <span class="o">=</span> <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">byval_begin</span><span class="p">();</span>

  <span class="c1">//@1 {</span>
  <span class="c1">// Walk the register/memloc assignments, inserting copies/loads.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//@1 }</span>
    <span class="n">SDValue</span> <span class="n">Arg</span> <span class="o">=</span> <span class="n">OutVals</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">MVT</span> <span class="n">LocVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocVT</span><span class="p">();</span>
    <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">Flags</span> <span class="o">=</span> <span class="n">Outs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">;</span>

    <span class="c1">//@ByVal Arg {</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">ByValArg</span> <span class="o">!=</span> <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">byval_end</span><span class="p">());</span>
      <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">IsTailCall</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;Do not tail-call optimize if there is a byval argument.&quot;</span><span class="p">);</span>
      <span class="n">passByValArg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegsToPass</span><span class="p">,</span> <span class="n">MemOpChains</span><span class="p">,</span> <span class="n">StackPtr</span><span class="p">,</span> <span class="n">MFI</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                   <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">ByValArg</span><span class="p">,</span> <span class="n">Flags</span><span class="p">,</span> <span class="n">Subtarget</span><span class="p">.</span><span class="n">isLittle</span><span class="p">());</span>
      <span class="o">++</span><span class="n">ByValArg</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//@ByVal Arg }</span>

    <span class="c1">// Promote the value if needed.</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">getLocInfo</span><span class="p">())</span> <span class="p">{</span>
    <span class="nl">default:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unknown loc info!&quot;</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CCValAssign</span>:<span class="o">:</span><span class="n">Full</span><span class="o">:</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">CCValAssign</span>:<span class="o">:</span><span class="n">SExt</span><span class="o">:</span>
      <span class="n">Arg</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SIGN_EXTEND</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">Arg</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">CCValAssign</span>:<span class="o">:</span><span class="n">ZExt</span><span class="o">:</span>
      <span class="n">Arg</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ZERO_EXTEND</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">Arg</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">CCValAssign</span>:<span class="o">:</span><span class="n">AExt</span><span class="o">:</span>
      <span class="n">Arg</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ANY_EXTEND</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">Arg</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Arguments that can be passed on register must be kept at</span>
    <span class="c1">// RegsToPass vector</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isRegLoc</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">RegsToPass</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">getLocReg</span><span class="p">(),</span> <span class="n">Arg</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Register can&#39;t get to this point...</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isMemLoc</span><span class="p">());</span>

    <span class="c1">// emit ISD::STORE whichs stores the</span>
    <span class="c1">// parameter value to a stack Location</span>
    <span class="n">MemOpChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">passArgOnStack</span><span class="p">(</span><span class="n">StackPtr</span><span class="p">,</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">(),</span>
                                         <span class="n">Chain</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">IsTailCall</span><span class="p">,</span> <span class="n">DAG</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// Transform all store nodes into one single node because all store</span>
  <span class="c1">// nodes are independent of each other.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MemOpChains</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">MemOpChains</span><span class="p">);</span>

  <span class="c1">// If the callee is a GlobalAddress/ExternalSymbol node (quite common, every</span>
  <span class="c1">// direct call is) turn it into a TargetGlobalAddress/TargetExternalSymbol</span>
  <span class="c1">// node so that legalize doesn&#39;t hack it.</span>
  <span class="kt">bool</span> <span class="n">IsPICCall</span> <span class="o">=</span> <span class="n">IsPIC</span><span class="p">;</span> <span class="c1">// true if calls are translated to</span>
                                         <span class="c1">// jalr $t9</span>
  <span class="kt">bool</span> <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">InternalLinkage</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">CalleeLo</span><span class="p">;</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">Callee</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">GlobalAddressSDNode</span> <span class="o">*</span><span class="n">G</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalAddressSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Callee</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsPICCall</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">Val</span> <span class="o">=</span> <span class="n">G</span><span class="o">-&gt;</span><span class="n">getGlobal</span><span class="p">();</span>
      <span class="n">InternalLinkage</span> <span class="o">=</span> <span class="n">Val</span><span class="o">-&gt;</span><span class="n">hasInternalLinkage</span><span class="p">();</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">InternalLinkage</span><span class="p">)</span>
        <span class="n">Callee</span> <span class="o">=</span> <span class="n">getAddrLocal</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
      <span class="k">else</span>
        <span class="n">Callee</span> <span class="o">=</span> <span class="n">getAddrGlobal</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_CALL</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span>
                               <span class="n">FuncInfo</span><span class="o">-&gt;</span><span class="n">callPtrInfo</span><span class="p">(</span><span class="n">Val</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span>
      <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">getGlobal</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span>
                                          <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()),</span> <span class="mi">0</span><span class="p">,</span>
                                          <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_NO_FLAG</span><span class="p">);</span>
    <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ExternalSymbolSDNode</span> <span class="o">*</span><span class="n">S</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ExternalSymbolSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Callee</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Sym</span> <span class="o">=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsPIC</span><span class="p">)</span> <span class="c1">// static</span>
      <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetExternalSymbol</span><span class="p">(</span><span class="n">Sym</span><span class="p">,</span>
                                           <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()),</span>
                                           <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_NO_FLAG</span><span class="p">);</span>
    <span class="k">else</span> <span class="c1">// PIC</span>
      <span class="n">Callee</span> <span class="o">=</span> <span class="n">getAddrGlobal</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_CALL</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span>
                             <span class="n">FuncInfo</span><span class="o">-&gt;</span><span class="n">callPtrInfo</span><span class="p">(</span><span class="n">Sym</span><span class="p">));</span>

    <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">Ops</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Chain</span><span class="p">);</span>
  <span class="n">SDVTList</span> <span class="n">NodeTys</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getVTList</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">);</span>

  <span class="n">getOpndList</span><span class="p">(</span><span class="n">Ops</span><span class="p">,</span> <span class="n">RegsToPass</span><span class="p">,</span> <span class="n">IsPICCall</span><span class="p">,</span> <span class="n">GlobalOrExternal</span><span class="p">,</span> <span class="n">InternalLinkage</span><span class="p">,</span>
              <span class="n">CLI</span><span class="p">,</span> <span class="n">Callee</span><span class="p">,</span> <span class="n">Chain</span><span class="p">);</span>

  <span class="c1">//@TailCall 3 {</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">TailCall</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Ops</span><span class="p">);</span>
  <span class="c1">//@TailCall 3 }</span>

  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">JmpLink</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">NodeTys</span><span class="p">,</span> <span class="n">Ops</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Create the CALLSEQ_END node.</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCALLSEQ_END</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">NextStackOffsetVal</span><span class="p">,</span>
                             <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span> <span class="n">InFlag</span><span class="p">,</span> <span class="n">DL</span><span class="p">);</span>
  <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Handle result values, copying them out of physregs into vregs that we</span>
  <span class="c1">// return.</span>
  <span class="k">return</span> <span class="nf">LowerCallResult</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">,</span> <span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span>
                         <span class="n">Ins</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">InVals</span><span class="p">,</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Callee</span><span class="p">.</span><span class="n">getNode</span><span class="p">(),</span> <span class="n">CLI</span><span class="p">.</span><span class="n">RetTy</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerCallResult - Lower the result values of a call into the</span>
<span class="c1">/// appropriate copies out of appropriate physical registers.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                                    <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                    <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                    <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">Type</span> <span class="o">*</span><span class="n">RetTy</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Assign locations to each value returned by this call.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="nf">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
		 <span class="n">RVLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>
		 
  <span class="n">Cpu0CC</span> <span class="nf">Cpu0CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">ABI</span><span class="p">.</span><span class="n">IsO32</span><span class="p">(),</span> <span class="n">CCInfo</span><span class="p">);</span>

  <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">analyzeCallResult</span><span class="p">(</span><span class="n">Ins</span><span class="p">,</span> <span class="n">Subtarget</span><span class="p">.</span><span class="n">abiUsesSoftFloat</span><span class="p">(),</span>
                               <span class="n">CallNode</span><span class="p">,</span> <span class="n">RetTy</span><span class="p">);</span>

  <span class="c1">// Copy all of the result registers out of their specified physreg.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getLocReg</span><span class="p">(),</span>
                                     <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getLocVT</span><span class="p">(),</span> <span class="n">InFlag</span><span class="p">);</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">Val</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Val</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getValVT</span><span class="p">()</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getLocVT</span><span class="p">())</span>
      <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">BITCAST</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getValVT</span><span class="p">(),</span> <span class="n">Val</span><span class="p">);</span>

    <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Val</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">CanLowerReturn</span><span class="p">(</span><span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                   <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                   <span class="n">LLVMContext</span> <span class="o">&amp;</span><span class="n">Context</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="nf">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="n">MF</span><span class="p">,</span>
                 <span class="n">RVLocs</span><span class="p">,</span> <span class="n">Context</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">CCInfo</span><span class="p">.</span><span class="n">CheckReturn</span><span class="p">(</span><span class="n">Outs</span><span class="p">,</span> <span class="n">RetCC_Cpu0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span><span class="n">SpecialCallingConvType</span>
  <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getSpecialCallingConv</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Callee</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">Cpu0CC</span><span class="o">::</span><span class="n">SpecialCallingConvType</span> <span class="n">SpecialCallingConv</span> <span class="o">=</span>
    <span class="n">Cpu0CC</span><span class="o">::</span><span class="n">NoSpecialCallingConv</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">SpecialCallingConv</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span>
<span class="n">analyzeCallOperands</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Args</span><span class="p">,</span>
                    <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span> <span class="k">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ArgListEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FuncArgs</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//@analyzeCallOperands body {</span>
  <span class="n">assert</span><span class="p">((</span><span class="n">CallConv</span> <span class="o">!=</span> <span class="n">CallingConv</span><span class="o">::</span><span class="n">Fast</span> <span class="o">||</span> <span class="o">!</span><span class="n">IsVarArg</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;CallingConv::Fast shouldn&#39;t be used for vararg functions.&quot;</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="n">NumOpnds</span> <span class="o">=</span> <span class="n">Args</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">FixedFn</span> <span class="o">=</span> <span class="n">fixedArgFn</span><span class="p">();</span>

  <span class="c1">//@3 {</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">NumOpnds</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//@3 }</span>
    <span class="n">MVT</span> <span class="n">ArgVT</span> <span class="o">=</span> <span class="n">Args</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">VT</span><span class="p">;</span>
    <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">ArgFlags</span> <span class="o">=</span> <span class="n">Args</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">Flags</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">R</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ArgFlags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">handleByValArg</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">ArgVT</span><span class="p">,</span> <span class="n">ArgVT</span><span class="p">,</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">Full</span><span class="p">,</span> <span class="n">ArgFlags</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">{</span>
      <span class="n">MVT</span> <span class="n">RegVT</span> <span class="o">=</span> <span class="n">getRegVT</span><span class="p">(</span><span class="n">ArgVT</span><span class="p">,</span> <span class="n">FuncArgs</span><span class="p">[</span><span class="n">Args</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">OrigArgIndex</span><span class="p">].</span><span class="n">Ty</span><span class="p">,</span> <span class="n">CallNode</span><span class="p">,</span>
                           <span class="n">IsSoftFloat</span><span class="p">);</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">FixedFn</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">ArgVT</span><span class="p">,</span> <span class="n">RegVT</span><span class="p">,</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">Full</span><span class="p">,</span> <span class="n">ArgFlags</span><span class="p">,</span> <span class="n">CCInfo</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef NDEBUG</span>
      <span class="n">dbgs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Call operand #&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">I</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; has unhandled type &quot;</span>
             <span class="o">&lt;&lt;</span> <span class="n">EVT</span><span class="p">(</span><span class="n">ArgVT</span><span class="p">).</span><span class="n">getEVTString</span><span class="p">();</span>
<span class="cp">#endif</span>
      <span class="n">llvm_unreachable</span><span class="p">(</span><span class="n">nullptr</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Just like load incoming arguments from stack frame, we call
CCInfo(CallConv,..., ArgLocs, ...) to get outgoing arguments information before
enter <strong>“for loop”*.
They&#8217;re almost same in **“for loop”</strong> with LowerFormalArguments(), except
LowerCall() creates store DAG vector instead of load DAG vector.
After the <strong>“for loop”</strong>, it create <strong>“ld $t9, %call16(_Z5sum_iiiiiii)($gp)”</strong>
and jalr $t9 for calling subroutine (the $6 is $t9) in PIC mode.</p>
<p>Like load incoming arguments, we need to implement storeRegToStackSlot() at
early chapter.</p>
<div class="section" id="pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup">
<h3><a class="toc-backref" href="#id18">Pseudo hook instruction ADJCALLSTACKDOWN and ADJCALLSTACKUP</a><a class="headerlink" href="#pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup" title="Permalink to this headline">¶</a></h3>
<p>DAG.getCALLSEQ_START() and DAG.getCALLSEQ_END() are set before and after the
<strong>“for loop”</strong>, respectively, they insert
CALLSEQ_START, CALLSEQ_END, and translate them into pseudo machine instructions
!ADJCALLSTACKDOWN, !ADJCALLSTACKUP later according Cpu0InstrInfo.td definition
as follows.</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">SDT_Cpu0CallSeqStart</span> <span class="o">:</span> <span class="n">SDCallSeqStart</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">SDT_Cpu0CallSeqEnd</span>   <span class="o">:</span> <span class="n">SDCallSeqEnd</span><span class="o">&lt;</span><span class="p">[</span><span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">SDTCisVT</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span> <span class="n">i32</span><span class="o">&gt;</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// These are target-independent nodes, but have target-specific formats.</span>
<span class="n">def</span> <span class="n">callseq_start</span> <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;ISD::CALLSEQ_START&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0CallSeqStart</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">callseq_end</span>   <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;ISD::CALLSEQ_END&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0CallSeqEnd</span><span class="p">,</span>
                           <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span> <span class="n">SDNPOutGlue</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><pre>//===----------------------------------------------------------------------===//
// Pseudo instructions
//===----------------------------------------------------------------------===//

let Predicates = [Ch9_2] in {
// As stack alignment is always done with addiu, we need a 16-bit immediate
let Defs = [SP], Uses = [SP] in {
def ADJCALLSTACKDOWN : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt),
                                  "!ADJCALLSTACKDOWN $amt",
                                  [(callseq_start timm:$amt)]&gt;;
def ADJCALLSTACKUP   : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt1, uimm16:$amt2),
                                  "!ADJCALLSTACKUP $amt1",
                                  [(callseq_end timm:$amt1, timm:$amt2)]&gt;;
}

//@def CPRESTORE {
// When handling PIC code the assembler needs .cpload and .cprestore
// directives. If the real instructions corresponding these directives
// are used, we have the same behavior, but get also a bunch of warnings
// from the assembler.
let hasSideEffects = 0 in
def CPRESTORE : Cpu0Pseudo&lt;(outs), (ins i32imm:$loc, CPURegs:$gp),
                           ".cprestore\t$loc", []&gt;;
} // let Predicates = [Ch9_2]
</pre>
</div>
<p>With below definition, eliminateCallFramePseudoInstr() will be called when
llvm meets pseudo instructions ADJCALLSTACKDOWN and ADJCALLSTACKUP.
It just discard these 2 pseudo instructions, and llvm will add offset to
stack.</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="o">:</span> 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADJCALLSTACKDOWN</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADJCALLSTACKUP</span><span class="p">),</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="k">const</span> <span class="n">override</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Eliminate ADJCALLSTACKDOWN, ADJCALLSTACKUP pseudo instructions</span>
<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span>
<span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                              <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">MBB</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="read-lowercall-with-graphivz-s-help">
<h3><a class="toc-backref" href="#id19">Read Lowercall() with Graphivz&#8217;s help</a><a class="headerlink" href="#read-lowercall-with-graphivz-s-help" title="Permalink to this headline">¶</a></h3>
<p>The whole DAGs created for outgoing arguments as
<a class="pageref" href="#funccall-f-outgoing-arg">Figure  5</a> for ch9_outgoing.cpp with cpu032I.
LowerCall() will generate the DAG nodes as
<a class="pageref" href="#funccall-f-outgoing-arg-lowercal">Figure  6</a>
for ch9_outgoing.cpp with cpu032I. The corresponding code of DAGs Store and
TargetGlobalAddress are listed in the figure, user can match the other DAGs
to function LowerCall() easily.
Through Graphivz tool with llc option -view-dag-combine1-dags, you can design
a small input C or llvm IR source code and check the DAGs to understand the
code in LowerCall() and LowerFormalArguments().
At the sub-sections &#8220;variable arguments&#8221; and &#8220;dynamic stack allocation
support&#8221; in the later section of this chapter, you can design
the input example with this features and check the DAGs with these two functions
again to make sure you know the code in these two function. About Graphivz,
please refer to section &#8220;Display llvm IR nodes with Graphviz&#8221; of chapter 4,
Arithmetic and logic instructions.
The DAGs diagram can be gotten by llc option as follows,</p>
<p class="rubric">lbdex/input/ch9_outgoing.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">call_sum_i</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>clang -O3 -target mips-unknown-linux-gnu -c
ch9_outgoing.cpp -emit-llvm -o ch9_outgoing.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llvm-dis ch9_outgoing.bc -o -
...
define i32 @_Z10call_sum_iv<span class="o">()</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> tail call i32 @_Z5sum_ii<span class="o">(</span>i32 1<span class="o">)</span>
  ret i32 %1
<span class="o">}</span>
JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -view-dag-combine1-dags -relocation-
<span class="nv">model</span><span class="o">=</span>static -filetype<span class="o">=</span>asm ch9_outgoing.bc -o -
      .text
      .section .mdebug.abiS32
      .previous
      .file   <span class="s2">&quot;ch9_outgoing.bc&quot;</span>
Writing <span class="s1">&#39;/var/folders/rf/8bgdgt9d6vgf5sn8h8_zycd00000gn/T/dag._Z10call_sum_iv-</span>
<span class="s1">0dfaf1.dot&#39;</span>...  <span class="k">done</span>.
Running <span class="s1">&#39;Graphviz&#39;</span> program...
</pre></div>
</div>
<div class="figure align-center" id="funccall-f-outgoing-arg">
<a class="reference internal image-reference" href="_images/outgoing-arg-S32.png"><img alt="_images/outgoing-arg-S32.png" src="_images/outgoing-arg-S32.png" style="width: 1192.1px; height: 1221.5px;" /></a>
<p class="caption">Figure 5: Outgoing arguments DAG created for ch9_outgoing.cpp with -cpu0-s32-calls=true</p>
</div>
<div class="figure align-center" id="funccall-f-outgoing-arg-lowercal">
<a class="reference internal image-reference" href="_images/outgoing-arg-LowerCall.png"><img alt="_images/outgoing-arg-LowerCall.png" src="_images/outgoing-arg-LowerCall.png" style="width: 945.0px; height: 756.0px;" /></a>
<p class="caption">Figure 6: Outgoing arguments DAG created by LowerCall() for ch9_outgoing.cpp with -cpu0-s32-calls=true</p>
</div>
<p>Mentioned in last section, option <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=true</span></tt> uses S32 calling
convention which passes all arguements at registers while option
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-s32-calls=false</span></tt> uses O32 pass first two arguments at
registers and other arguments at stack. The result as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -cpu0-s32-calls<span class="o">=</span><span class="nb">true</span>
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o -
        .text
        .section .mdebug.abiS32
        .previous
        .file <span class="s2">&quot;ch9_1.bc&quot;</span>
        .globl        _Z5sum_iiiiiii
        .align        2
        .type _Z5sum_iiiiiii,@function
        .ent  _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
        .frame        <span class="nv">$fp</span>,32,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .cpload       <span class="nv">$t9</span>
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
        ld    <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$5</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$t9</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$7</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$7</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$t9</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$5</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        lui   <span class="nv">$3</span>, %got_hi<span class="o">(</span>gI<span class="o">)</span>
        addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$gp</span>
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, %got_lo<span class="o">(</span>gI<span class="o">)(</span><span class="nv">$3</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        ld    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        ld    <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        ld    <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        ld    <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addu  <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
        ret   <span class="nv">$lr</span>
        nop
        .set  macro
        .set  reorder
        .end  _Z5sum_iiiiiii
<span class="nv">$tmp0</span>:
        .size _Z5sum_iiiiiii, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z5sum_iiiiiii

        .globl        main
        .align        2
        .type main,@function
        .ent  main                    <span class="c"># @main</span>
main:
        .frame        <span class="nv">$fp</span>,40,<span class="nv">$lr</span>
        .mask         0x00004000,-4
        .set  noreorder
        .cpload       <span class="nv">$t9</span>
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
        st    <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
        st    <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
        st    <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
        st    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
        st    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
        st    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
        jalr  <span class="nv">$t9</span>
        nop
        st    <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 40
        ret   <span class="nv">$lr</span>
        nop
        .set  macro
        .set  reorder
        .end  main
<span class="nv">$tmp1</span>:
        .size main, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-main

        .type gI,@object              <span class="c"># @gI</span>
        .data
        .globl        gI
        .align        2
gI:
        .4byte        100                     <span class="c"># 0x64</span>
        .size gI, 4

118-165-78-230:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -cpu0-s32-calls<span class="o">=</span><span class="nb">false</span>
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o -
  ...
        .globl        main
        .align        2
        .type main,@function
        .ent  main                    <span class="c"># @main</span>
main:
        .frame        <span class="nv">$fp</span>,40,<span class="nv">$lr</span>
        .mask         0x00004000,-4
        .set  noreorder
        .cpload       <span class="nv">$t9</span>
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
        st    <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
        st    <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
        st    <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
        st    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
        st    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 1
        addiu <span class="nv">$5</span>, <span class="nv">$zero</span>, 2
        jalr  <span class="nv">$t9</span>
        nop
        st    <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 40
        ret   <span class="nv">$lr</span>
        nop
        .set  macro
        .set  reorder
        .end  main
</pre></div>
</div>
</div>
<div class="section" id="long-and-short-string-initialization">
<h3><a class="toc-backref" href="#id20">Long and short string initialization</a><a class="headerlink" href="#long-and-short-string-initialization" title="Permalink to this headline">¶</a></h3>
<p>The last section mentioned the &#8220;JSUB texternalsym&#8221; pattern. Run Chapter9_2 with
ch9_1_2.cpp to get the result as below. For long string, llvm call memcpy() to
initialize string (char str[81] = &#8220;Hello world&#8221; in this case). For short string,
the &#8220;call memcpy&#8221; is translated into &#8220;store with contant&#8221; in stages of
optimization.</p>
<p class="rubric">lbdex/input/ch9_1_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">81</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Hello world&quot;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>llvm-dis ch9_1_2.bc -o -
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch9_1_2.bc&#39;</span>
...
@_ZZ4mainE3str <span class="o">=</span> private unnamed_addr constant <span class="o">[</span>81 x i8<span class="o">]</span> c<span class="s2">&quot;Hello world\00\00\00\</span>
<span class="s2">00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00</span>
<span class="s2">\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\0</span>
<span class="s2">0\00\00\00\00\00\00\00\00\00\00\00\00\00&quot;</span>, align 1
@_ZZ4mainE1s <span class="o">=</span> private unnamed_addr constant <span class="o">[</span>6 x i8<span class="o">]</span> c<span class="s2">&quot;Hello\00&quot;</span>, align 1

; Function Attrs: nounwind
define i32 @main<span class="o">()</span> <span class="c">#0 {</span>
entry:
  %retval <span class="o">=</span> alloca i32, align 4
  %str <span class="o">=</span> alloca <span class="o">[</span>81 x i8<span class="o">]</span>, align 1
  store i32 0, i32* %retval
  %0 <span class="o">=</span> bitcast <span class="o">[</span>81 x i8<span class="o">]</span>* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32<span class="o">(</span>i8* %0, i8* getelementptr inbounds
  <span class="o">([</span>81 x i8<span class="o">]</span>* @_ZZ4mainE3str, i32 0, i32 0<span class="o">)</span>, i32 81, i32 1, i1 <span class="nb">false</span><span class="o">)</span>
  %1 <span class="o">=</span> bitcast <span class="o">[</span>6 x i8<span class="o">]</span>* %s to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32<span class="o">(</span>i8* %1, i8* getelementptr inbounds
  <span class="o">([</span>6 x i8<span class="o">]</span>* @_ZZ4mainE1s, i32 0, i32 0<span class="o">)</span>, i32 6, i32 1, i1 <span class="nb">false</span><span class="o">)</span>

  ret i32 0
<span class="o">}</span>

JonathantekiiMac:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_1_2.cpp -emit-llvm -o ch9_1_2.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build
/Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -cpu0-s32-calls<span class="o">=</span><span class="nb">true</span>
-relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch9_1_2.bc -o -
  .section .mdebug.abi32
  ...
        lui   <span class="nv">$2</span>, %hi<span class="o">(</span><span class="nv">$_ZZ4mainE3str</span><span class="o">)</span>
        ori   <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span><span class="nv">$_ZZ4mainE3str</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 24
        st    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        jsub  memcpy
        nop
        lui   <span class="nv">$2</span>, %hi<span class="o">(</span><span class="nv">$_ZZ4mainE1s</span><span class="o">)</span>
        ori   <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span><span class="nv">$_ZZ4mainE1s</span><span class="o">)</span>
        lbu   <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        shl   <span class="nv">$3</span>, <span class="nv">$3</span>, 8
        lbu   <span class="nv">$4</span>, 5<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        or    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        sh    <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        lbu   <span class="nv">$3</span>, 2<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        shl   <span class="nv">$3</span>, <span class="nv">$3</span>, 8
        lbu   <span class="nv">$4</span>, 3<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        or    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        lbu   <span class="nv">$4</span>, 1<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        lbu   <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        shl   <span class="nv">$2</span>, <span class="nv">$2</span>, 8
        or    <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$4</span>
        shl   <span class="nv">$2</span>, <span class="nv">$2</span>, 16
        or    <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        st    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ...
      .type   <span class="nv">$_ZZ4mainE3str</span>,@object  <span class="c"># @_ZZ4mainE3str</span>
      .section        .rodata,<span class="s2">&quot;a&quot;</span>,@progbits
<span class="nv">$_ZZ4mainE3str</span>:
        .asciz        <span class="s2">&quot;Hello world\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="s2">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="s2">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="s2">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000&quot;</span>
        .size <span class="nv">$_ZZ4mainE3str</span>, 81

        .type <span class="nv">$_ZZ4mainE1s</span>,@object    <span class="c"># @_ZZ4mainE1s</span>
        .section      .rodata.str1.1,<span class="s2">&quot;aMS&quot;</span>,@progbits,1
<span class="nv">$_ZZ4mainE1s</span>:
        .asciz        <span class="s2">&quot;Hello&quot;</span>
        .size <span class="nv">$_ZZ4mainE1s</span>, 6
</pre></div>
</div>
<p>The &#8220;call memcpy&#8221; for short string is optimized by llvm before &#8220;DAG-&gt;DAG Pattern
Instruction Selection&#8221; stage and translates it into &#8220;store with contant&#8221; as
follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build
/Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -cpu0-s32-calls<span class="o">=</span><span class="nb">true</span>
-relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch9_1_2.bc -debug -o -

Initial selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 35 nodes:
  ...
        0x7fd909030810: &lt;multiple use&gt;
        0x7fd909030c10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1214606444&gt;  // <span class="nv">1214606444</span><span class="o">=</span><span class="nv">0x48656c6c</span><span class="o">=</span><span class="s2">&quot;Hell&quot;</span>

        0x7fd909030910: &lt;multiple use&gt;
        0x7fd90902d810: &lt;multiple use&gt;
      0x7fd909030d10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fd909030810, 0x7fd909030c10, 0x7fd909030910,
      0x7fd90902d810&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt;

        0x7fd909030810: &lt;multiple use&gt;
        0x7fd909030e10: <span class="nv">i16</span> <span class="o">=</span> Constant&lt;28416&gt;      // <span class="nv">28416</span><span class="o">=</span><span class="nv">0x6f00</span><span class="o">=</span><span class="s2">&quot;o\0&quot;</span>

        ...

        0x7fd90902d810: &lt;multiple use&gt;
      0x7fd909031210: <span class="nv">ch</span> <span class="o">=</span> store 0x7fd909030810, 0x7fd909030e10, 0x7fd909031010,
      0x7fd90902d810&lt;ST2<span class="o">[</span>%1+4<span class="o">](</span><span class="nv">align</span><span class="o">=</span>4<span class="o">)</span>&gt;
  ...
</pre></div>
</div>
<p>The incoming arguments is the formal arguments defined in compiler and program
language books. The outgoing arguments is the actual arguments.
Summary as Table: Callee incoming arguments and caller outgoing arguments.</p>
<table border="1" class="docutils">
<caption>Callee incoming arguments and caller outgoing arguments</caption>
<colgroup>
<col width="22%" />
<col width="39%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Callee</th>
<th class="head">Caller</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Charged Function</td>
<td>LowerFormalArguments()</td>
<td>LowerCall()</td>
</tr>
<tr class="row-odd"><td>Charged Function Created</td>
<td>Create load vectors for incoming arguments</td>
<td>Create store vectors for outgoing arguments</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="structure-type-support">
<h2><a class="toc-backref" href="#id21">Structure type support</a><a class="headerlink" href="#structure-type-support" title="Permalink to this headline">¶</a></h2>
<div class="section" id="ordinary-struct-type">
<h3><a class="toc-backref" href="#id22">Ordinary struct type</a><a class="headerlink" href="#ordinary-struct-type" title="Permalink to this headline">¶</a></h3>
<p>The following code in Chapter9_1/ and Chapter3_4/ support the ordinary
structure type in function call.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerFormalArguments - transform physical registers into virtual registers</span>
<span class="c1">/// and generate load operations for arguments places on the stack.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The cpu0 ABIs for returning structs by value requires that we copy</span>
    <span class="c1">// the sret argument into $v0 for the return. Save the argument into</span>
    <span class="c1">// a virtual register so that we can access it from the return points.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Ins</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">.</span><span class="n">isSRet</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getSRetReturnReg</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Reg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">createVirtualRegister</span><span class="p">(</span>
            <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>
        <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setSRetReturnReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">SDValue</span> <span class="n">Copy</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">InVals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Copy</span><span class="p">,</span> <span class="n">Chain</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                                <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// The cpu0 ABIs for returning structs by value requires that we copy</span>
  <span class="c1">// the sret argument into $v0 for the return. We saved the argument into</span>
  <span class="c1">// a virtual register in the entry block, so now we copy the value out</span>
  <span class="c1">// and into $v0.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasStructRetAttr</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getSRetReturnReg</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span>
      <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;sret virtual register not created in the entry block&quot;</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">Val</span> <span class="o">=</span>
        <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()));</span>
    <span class="kt">unsigned</span> <span class="n">V0</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">;</span>

    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">V0</span><span class="p">,</span> <span class="n">Val</span><span class="p">,</span> <span class="n">Flag</span><span class="p">);</span>
    <span class="n">Flag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">RetOps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">V0</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">())));</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p>In addition to above code, we had defined the calling convention in early
chapter as follows,</p>
<p class="rubric">lbdex/chapters/Chapter3_4/Cpu0CallingConv.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">RetCC_Cpu0EABI</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="c1">// i32 are returned in registers V0, V1, A0, A1</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="n">CCAssignToReg</span><span class="o">&lt;</span><span class="p">[</span><span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">]</span><span class="o">&gt;&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>It meaning for the return value, we keep it in registers V0, V1, A0, A1 if the return
value didn&#8217;t over 4 registers size; If it over 4 registers size, cpu0 will save
them with pointer.
For explanation, let&#8217;s run Chapter9_2/ with ch9_1_struct.cpp and explain with this
example.</p>
<p class="rubric">lbdex/input/ch9_1_struct.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">struct</span> <span class="n">Date</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">month</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">day</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">hour</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minute</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">second</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">Date</span> <span class="n">gDate</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">Time</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">hour</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minute</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">second</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">Time</span> <span class="n">gTime</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>

<span class="k">static</span> <span class="n">Date</span> <span class="nf">getDate</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="n">gDate</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Date</span> <span class="nf">copyDate</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="n">date</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Date</span> <span class="nf">copyDate</span><span class="p">(</span><span class="n">Date</span><span class="o">*</span> <span class="n">date</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="o">*</span><span class="n">date</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Time</span> <span class="nf">copyTime</span><span class="p">(</span><span class="n">Time</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="n">time</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">Time</span> <span class="nf">copyTime</span><span class="p">(</span><span class="n">Time</span><span class="o">*</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="o">*</span><span class="n">time</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_func_arg_struct</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Time</span> <span class="n">time1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>
  <span class="n">Date</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">getDate</span><span class="p">();</span>
  <span class="n">Date</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">copyDate</span><span class="p">(</span><span class="n">date1</span><span class="p">);</span>
  <span class="n">Date</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">copyDate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">date1</span><span class="p">);</span>
  <span class="n">Time</span> <span class="n">time2</span> <span class="o">=</span> <span class="n">copyTime</span><span class="p">(</span><span class="n">time1</span><span class="p">);</span>
  <span class="n">Time</span> <span class="n">time3</span> <span class="o">=</span> <span class="n">copyTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">date1</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">2012</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">month</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">day</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">hour</span> 
      <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">date2</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">2012</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">month</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">day</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">hour</span> 
      <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time2</span><span class="p">.</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">time2</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">time2</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">12</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">time3</span><span class="p">.</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">time3</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">time3</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">12</span><span class="p">))</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

<span class="cp">#ifdef PRINT_TEST</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;date1 = %d %d %d %d %d %d&quot;</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">year</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">month</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">day</span><span class="p">,</span>
    <span class="n">date1</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">second</span><span class="p">);</span> <span class="c1">// date1 = 2012 10 12 1 2 3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">date1</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">2012</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">month</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">day</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">hour</span> 
      <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;date2 = %d %d %d %d %d %d&quot;</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">year</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">month</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">day</span><span class="p">,</span>
    <span class="n">date2</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">second</span><span class="p">);</span> <span class="c1">// date2 = 2012 10 12 1 2 3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">date2</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">2012</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">month</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">day</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">hour</span> 
      <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="c1">// time2 = 1 10 12</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;time2 = %d %d %d&quot;</span><span class="p">,</span> <span class="n">time2</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">time2</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">time2</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">time2</span><span class="p">.</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">time2</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">time2</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="c1">// time3 = 1 10 12</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;time3 = %d %d %d&quot;</span><span class="p">,</span> <span class="n">time3</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">time3</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">time3</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">time3</span><span class="p">.</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">time3</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">time3</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch9_1_struct.bc -o -
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch9_1_struct.bc&quot;</span>
  .text
  .globl  _Z7getDatev
  .align  2
  .type _Z7getDatev,@function
  .ent  _Z7getDatev             <span class="c"># @_Z7getDatev</span>
_Z7getDatev:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
        lui   <span class="nv">$2</span>, %got_hi<span class="o">(</span>gDate<span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$gp</span>
        ld    <span class="nv">$3</span>, %got_lo<span class="o">(</span>gDate<span class="o">)(</span><span class="nv">$2</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>        // save gDate contents to 212..192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z7getDatev
<span class="nv">$tmp0</span>:
  .size _Z7getDatev, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z7getDatev
  .cfi_endproc
  ...
  .globl  _Z20test_func_arg_structv
  .align  2
  .type _Z20test_func_arg_structv,@function
  .ent  _Z20test_func_arg_structv                    <span class="c"># @main</span>
_Z20test_func_arg_structv:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,248,<span class="nv">$lr</span>
  .mask   0x00004180,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
  <span class="c"># BB#0:</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -200
        st    <span class="nv">$lr</span>, 196<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>           <span class="c"># 4-byte Folded Spill</span>
        st    <span class="nv">$8</span>, 192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
        ld    <span class="nv">$2</span>, %got<span class="o">(</span><span class="nv">$_ZZ20test_func_arg_structvE5time1</span><span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
        ori   <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span><span class="nv">$_ZZ20test_func_arg_structvE5time1</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$3</span>, 184<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$3</span>, 180<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 176<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        addiu <span class="nv">$8</span>, <span class="nv">$sp</span>, 152
        st    <span class="nv">$8</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z7getDatev<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span> // copy gDate contents to date1, 176..152<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        jalr  <span class="nv">$t9</span>
        nop
        ld    <span class="nv">$gp</span>, 176<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 172<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 124<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 168<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 120<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 164<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 116<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 160<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 112<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 156<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 108<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 152<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 104<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ...
</pre></div>
</div>
<p>The ch9_1_constructor.cpp include C++ class &#8220;Date&#8221; implementation.
It can be translated into cpu0 backend too since the front end (clang in this
example) translate them into C language form.
If you mark the &#8220;if hasStructRetAttr()&#8221; part from both of above functions,
the output cpu0 code for ch9_1_struct.cpp will use $3 instead of $2 as return
register as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>        .text
        .section .mdebug.abiS32
        .previous
        .file <span class="s2">&quot;ch9_1_struct.bc&quot;</span>
        .globl        _Z7getDatev
        .align        2
        .type _Z7getDatev,@function
        .ent  _Z7getDatev             <span class="c"># @_Z7getDatev</span>
_Z7getDatev:
        .frame        <span class="nv">$fp</span>,0,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .cpload       <span class="nv">$t9</span>
        .set  nomacro
<span class="c"># BB#0:</span>
        lui   <span class="nv">$2</span>, %got_hi<span class="o">(</span>gDate<span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$gp</span>
        ld    <span class="nv">$2</span>, %got_lo<span class="o">(</span>gDate<span class="o">)(</span><span class="nv">$2</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
        ret   <span class="nv">$lr</span>
        nop
  ...
</pre></div>
</div>
<p>Mips ABI ask return struct varaible address at $2.</p>
</div>
<div class="section" id="byval-struct-type">
<h3><a class="toc-backref" href="#id23">byval struct type</a><a class="headerlink" href="#byval-struct-type" title="Permalink to this headline">¶</a></h3>
<p>The following code in Chapter9_1/ and Chapter9_2/ support the byval structure
type in function call.</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">copyByValRegs</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span>
              <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="k">const</span> <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span>
              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">,</span> <span class="k">const</span> <span class="n">Argument</span> <span class="o">*</span><span class="n">FuncArg</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="k">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">RegAreaSize</span> <span class="o">=</span> <span class="n">ByVal</span><span class="p">.</span><span class="n">NumRegs</span> <span class="o">*</span> <span class="n">CC</span><span class="p">.</span><span class="n">regSize</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">FrameObjSize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">(),</span> <span class="n">RegAreaSize</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">FrameObjOffset</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">ByValArgRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="p">.</span><span class="n">intArgRegs</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">RegAreaSize</span><span class="p">)</span>
    <span class="n">FrameObjOffset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">CC</span><span class="p">.</span><span class="n">reservedArgArea</span><span class="p">()</span> <span class="o">-</span>
      <span class="p">(</span><span class="kt">int</span><span class="p">)((</span><span class="n">CC</span><span class="p">.</span><span class="n">numIntArgRegs</span><span class="p">()</span> <span class="o">-</span> <span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span><span class="p">)</span> <span class="o">*</span> <span class="n">CC</span><span class="p">.</span><span class="n">regSize</span><span class="p">());</span>
  <span class="k">else</span>
    <span class="n">FrameObjOffset</span> <span class="o">=</span> <span class="n">ByVal</span><span class="p">.</span><span class="n">Address</span><span class="p">;</span>

  <span class="c1">// Create frame object.</span>
  <span class="n">EVT</span> <span class="n">PtrTy</span> <span class="o">=</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">FrameObjSize</span><span class="p">,</span> <span class="n">FrameObjOffset</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FIN</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">);</span>
  <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">FIN</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ByVal</span><span class="p">.</span><span class="n">NumRegs</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Copy arg registers.</span>
  <span class="n">MVT</span> <span class="n">RegTy</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">CC</span><span class="p">.</span><span class="n">regSize</span><span class="p">()</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">RegTy</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">ByVal</span><span class="p">.</span><span class="n">NumRegs</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">ArgReg</span> <span class="o">=</span> <span class="n">ByValArgRegs</span><span class="p">[</span><span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span> <span class="o">+</span> <span class="n">I</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="n">VReg</span> <span class="o">=</span> <span class="n">addLiveIn</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">ArgReg</span><span class="p">,</span> <span class="n">RC</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">I</span> <span class="o">*</span> <span class="n">CC</span><span class="p">.</span><span class="n">regSize</span><span class="p">();</span>
    <span class="n">SDValue</span> <span class="n">StorePtr</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">FIN</span><span class="p">,</span>
                                   <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">Offset</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
    <span class="n">SDValue</span> <span class="n">Store</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">VReg</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">),</span>
                                 <span class="n">StorePtr</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">FuncArg</span><span class="p">,</span> <span class="n">Offset</span><span class="p">),</span>
                                 <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">OutChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Store</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerFormalArguments - transform physical registers into virtual registers</span>
<span class="c1">/// and generate load operations for arguments places on the stack.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">ByValArg</span> <span class="o">!=</span> <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">byval_end</span><span class="p">());</span>
      <span class="n">copyByValRegs</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">OutChains</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Flags</span><span class="p">,</span> <span class="n">InVals</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">FuncArg</span><span class="p">,</span>
                    <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">ByValArg</span><span class="p">);</span>
      <span class="o">++</span><span class="n">ByValArg</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="p">...</span>
<span class="p">.</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// The cpu0 ABIs for returning structs by value requires that we copy</span>
    <span class="c1">// the sret argument into $v0 for the return. Save the argument into</span>
    <span class="c1">// a virtual register so that we can access it from the return points.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Ins</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">.</span><span class="n">isSRet</span><span class="p">())</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getSRetReturnReg</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Reg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">createVirtualRegister</span><span class="p">(</span>
            <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>
        <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setSRetReturnReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">SDValue</span> <span class="n">Copy</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">InVals</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Copy</span><span class="p">,</span> <span class="n">Chain</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Copy byVal arg to registers and stack.</span>
<span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">passByValArg</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span>
             <span class="n">std</span><span class="o">::</span><span class="n">deque</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">RegsToPass</span><span class="p">,</span>
             <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">MemOpChains</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">StackPtr</span><span class="p">,</span>
             <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="k">const</span> <span class="n">ByValArgInfo</span> <span class="o">&amp;</span><span class="n">ByVal</span><span class="p">,</span>
             <span class="k">const</span> <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="o">&amp;</span><span class="n">Flags</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">ByValSizeInBytes</span> <span class="o">=</span> <span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">OffsetInBytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// From beginning of struct</span>
  <span class="kt">unsigned</span> <span class="n">RegSizeInBytes</span> <span class="o">=</span> <span class="n">CC</span><span class="p">.</span><span class="n">regSize</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">Alignment</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValAlign</span><span class="p">(),</span> <span class="n">RegSizeInBytes</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">PtrTy</span> <span class="o">=</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()),</span>
      <span class="n">RegTy</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">RegSizeInBytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ByVal</span><span class="p">.</span><span class="n">NumRegs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">ArgRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="p">.</span><span class="n">intArgRegs</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">LeftoverBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">ByVal</span><span class="p">.</span><span class="n">NumRegs</span> <span class="o">*</span> <span class="n">RegSizeInBytes</span> <span class="o">&gt;</span> <span class="n">ByValSizeInBytes</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// Copy words to registers.</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">ByVal</span><span class="p">.</span><span class="n">NumRegs</span> <span class="o">-</span> <span class="n">LeftoverBytes</span><span class="p">;</span>
         <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="n">OffsetInBytes</span> <span class="o">+=</span> <span class="n">RegSizeInBytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SDValue</span> <span class="n">LoadPtr</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                                    <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
      <span class="n">SDValue</span> <span class="n">LoadVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">RegTy</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">LoadPtr</span><span class="p">,</span>
                                    <span class="n">MachinePointerInfo</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
                                    <span class="n">Alignment</span><span class="p">);</span>
      <span class="n">MemOpChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LoadVal</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
      <span class="kt">unsigned</span> <span class="n">ArgReg</span> <span class="o">=</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span> <span class="o">+</span> <span class="n">I</span><span class="p">];</span>
      <span class="n">RegsToPass</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">ArgReg</span><span class="p">,</span> <span class="n">LoadVal</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="c1">// Return if the struct has been fully copied.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ByValSizeInBytes</span> <span class="o">==</span> <span class="n">OffsetInBytes</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="c1">// Copy the remainder of the byval argument with sub-word loads and shifts.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LeftoverBytes</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">((</span><span class="n">ByValSizeInBytes</span> <span class="o">&gt;</span> <span class="n">OffsetInBytes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="p">(</span><span class="n">ByValSizeInBytes</span> <span class="o">&lt;</span> <span class="n">OffsetInBytes</span> <span class="o">+</span> <span class="n">RegSizeInBytes</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;Size of the remainder should be smaller than RegSizeInBytes.&quot;</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">Val</span><span class="p">;</span>

      <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">LoadSizeInBytes</span> <span class="o">=</span> <span class="n">RegSizeInBytes</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">TotalBytesLoaded</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
           <span class="n">OffsetInBytes</span> <span class="o">&lt;</span> <span class="n">ByValSizeInBytes</span><span class="p">;</span> <span class="n">LoadSizeInBytes</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">RemainingSizeInBytes</span> <span class="o">=</span> <span class="n">ByValSizeInBytes</span> <span class="o">-</span> <span class="n">OffsetInBytes</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">RemainingSizeInBytes</span> <span class="o">&lt;</span> <span class="n">LoadSizeInBytes</span><span class="p">)</span>
          <span class="k">continue</span><span class="p">;</span>

        <span class="c1">// Load subword.</span>
        <span class="n">SDValue</span> <span class="n">LoadPtr</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                                      <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
        <span class="n">SDValue</span> <span class="n">LoadVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getExtLoad</span><span class="p">(</span>
            <span class="n">ISD</span><span class="o">::</span><span class="n">ZEXTLOAD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">LoadPtr</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="p">(),</span>
            <span class="n">MVT</span><span class="o">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">LoadSizeInBytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">),</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
            <span class="n">Alignment</span><span class="p">);</span>
        <span class="n">MemOpChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">LoadVal</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

        <span class="c1">// Shift the loaded value.</span>
        <span class="kt">unsigned</span> <span class="n">Shamt</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">isLittle</span><span class="p">)</span>
          <span class="n">Shamt</span> <span class="o">=</span> <span class="n">TotalBytesLoaded</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
        <span class="k">else</span>
          <span class="n">Shamt</span> <span class="o">=</span> <span class="p">(</span><span class="n">RegSizeInBytes</span> <span class="o">-</span> <span class="p">(</span><span class="n">TotalBytesLoaded</span> <span class="o">+</span> <span class="n">LoadSizeInBytes</span><span class="p">))</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>

        <span class="n">SDValue</span> <span class="n">Shift</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SHL</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">LoadVal</span><span class="p">,</span>
                                    <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">Shamt</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">Val</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span>
          <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">OR</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">,</span> <span class="n">Val</span><span class="p">,</span> <span class="n">Shift</span><span class="p">);</span>
        <span class="k">else</span>
          <span class="n">Val</span> <span class="o">=</span> <span class="n">Shift</span><span class="p">;</span>

        <span class="n">OffsetInBytes</span> <span class="o">+=</span> <span class="n">LoadSizeInBytes</span><span class="p">;</span>
        <span class="n">TotalBytesLoaded</span> <span class="o">+=</span> <span class="n">LoadSizeInBytes</span><span class="p">;</span>
        <span class="n">Alignment</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">Alignment</span><span class="p">,</span> <span class="n">LoadSizeInBytes</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="kt">unsigned</span> <span class="n">ArgReg</span> <span class="o">=</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">ByVal</span><span class="p">.</span><span class="n">FirstIdx</span> <span class="o">+</span> <span class="n">I</span><span class="p">];</span>
      <span class="n">RegsToPass</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">ArgReg</span><span class="p">,</span> <span class="n">Val</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Copy remainder of byval arg to it with memcpy.</span>
  <span class="kt">unsigned</span> <span class="n">MemCpySize</span> <span class="o">=</span> <span class="n">ByValSizeInBytes</span> <span class="o">-</span> <span class="n">OffsetInBytes</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">Src</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                            <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">OffsetInBytes</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">Dst</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">,</span> <span class="n">StackPtr</span><span class="p">,</span>
                            <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">ByVal</span><span class="p">.</span><span class="n">Address</span><span class="p">,</span> <span class="n">DL</span><span class="p">));</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMemcpy</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Dst</span><span class="p">,</span> <span class="n">Src</span><span class="p">,</span>
                        <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">MemCpySize</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">PtrTy</span><span class="p">),</span>
                        <span class="n">Alignment</span><span class="p">,</span> <span class="cm">/*isVolatile=*/</span><span class="nb">false</span><span class="p">,</span> <span class="cm">/*AlwaysInline=*/</span><span class="nb">false</span><span class="p">,</span>
                        <span class="cm">/*isTailCall=*/</span><span class="nb">false</span><span class="p">,</span>
                        <span class="n">MachinePointerInfo</span><span class="p">(),</span> <span class="n">MachinePointerInfo</span><span class="p">());</span>
  <span class="n">MemOpChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerCall - functions arguments are copied from virtual regs to</span>
<span class="c1">/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Walk the register/memloc assignments, inserting copies/loads.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">ByValArg</span> <span class="o">!=</span> <span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">byval_end</span><span class="p">());</span>
      <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="n">IsTailCall</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;Do not tail-call optimize if there is a byval argument.&quot;</span><span class="p">);</span>
      <span class="n">passByValArg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegsToPass</span><span class="p">,</span> <span class="n">MemOpChains</span><span class="p">,</span> <span class="n">StackPtr</span><span class="p">,</span> <span class="n">MFI</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                   <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">ByValArg</span><span class="p">,</span> <span class="n">Flags</span><span class="p">,</span> <span class="n">Subtarget</span><span class="p">.</span><span class="n">isLittle</span><span class="p">());</span>
      <span class="o">++</span><span class="n">ByValArg</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In LowerCall(), Flags.isByVal() will be true if it meets <strong>byval</strong> for struct
type in caller function as follows,</p>
<p class="rubric">lbdex/input/tailcall.ll</p>
<div class="highlight-c++"><pre>define internal fastcc i32 @caller9_1() nounwind noinline {
entry:
  ...
  %call = tail call i32 @callee9(%struct.S* byval @gs1) nounwind
  ret i32 %call
}</pre>
</div>
<p>In LowerFormalArguments(), Flags.isByVal() will be true if it meet <strong>byval</strong>
for in callee function as follows,</p>
<p class="rubric">lbdex/input/tailcall.ll</p>
<div class="highlight-c++"><pre>define i32 @caller12(%struct.S* nocapture byval %a0) nounwind {
entry:
  ...
}</pre>
</div>
<p>At this point, I don&#8217;t know how to create a make clang to generate byval IR with
C language.</p>
</div>
</div>
<div class="section" id="function-call-optiomization">
<h2><a class="toc-backref" href="#id24">Function call optiomization</a><a class="headerlink" href="#function-call-optiomization" title="Permalink to this headline">¶</a></h2>
<div class="section" id="tail-call-optimization">
<h3><a class="toc-backref" href="#id25">Tail call optimization</a><a class="headerlink" href="#tail-call-optimization" title="Permalink to this headline">¶</a></h3>
<p>Tail call optimization is used in some situation of function call. For some
situation, the caller and callee stack can share the same memory stack.
When this situation applied in recursive function call, it often asymptotically
reduces stack space requirements from linear, or O(n), to constant, or O(1)
<a class="footnote-reference" href="#wikitailcall" id="id6">[5]</a>. LLVM IR supports tailcall here <a class="footnote-reference" href="#tailcallopt" id="id7">[6]</a>.</p>
<p>The <strong>tailcall</strong> appeared in Cpu0ISelLowering.cpp and Cpu0InstrInfo.td are used
to make tail call optimization.</p>
<p class="rubric">lbdex/input/ch9_2_tailcall.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">factorial</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">factorial</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_tailcall</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">factorial</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run Chapter9_2/ with ch9_2_tailcall.cpp will get the following result.</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>clang -O1 -target mips-unknown-linux-gnu -c
ch9_2_tailcall.cpp -emit-llvm -o ch9_2_tailcall.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/
llvm-dis ch9_2_tailcall.bc -o -
...
; Function Attrs: nounwind readnone
define i32 @_Z9factoriali<span class="o">(</span>i32 %x<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> icmp sgt i32 %x, 0
  br i1 %1, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse:                                      ; <span class="nv">preds</span> <span class="o">=</span> %tailrecurse, %0
  %x.tr2 <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse <span class="o">]</span>, <span class="o">[</span> %x, %0 <span class="o">]</span>
  %accumulator.tr1 <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>, <span class="o">[</span> 1, %0 <span class="o">]</span>
  %2 <span class="o">=</span> add nsw i32 %x.tr2, -1
  %3 <span class="o">=</span> mul nsw i32 %x.tr2, %accumulator.tr1
  %4 <span class="o">=</span> icmp sgt i32 %2, 0
  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; <span class="nv">preds</span> <span class="o">=</span> %tailrecurse, %0
  %accumulator.tr.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> 1, %0 <span class="o">]</span>, <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>
  ret i32 %accumulator.tr.lcssa
<span class="o">}</span>

; Function Attrs: nounwind readnone
define i32 @_Z13test_tailcalli<span class="o">(</span>i32 %a<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> tail call i32 @_Z9factoriali<span class="o">(</span>i32 %a<span class="o">)</span>
  ret i32 %1
<span class="o">}</span>
...
JonathantekiiMac:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/
llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
-enable-cpu0-tail-calls ch9_2_tailcall.bc -stats -o -
        .text
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;ch9_2_tailcall.bc&quot;</span>
        .globl        _Z9factoriali
        .align        2
        .type _Z9factoriali,@function
        .ent  _Z9factoriali           <span class="c"># @_Z9factoriali</span>
_Z9factoriali:
        .frame        <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
        slt   <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$2</span>
        bne   <span class="nv">$3</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_2</span>
        nop
<span class="nv">$BB0_1</span>:                                 <span class="c"># %tailrecurse</span>
                                        <span class="c"># =&gt;This Inner Loop Header: Depth=1</span>
        mul   <span class="nv">$2</span>, <span class="nv">$4</span>, <span class="nv">$2</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, -1
        addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
        slt   <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        bne   <span class="nv">$3</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_1</span>
        nop
<span class="nv">$BB0_2</span>:                                 <span class="c"># %tailrecurse._crit_edge</span>
        ret   <span class="nv">$lr</span>
        nop
        .set  macro
        .set  reorder
        .end  _Z9factoriali
<span class="nv">$tmp0</span>:
        .size _Z9factoriali, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z9factoriali

        .globl        _Z13test_tailcalli
        .align        2
        .type _Z13test_tailcalli,@function
        .ent  _Z13test_tailcalli      <span class="c"># @_Z13test_tailcalli</span>
_Z13test_tailcalli:
        .frame        <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        jmp   _Z9factoriali
        nop
        .set  macro
        .set  reorder
        .end  _Z13test_tailcalli
<span class="nv">$tmp1</span>:
        .size _Z13test_tailcalli, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z13test_tailcalli


<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
                          ... Statistics Collected ...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>

 ...
 1 cpu0-lower        - Number of tail calls
 ...
</pre></div>
</div>
<p>The tail call optimization is applied in cpu032II only for this example (it uses
&#8220;jmp _Z9factoriali&#8221; instead of &#8220;jsub _Z9factoriali&#8221;).
Tail call share caller and callee stack but cpu032I (pass all arguments in
stack) not satisify the following statement, NextStackOffset &lt;=
FI.getIncomingArgSize() in isEligibleForTailCallOptimization(), and return
false for this function as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0SEISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Cpu0SETargetLowering</span><span class="o">::</span>
<span class="n">isEligibleForTailCallOptimization</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">Cpu0CCInfo</span><span class="p">,</span>
                                  <span class="kt">unsigned</span> <span class="n">NextStackOffset</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">Cpu0FunctionInfo</span><span class="o">&amp;</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">EnableCpu0TailCalls</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// Return false if either the callee or caller has a byval argument.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0CCInfo</span><span class="p">.</span><span class="n">hasByValArg</span><span class="p">()</span> <span class="o">||</span> <span class="n">FI</span><span class="p">.</span><span class="n">hasByvalArg</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="c1">// Return true if the callee&#39;s argument area is no larger than the</span>
  <span class="c1">// caller&#39;s.</span>
  <span class="k">return</span> <span class="n">NextStackOffset</span> <span class="o">&lt;=</span> <span class="n">FI</span><span class="p">.</span><span class="n">getIncomingArgSize</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerCall - functions arguments are copied from virtual regs to</span>
<span class="c1">/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Check if it&#39;s really possible to do a tail call.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="n">IsTailCall</span> <span class="o">=</span>
      <span class="n">isEligibleForTailCallOptimization</span><span class="p">(</span><span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="n">NextStackOffset</span><span class="p">,</span>
                                        <span class="o">*</span><span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsTailCall</span> <span class="o">&amp;&amp;</span> <span class="n">CLI</span><span class="p">.</span><span class="n">CS</span> <span class="o">&amp;&amp;</span> <span class="n">CLI</span><span class="p">.</span><span class="n">CS</span><span class="o">-&gt;</span><span class="n">isMustTailCall</span><span class="p">())</span>
    <span class="n">report_fatal_error</span><span class="p">(</span><span class="s">&quot;failed to perform tail call elimination on a call &quot;</span>
                       <span class="s">&quot;site marked musttail&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="o">++</span><span class="n">NumTailCalls</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCALLSEQ_START</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">NextStackOffsetVal</span><span class="p">,</span> <span class="n">DL</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">IsTailCall</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">TailCall</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Ops</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since tailcall optimization will translate jmp instruction directly instead of
jsub. The callseq_start, callseq_end, and the DAG nodes created in
LowerCallResult() and LowerReturn() are needless. It creates DAGs as
<a class="pageref" href="#funccall-f-outgoing-arg-tailcall">Figure  7</a> for ch9_2_tailcall.cpp as
follows,</p>
<div class="figure align-center" id="funccall-f-outgoing-arg-tailcall">
<a class="reference internal image-reference" href="_images/outgoing-arg-tailcall.png"><img alt="_images/outgoing-arg-tailcall.png" src="_images/outgoing-arg-tailcall.png" style="width: 1019.0px; height: 475.0px;" /></a>
<p class="caption">Figure 7: Outgoing arguments DAGs created for ch9_2_tailcall.cpp</p>
</div>
<p>Finally, listing the DAGs translation of tail call as the following table.</p>
<table border="1" class="docutils">
<caption>the DAGs translation of tail call</caption>
<colgroup>
<col width="49%" />
<col width="29%" />
<col width="22%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">DAG</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Backend lowering</td>
<td>Cpu0ISD::TailCall</td>
<td>LowerCall()</td>
</tr>
<tr class="row-odd"><td>Instruction selection</td>
<td>TAILCALL</td>
<td>note 1</td>
</tr>
<tr class="row-even"><td>Instruction Print</td>
<td>JMP</td>
<td>note 2</td>
</tr>
</tbody>
</table>
<p>note 1: by Cpu0InstrInfo.td as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Tail call</span>
<span class="n">def</span> <span class="n">Cpu0TailCall</span> <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;Cpu0ISD::TailCall&quot;</span><span class="p">,</span> <span class="n">SDT_Cpu0JmpLink</span><span class="p">,</span>
                          <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span> <span class="n">SDNPVariadic</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><pre>def : Pat&lt;(Cpu0TailCall (iPTR tglobaladdr:$dst)),
              (TAILCALL tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0TailCall (iPTR texternalsym:$dst)),
              (TAILCALL texternalsym:$dst)&gt;;
</pre>
</div>
<p>note 2: by Cpu0InstrInfo.td and emitPseudoExpansionLowering() of
Cpu0AsmPrinter.cpp as follows,</p>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>let isCall = 1, isTerminator = 1, isReturn = 1, isBarrier = 1, hasDelaySlot = 1,
    hasExtraSrcRegAllocReq = 1, Defs = [AT] in {
  class TailCall&lt;Instruction JumpInst&gt; :
    PseudoSE&lt;(outs), (ins calltarget:$target), [], IIBranch&gt;,
    PseudoInstExpansion&lt;(JumpInst jmptarget:$target)&gt;;

  class TailCallReg&lt;RegisterClass RO, Instruction JRInst,
                    RegisterClass ResRO = RO&gt; :
    PseudoSE&lt;(outs), (ins RO:$rs), [(Cpu0TailCall RO:$rs)], IIBranch&gt;,
    PseudoInstExpansion&lt;(JRInst ResRO:$rs)&gt;;
}
</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">Predicates</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ch9_1</span><span class="p">]</span> <span class="n">in</span> <span class="p">{</span>
<span class="n">def</span> <span class="n">TAILCALL</span> <span class="o">:</span> <span class="n">TailCall</span><span class="o">&lt;</span><span class="n">JMP</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">TAILCALL_R</span> <span class="o">:</span> <span class="n">TailCallReg</span><span class="o">&lt;</span><span class="n">GPROut</span><span class="p">,</span> <span class="n">JR</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0AsmPrinter.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// tblgen&#39;erated function.</span>
  <span class="kt">bool</span> <span class="nf">emitPseudoExpansionLowering</span><span class="p">(</span><span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">OutStreamer</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_1/Cpu0AsmPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- EmitInstruction() must exists or will have run time error.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//@EmitInstruction body {</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">isDebugValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">Str</span><span class="p">;</span>
    <span class="n">raw_svector_ostream</span> <span class="nf">OS</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>

    <span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">OS</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//@print out instruction:</span>
  <span class="c1">//  Print out both ordinary instruction and boudle instruction</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">const_instr_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MI</span><span class="p">;</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">const_instr_iterator</span> <span class="n">E</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">instr_end</span><span class="p">();</span>

  <span class="k">do</span> <span class="p">{</span>
    <span class="c1">// Do any auto-generated pseudo lowerings.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">emitPseudoExpansionLowering</span><span class="p">(</span><span class="o">*</span><span class="n">OutStreamer</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">I</span><span class="p">))</span>
      <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">isPseudo</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isLongBranchPseudo</span><span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()))</span>
      <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Pseudo opcode found in EmitInstruction()&quot;</span><span class="p">);</span>

    <span class="n">MCInst</span> <span class="n">TmpInst0</span><span class="p">;</span>
    <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">TmpInst0</span><span class="p">);</span>
    <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">TmpInst0</span><span class="p">,</span> <span class="n">getSubtargetInfo</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="o">++</span><span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">isInsideBundle</span><span class="p">());</span> <span class="c1">// Delay slot check</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Function emitPseudoExpansionLowering() is generated by TableGen and exists
in Cpu0GenMCPseudoLowering.inc.</p>
</div>
<div class="section" id="recursion-optimization">
<h3><a class="toc-backref" href="#id26">Recursion optimization</a><a class="headerlink" href="#recursion-optimization" title="Permalink to this headline">¶</a></h3>
<p>As last section, cpu032I cannot do tail call optimization in
ch9_2_tailcall.cpp since the limitation of arguments size is not satisfied.
If run with <tt class="docutils literal"><span class="pre">clang</span> <span class="pre">-O3</span></tt> option, it can get the same or better performance
than tail call as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>clang -O1 -target mips-unknown-linux-gnu -c
ch9_2_tailcall.cpp -emit-llvm -o ch9_2_tailcall.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/
llvm-dis ch9_2_tailcall.bc -o -
...
; Function Attrs: nounwind readnone
define i32 @_Z9factoriali<span class="o">(</span>i32 %x<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> icmp sgt i32 %x, 0
  br i1 %1, label %tailrecurse.preheader, label %tailrecurse._crit_edge

tailrecurse.preheader:                            ; <span class="nv">preds</span> <span class="o">=</span> %0
  br label %tailrecurse

tailrecurse:                                      ; <span class="nv">preds</span> <span class="o">=</span> %tailrecurse,
%tailrecurse.preheader
  %x.tr2 <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse <span class="o">]</span>, <span class="o">[</span> %x, %tailrecurse.preheader <span class="o">]</span>
  %accumulator.tr1 <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>, <span class="o">[</span> 1, %tailrecurse.preheader <span class="o">]</span>
  %2 <span class="o">=</span> add nsw i32 %x.tr2, -1
  %3 <span class="o">=</span> mul nsw i32 %x.tr2, %accumulator.tr1
  %4 <span class="o">=</span> icmp sgt i32 %2, 0
  br i1 %4, label %tailrecurse, label %tailrecurse._crit_edge.loopexit

tailrecurse._crit_edge.loopexit:                  ; <span class="nv">preds</span> <span class="o">=</span> %tailrecurse
  %.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse <span class="o">]</span>
  br label %tailrecurse._crit_edge

tailrecurse._crit_edge:                           ; <span class="nv">preds</span> <span class="o">=</span> %tailrecurse._crit
  _edge.loopexit, %0
  %accumulator.tr.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> 1, %0 <span class="o">]</span>, <span class="o">[</span> %.lcssa, %tailrecurse._crit_edge
  .loopexit <span class="o">]</span>
  ret i32 %accumulator.tr.lcssa
<span class="o">}</span>

; Function Attrs: nounwind readnone
define i32 @_Z13test_tailcalli<span class="o">(</span>i32 %a<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> icmp sgt i32 %a, 0
  br i1 %1, label %tailrecurse.i.preheader, label %_Z9factoriali.exit

tailrecurse.i.preheader:                          ; <span class="nv">preds</span> <span class="o">=</span> %0
  br label %tailrecurse.i

tailrecurse.i:                                    ; <span class="nv">preds</span> <span class="o">=</span> %tailrecurse.i,
  %tailrecurse.i.preheader
  %x.tr2.i <span class="o">=</span> phi i32 <span class="o">[</span> %2, %tailrecurse.i <span class="o">]</span>, <span class="o">[</span> %a, %tailrecurse.i.preheader <span class="o">]</span>
  %accumulator.tr1.i <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse.i <span class="o">]</span>, <span class="o">[</span> 1, %tailrecurse.i.
  preheader <span class="o">]</span>
  %2 <span class="o">=</span> add nsw i32 %x.tr2.i, -1
  %3 <span class="o">=</span> mul nsw i32 %accumulator.tr1.i, %x.tr2.i
  %4 <span class="o">=</span> icmp sgt i32 %2, 0
  br i1 %4, label %tailrecurse.i, label %_Z9factoriali.exit.loopexit

_Z9factoriali.exit.loopexit:                      ; <span class="nv">preds</span> <span class="o">=</span> %tailrecurse.i
  %.lcssa <span class="o">=</span> phi i32 <span class="o">[</span> %3, %tailrecurse.i <span class="o">]</span>
  br label %_Z9factoriali.exit

_Z9factoriali.exit:                               ; <span class="nv">preds</span> <span class="o">=</span> %_Z9factoriali.
  exit.loopexit, %0
  %accumulator.tr.lcssa.i <span class="o">=</span> phi i32 <span class="o">[</span> 1, %0 <span class="o">]</span>, <span class="o">[</span> %.lcssa, %_Z9factoriali.
  exit.loopexit <span class="o">]</span>
  ret i32 %accumulator.tr.lcssa.i
<span class="o">}</span>
...
JonathantekiiMac:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/
llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch9_2_tailcall.bc -o -
        .text
        .section .mdebug.abiS32
        .previous
        .file <span class="s2">&quot;ch9_2_tailcall.bc&quot;</span>
        .globl        _Z9factoriali
        .align        2
        .type _Z9factoriali,@function
        .ent  _Z9factoriali           <span class="c"># @_Z9factoriali</span>
_Z9factoriali:
        .frame        <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
        ld    <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        cmp   <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        jlt   <span class="nv">$sw</span>, <span class="nv">$BB0_2</span>
        nop
<span class="nv">$BB0_1</span>:                                 <span class="c"># %tailrecurse</span>
                                        <span class="c"># =&gt;This Inner Loop Header: Depth=1</span>
        mul   <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        addiu <span class="nv">$3</span>, <span class="nv">$3</span>, -1
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 0
        cmp   <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        jgt   <span class="nv">$sw</span>, <span class="nv">$BB0_1</span>
        nop
<span class="nv">$BB0_2</span>:                                 <span class="c"># %tailrecurse._crit_edge</span>
        ret   <span class="nv">$lr</span>
        nop
        .set  macro
        .set  reorder
        .end  _Z9factoriali
<span class="nv">$tmp0</span>:
        .size _Z9factoriali, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z9factoriali

        .globl        _Z13test_tailcalli
        .align        2
        .type _Z13test_tailcalli,@function
        .ent  _Z13test_tailcalli      <span class="c"># @_Z13test_tailcalli</span>
_Z13test_tailcalli:
        .frame        <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
        ld    <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
        cmp   <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        jlt   <span class="nv">$sw</span>, <span class="nv">$BB1_2</span>
        nop
<span class="nv">$BB1_1</span>:                                 <span class="c"># %tailrecurse.i</span>
                                        <span class="c"># =&gt;This Inner Loop Header: Depth=1</span>
        mul   <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        addiu <span class="nv">$3</span>, <span class="nv">$3</span>, -1
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 0
        cmp   <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        jgt   <span class="nv">$sw</span>, <span class="nv">$BB1_1</span>
        nop
<span class="nv">$BB1_2</span>:                                 <span class="c"># %_Z9factoriali.exit</span>
        ret   <span class="nv">$lr</span>
        nop
        .set  macro
        .set  reorder
        .end  _Z13test_tailcalli
<span class="nv">$tmp1</span>:
        .size _Z13test_tailcalli, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z13test_tailcalli
</pre></div>
</div>
<p>According above llvm IR, <tt class="docutils literal"><span class="pre">clang</span> <span class="pre">-O3</span></tt> option remove recursion to loop by
inline the callee recursion function. This is a front end optimization through
cross over function analysis.</p>
<p>Cpu0 doesn&#8217;t support fastcc <a class="footnote-reference" href="#callconv" id="id8">[7]</a> but it can pass the fastcc keyword of
IR.
Mips supports fastcc by using as more registers as possible without following
ABI specification.</p>
</div>
</div>
<div class="section" id="other-features-supporting">
<h2><a class="toc-backref" href="#id27">Other features supporting</a><a class="headerlink" href="#other-features-supporting" title="Permalink to this headline">¶</a></h2>
<p>This section support features of $gp register caller saved register in PIC
addressing mode, variable number of arguments and dynamic stack allocation.</p>
<p>Run Chapter9_2/ with ch9_3_vararg.cpp to get the following error,</p>
<p class="rubric">lbdex/input/ch9_3_vararg.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="kt">int</span> <span class="nf">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="kt">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_vararg</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3_vararg.cpp -emit-llvm -o ch9_3_vararg.bc
118-165-78-230:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_3_vararg.bc -o -
...
LLVM ERROR: Cannot <span class="k">select</span>: 0x7f8b6902fd10: <span class="nv">ch</span> <span class="o">=</span> vastart 0x7f8b6902fa10,
0x7f8b6902fb10, 0x7f8b6902fc10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>9<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>22<span class="o">]</span>
  0x7f8b6902fb10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;5&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
In <span class="k">function</span>: _Z5sum_iiz
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_alloc.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// This file needed compile without option, -target mips-unknown-linux-gnu, so </span>
<span class="c1">// it is verified by build-run_backend2.sh or verified in lld linker support</span>
<span class="c1">// (build-slinker.sh).</span>

<span class="c1">//#include &lt;alloca.h&gt;</span>
<span class="c1">//#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">weight_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">//  int *b = (int*)alloca(sizeof(int) * 1 * x1);</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">__builtin_alloca</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">x1</span><span class="p">);</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
  <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">x3</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x5</span><span class="p">,</span> <span class="n">x6</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">weight</span> <span class="o">+</span> <span class="p">(</span><span class="o">*</span><span class="n">a</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_alloc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">weight_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span> <span class="c1">// 31</span>
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run Chapter9_2 with ch9_3_alloc.cpp will get the following error.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-72-242:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3_alloc.cpp -emit-llvm -o ch9_3_alloc.bc
118-165-72-242:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -cpu0-s32-calls<span class="o">=</span><span class="nb">false</span>
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_3_alloc.bc -o -
...
LLVM ERROR: Cannot <span class="k">select</span>: 0x7ffd8b02ff10: i32,ch <span class="o">=</span> dynamic_stackalloc
0x7ffd8b02f910:1, 0x7ffd8b02fe10, 0x7ffd8b02c010 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>48<span class="o">]</span>
  0x7ffd8b02fe10: <span class="nv">i32</span> <span class="o">=</span> and 0x7ffd8b02fc10, 0x7ffd8b02fd10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>47<span class="o">]</span>
    0x7ffd8b02fc10: <span class="nv">i32</span> <span class="o">=</span> add 0x7ffd8b02fa10, 0x7ffd8b02fb10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>46<span class="o">]</span>
      0x7ffd8b02fa10: <span class="nv">i32</span> <span class="o">=</span> shl 0x7ffd8b02f910, 0x7ffd8b02f510 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>45<span class="o">]</span>
        0x7ffd8b02f910: i32,ch <span class="o">=</span> load 0x7ffd8b02ee10, 0x7ffd8b02e310,
        0x7ffd8b02b310&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>44<span class="o">]</span>
          0x7ffd8b02e310: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>10<span class="o">]</span>
          0x7ffd8b02b310: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>2<span class="o">]</span>
        0x7ffd8b02f510: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;2&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>25<span class="o">]</span>
      0x7ffd8b02fb10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;7&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>16<span class="o">]</span>
    0x7ffd8b02fd10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;-8&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>17<span class="o">]</span>
  0x7ffd8b02c010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>8<span class="o">]</span>
In <span class="k">function</span>: _Z5sum_iiiiiii
</pre></div>
</div>
<div class="section" id="the-gp-register-caller-saved-register-in-pic-addressing-mode">
<h3><a class="toc-backref" href="#id28">The $gp register caller saved register in PIC addressing mode</a><a class="headerlink" href="#the-gp-register-caller-saved-register-in-pic-addressing-mode" title="Permalink to this headline">¶</a></h3>
<p>According the original cpu0 web site information, it only supports <strong>“jsub”</strong>
bits address range access.
We add <strong>“jalr”</strong> to cpu0 and expand it to 32 bit address. We did this change for
two reasons. One is cpu0 can be expanded to 32 bit address space by only adding
this instruction.
The other is cpu0 as well as this book are designed for tutorial.
We reserve <strong>“jalr”</strong> as PIC mode for dynamic linking function to demonstrates:</p>
<ol class="arabic simple">
<li>How caller handle the caller saved register $gp in calling the function</li>
<li>How the code in the shared libray function uses $gp to access global variable
address.</li>
<li>The jalr for dynamic linking function is easier in implementation and faster.
As we have depicted in section &#8220;pic mode&#8221; of chapter &#8220;Global variables, structs
and arrays, other type&#8221;. This solution is popular in reality and deserve changing
cpu0 official design as a compiler book.</li>
</ol>
<p>In chapter &#8220;Global variable&#8221;, we mentioned two link
type, the static link and dynamic link.
The option -relocation-model=static is for static link function while option
-relocation-model=pic is for dynamic link function.
One example of dynamic link function is used in share library.
Share library include a lots of dynamic link functions usually can be loaded
at run time.
Since share library can be loaded in different memory address, the global
variable address which it access cannot be decided at link time.
Even so, we still can caculate the distance between the global variable address
and the start address of shared library function when it be loaded.</p>
<p>Let&#8217;s run Chapter9_3/ with ch9_gprestore.cpp to get the following result.
We putting the comments in the result for explanation.</p>
<p class="rubric">lbdex/input/ch9_gprestore.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">call_sum_i</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II-cpu0-s32-calls<span class="o">=</span><span class="nb">true</span>
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_gprestore.bc -o -
...
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:                                 # %entry</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
<span class="nv">$tmp0</span>:
  .cfi_def_cfa_offset 24
  st  <span class="nv">$lr</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$fp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>              <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp1</span>:
  .cfi_offset 14, -4
<span class="nv">$tmp2</span>:
  .cfi_offset 12, -8
  .cprestore  8    // save <span class="nv">$gp</span> to 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_ii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 1
  jalr  <span class="nv">$t9</span>
  nop
  ld  <span class="nv">$gp</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>  // restore <span class="nv">$gp</span> from 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$8</span>, <span class="nv">$zero</span>, <span class="nv">$2</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_ii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 2
  jalr  <span class="nv">$t9</span>
  nop
  ld  <span class="nv">$gp</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>  // restore <span class="nv">$gp</span> from 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$8</span>
  ld  <span class="nv">$8</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>              <span class="c"># 4-byte Folded Reload</span>
  ld  <span class="nv">$lr</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  nop
</pre></div>
</div>
<p>As above code comment, <strong>“.cprestore 8”</strong> is a pseudo instruction for saving
<strong>$gp</strong> to <strong>8($sp)</strong> while Instruction <strong>“ld $gp, 8($sp)”</strong> restore
the $gp, refer to Table 8-1 of &#8220;MIPSpro TM Assembly Language Programmer’s
Guide&#8221; <a class="footnote-reference" href="#mipsasm" id="id9">[2]</a>.
In other word, $gp is a caller saved register, so main() need to save/restore
$gp before/after call the shared library _Z5sum_ii() function.
In llvm Mips 3.5, it removed the .cprestore in mode PIC which meaning $gp
is not a caller saved register in PIC anymore.
However, it is still existed in Cpu0 and this feature can be removed by not
defining it in Cpu0Config.h.
The #ifdef ENABLE_GPRESTORE part of code in Cpu0 can be removed but it come with
the cost of reserve $gp register as a specific register and cannot be allocated
for the program variable in PIC mode. As explained in early chapter Gloabal
variable, the PIC is rare and the performance advantage can be ignored in
dynamic link, so we keep this feature in Cpu0 and provide readers this feature.
Even with this point, I really prefer to reserve $gp as a specific register in
PIC. It will save a lot of trouble in programming.
When reserve $gp, .cpload can be disabled by option &#8220;-cpu0-reserve-gp&#8221;.
The .cpload is need even reserve $gp. Consider prgrammer implement a boot code
function with C and assembly mixed, programmer can set $gp value through .cpload
issue.</p>
<p>If enable &#8220;-cpu0-no-cpload&#8221;, and undefine ENABLE_GPRESTORE or enable
&#8220;-cpu0-reserve-gp&#8221;, .cpload and $gp save/restore won&#8217;t be issue as follow,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II-cpu0-s32-calls<span class="o">=</span><span class="nb">true</span>
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_gprestore.bc -cpu0-no-cpload
-cpu0-reserve-gp -o -
...
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
<span class="nv">$tmp0</span>:
  .cfi_def_cfa_offset 24
  st  <span class="nv">$lr</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$fp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp1</span>:
  .cfi_offset 14, -4
<span class="nv">$tmp2</span>:
  .cfi_offset 12, -8
  move   <span class="nv">$fp</span>, <span class="nv">$sp</span>
<span class="nv">$tmp3</span>:
  .cfi_def_cfa_register 12
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_ii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 1
  jalr  <span class="nv">$t9</span>
  nop
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 2
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_ii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  nop
  ld  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  move   <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$fp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  ld  <span class="nv">$lr</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
  ret <span class="nv">$lr</span>
  nop
</pre></div>
</div>
<p>LLVM Mips 3.1 issues the .cpload and .cprestore and Cpu0 borrows it from that
version. But now, llvm Mips replace .cpload with real instructions and remove
.cprestore. It treats $gp as reserved register in PIC mode. Since the Mips
assembly document I reference say $gp is caller save register, Cpu0 stay and
follow this document at this point and supply reserve $gp register as option.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>mips -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_gprestore.bc
-o -
...
<span class="c"># BB#0:                                 # %entry</span>
  lui <span class="nv">$2</span>, %hi<span class="o">(</span>_gp_disp<span class="o">)</span>
  ori <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>_gp_disp<span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp0</span>:
  .cfi_def_cfa_offset 32
  sw  <span class="nv">$ra</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  sw  <span class="nv">$fp</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  sw  <span class="nv">$16</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp1</span>:
  .cfi_offset 31, -4
<span class="nv">$tmp2</span>:
  .cfi_offset 30, -8
<span class="nv">$tmp3</span>:
  .cfi_offset 16, -12
  move   <span class="nv">$fp</span>, <span class="nv">$sp</span>
<span class="nv">$tmp4</span>:
  .cfi_def_cfa_register 30
  addu  <span class="nv">$16</span>, <span class="nv">$2</span>, <span class="nv">$25</span>
  lw  <span class="nv">$25</span>, %call16<span class="o">(</span>_Z5sum_ii<span class="o">)(</span><span class="nv">$16</span><span class="o">)</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 1
  jalr  <span class="nv">$25</span>
  move   <span class="nv">$gp</span>, <span class="nv">$16</span>
  sw  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  lw  <span class="nv">$25</span>, %call16<span class="o">(</span>_Z5sum_ii<span class="o">)(</span><span class="nv">$16</span><span class="o">)</span>
  jalr  <span class="nv">$25</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 2
  lw  <span class="nv">$1</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$1</span>, <span class="nv">$2</span>
  sw  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  move   <span class="nv">$sp</span>, <span class="nv">$fp</span>
  lw  <span class="nv">$16</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  lw  <span class="nv">$fp</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  lw  <span class="nv">$ra</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  jr  <span class="nv">$ra</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
</pre></div>
</div>
<p>The following code added in Chapter9_3/ to issue <strong>“.cprestore”</strong> or the
corresponding machine code before the first time of PIC function call.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerCall - functions arguments are copied from virtual regs to</span>
<span class="c1">/// (physical regs)/(stack frame), CALLSEQ_START and CALLSEQ_END are emitted.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Cpu0ReserveGP</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// If this is the first call, create a stack frame object that points to</span>
    <span class="c1">// a location to which .cprestore saves $gp.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsPIC</span> <span class="o">&amp;&amp;</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegFixed</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">())</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setGPFI</span><span class="p">(</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">needGPSaveRestore</span><span class="p">())</span>
      <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setObjectOffset</span><span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">(),</span> <span class="n">NextStackOffset</span><span class="p">);</span>
  <span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
  <span class="kt">bool</span> <span class="nf">needGPSaveRestore</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">getGPFI</span><span class="p">();</span> <span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
  <span class="c1">// Restore GP from the saved stack location</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">needGPSaveRestore</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">());</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPRESTORE</span><span class="p">)).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">)</span>
      <span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- If no eliminateFrameIndex(), it will hang on run. </span>
<span class="c1">// pure virtual method</span>
<span class="c1">// FrameIndex represent objects inside a abstract stack.</span>
<span class="c1">// We must replace FrameIndex with an stack/frame pointer</span>
<span class="c1">// direct reference.</span>
<span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="cp">#if CH &gt;= CH3_5</span>
  <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span> <span class="o">=</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="o">*</span><span class="n">MI</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">isFI</span><span class="p">())</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="p">.</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="s">&quot;Instr doesn&#39;t have FrameIndex operand!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Function : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MI</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">FrameIndex</span> <span class="o">=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">getIndex</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>
  <span class="kt">int64_t</span> <span class="n">spOffset</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">);</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FrameIndex : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">FrameIndex</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;spOffset   : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">spOffset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;stackSize  : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">stackSize</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">MinCSFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">MinCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
    <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// The following stack frame objects are always referenced relative to $sp:</span>
  <span class="c1">//  1. Outgoing arguments.</span>
  <span class="c1">//  2. Pointer to dynamically allocated stack space.</span>
  <span class="c1">//  3. Locations for callee-saved registers.</span>
  <span class="c1">// Everything else is referenced relative to whatever register</span>
  <span class="c1">// getFrameRegister() returns.</span>
  <span class="kt">unsigned</span> <span class="n">FrameReg</span><span class="p">;</span>

<span class="cp">#if CH &gt;= CH9_3 </span><span class="c1">//3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">FrameIndex</span> <span class="o">&gt;=</span> <span class="n">MinCSFI</span> <span class="o">&amp;&amp;</span> <span class="n">FrameIndex</span> <span class="o">&lt;=</span> <span class="n">MaxCSFI</span><span class="p">))</span>
    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>
<span class="cp">#else</span>
  <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">//#if CH &gt;= CH9_3 //3</span>

  <span class="c1">// Calculate final offset.</span>
  <span class="c1">// - There is no need to change the offset if the frame object is one of the</span>
  <span class="c1">//   following: an outgoing argument, pointer to a dynamically allocated</span>
  <span class="c1">//   stack space or a $gp restore location,</span>
  <span class="c1">// - If the frame object is any of the following, its offset must be adjusted</span>
  <span class="c1">//   by adding the size of the stack:</span>
  <span class="c1">//   incoming argument, callee-saved register location or local variable.</span>
  <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">;</span>
<span class="cp">#if CH &gt;= CH9_3 </span><span class="c1">//1</span>
<span class="cp">#ifdef ENABLE_GPRESTORE </span><span class="c1">//2</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
  <span class="k">else</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="c1">//#if CH &gt;= CH9_3 //1</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">stackSize</span><span class="p">;</span>

  <span class="n">Offset</span>    <span class="o">+=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">();</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Offset     : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// If MI is not a debug value, make sure Offset fits in the 16-bit immediate</span>
  <span class="c1">// field.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">isDebugValue</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">assert</span><span class="p">(</span><span class="s">&quot;(!MI.isDebugValue() &amp;&amp; !isInt&lt;16&gt;(Offset))&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ChangeToRegister</span><span class="p">(</span><span class="n">FrameReg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">ChangeToImmediate</span><span class="p">(</span><span class="n">Offset</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// #if CH &gt;= CH3_5</span>
<span class="p">}</span>
<span class="c1">//}</span>

<span class="kt">bool</span>
<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">requiresRegisterScavenging</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span>
<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">trackLivenessAfterRegAlloc</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="kt">unsigned</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getFrameRegister</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">TFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getSubtarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">TFI</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">)</span> <span class="o">:</span>
                          <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// #if CH &gt;= CH3_1</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE </span><span class="c1">//2</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
  <span class="k">else</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// When handling PIC code the assembler needs .cpload and .cprestore
// directives. If the real instructions corresponding these directives
// are used, we have the same behavior, but get also a bunch of warnings
// from the assembler.
let hasSideEffects = 0 in
def CPRESTORE : Cpu0Pseudo&lt;(outs), (ins i32imm:$loc, CPURegs:$gp),
                           ".cprestore\t$loc", []&gt;;
</pre>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0AsmPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCInst</span> <span class="n">TmpInst</span><span class="p">;</span>

  <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">TmpInst</span><span class="p">);</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">macro&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">at&quot;</span><span class="p">));</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">TmpInst</span><span class="p">,</span> <span class="n">getSubtargetInfo</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">noat&quot;</span><span class="p">));</span>
  <span class="n">OutStreamer</span><span class="o">-&gt;</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">nomacro&quot;</span><span class="p">));</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">emitPseudoCPRestore</span><span class="p">(</span><span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">OutStreamer</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MCInsts</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;CPRESTORE&#39;s operand must be an immediate.&quot;</span><span class="p">);</span>
  <span class="kt">int64_t</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// output assembly</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="n">MI</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">MCInst</span> <span class="n">TmpInst0</span><span class="p">;</span>
    <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">TmpInst0</span><span class="p">);</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">TmpInst0</span><span class="p">,</span> <span class="n">getSubtargetInfo</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// output elf</span>
    <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">LowerCPRESTORE</span><span class="p">(</span><span class="n">Offset</span><span class="p">,</span> <span class="n">MCInsts</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MCInsts</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
         <span class="n">I</span> <span class="o">!=</span> <span class="n">MCInsts</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
      <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="o">*</span><span class="n">I</span><span class="p">,</span> <span class="n">getSubtargetInfo</span><span class="p">());</span>

    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- EmitInstruction() must exists or will have run time error.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">CPRESTORE</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">emitPseudoCPRestore</span><span class="p">(</span><span class="o">*</span><span class="n">OutStreamer</span><span class="p">,</span> <span class="o">&amp;*</span><span class="n">I</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MCInstLower.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
  <span class="kt">void</span> <span class="nf">LowerCPRESTORE</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">MCInsts</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
<span class="c1">// Lower &quot;.cprestore offset&quot; to &quot;st $gp, offset($sp)&quot;.</span>
<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerCPRESTORE</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">,</span>
                                     <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">MCInsts</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Imm operand of .cprestore must be a non-negative 32-bit value.&quot;</span><span class="p">);</span>

  <span class="n">MCOperand</span> <span class="n">SPReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">),</span> <span class="n">BaseReg</span> <span class="o">=</span> <span class="n">SPReg</span><span class="p">;</span>
  <span class="n">MCOperand</span> <span class="n">GPReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="n">MCOperand</span> <span class="n">ZEROReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Hi</span> <span class="o">=</span> <span class="p">((</span><span class="n">Offset</span> <span class="o">+</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="n">Offset</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="n">MCOperand</span> <span class="n">ATReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">createReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">);</span>
    <span class="n">BaseReg</span> <span class="o">=</span> <span class="n">ATReg</span><span class="p">;</span>

    <span class="c1">// lui   at,hi</span>
    <span class="c1">// add   at,at,sp</span>
    <span class="n">MCInsts</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">,</span> <span class="n">ATReg</span><span class="p">,</span> <span class="n">ZEROReg</span><span class="p">,</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">Hi</span><span class="p">));</span>
    <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">ATReg</span><span class="p">,</span> <span class="n">ATReg</span><span class="p">,</span> <span class="n">SPReg</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MCInst</span> <span class="n">St</span><span class="p">;</span>
  <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">St</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ST</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">BaseReg</span><span class="p">,</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">createImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">));</span>
  <span class="n">MCInsts</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">St</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>The added code of Cpu0AsmPrinter.cpp as above will call the LowerCPRESTORE() when
user run with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-filetype=obj</span></tt>.
The added code of Cpu0MCInstLower.cpp as above takes care the .cprestore machine
instructions.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>
obj ch9_1.bc -o ch9_1.cpu0.o
118-165-76-131:input Jonathan<span class="nv">$ </span>hexdump  ch9_1.cpu0.o
...
// .cprestore machine instruction “ 01 ad 00 18”
00000d0 01 ad 00 18 09 20 00 00 01 2d 00 40 09 20 00 06
...

118-165-67-25:input Jonathan<span class="nv">$ </span>cat ch9_1.cpu0.s
...
  .ent  _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
...
  .cpload <span class="nv">$t9</span> // assign <span class="nv">$gp</span> <span class="o">=</span> <span class="nv">$t9</span> by loader when loader load re-entry <span class="k">function</span>
              // <span class="o">(</span>shared library<span class="o">)</span> of _Z5sum_iiiiiii
  .set  nomacro
<span class="c"># BB#0:</span>
...
  .ent  main                    <span class="c"># @main</span>
...
  .cprestore  24  // save <span class="nv">$gp</span> to 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
...
</pre></div>
</div>
<p>Run <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-static</span></tt> will call jsub instruction instead of jalr as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>
asm ch9_1.bc -o ch9_1.cpu0.s
118-165-76-131:input Jonathan<span class="nv">$ </span>cat ch9_1.cpu0.s
...
  jsub  _Z5sum_iiiiiii
...
</pre></div>
</div>
<p>Run with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-filetype=obj</span></tt>, you can find the Cx of <strong>“jsub Cx”</strong> is 0 since
the Cx is calculated by linker as below.
Mips has the same 0 in it&#8217;s jal instruction.</p>
<div class="highlight-bash"><div class="highlight"><pre>// jsub _Z5sum_iiiiiii translate into 2B 00 00 00
00F0: 2B 00 00 00 01 2D 00 34 00 ED 00 3C 09 DD 00 40
</pre></div>
</div>
<p>The following code will emit &#8220;ld $gp, ($gp save slot on stack)&#8221; after jalr by
create file Cpu0EmitGPRestore.cpp which run as a function pass.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Cpu0EmitGPRestore</span><span class="p">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Cpu0 Code Generator Pass Configuration Options.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
  <span class="kt">void</span> <span class="n">addPreRegAlloc</span><span class="p">()</span> <span class="n">override</span><span class="p">;</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
<span class="kt">void</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addPreRegAlloc</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Cpu0ReserveGP</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// $gp is a caller-saved register.</span>
    <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0EmitGPRestorePass</span><span class="p">(</span><span class="n">getCpu0TargetMachine</span><span class="p">()));</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifdef ENABLE_GPRESTORE</span>
  <span class="n">FunctionPass</span> <span class="o">*</span><span class="nf">createCpu0EmitGPRestorePass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0EmitGPRestore.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0EmitGPRestore.cpp - Emit GP Restore Instruction ---------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This pass emits instructions that restore $gp right</span>
<span class="c1">// after jalr instructions.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#if CH &gt;= CH9_3</span>
<span class="cp">#ifdef ENABLE_GPRESTORE</span>

<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Statistic.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="cp">#define DEBUG_TYPE &quot;emit-gp-restore&quot;</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Inserter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionPass</span> <span class="p">{</span>

    <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
    <span class="n">Inserter</span><span class="p">(</span><span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">MachineFunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">),</span> <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getPassName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;Cpu0 Emit GP Restore&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="kt">char</span> <span class="n">Inserter</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// end of anonymous namespace</span>

<span class="kt">bool</span> <span class="n">Inserter</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">TargetSubtargetInfo</span> <span class="o">*</span><span class="n">STI</span> <span class="o">=</span>  <span class="n">TM</span><span class="p">.</span><span class="n">getSubtargetImpl</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">F</span><span class="p">.</span><span class="n">getFunction</span><span class="p">()));</span>
  <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">*</span><span class="n">TII</span> <span class="o">=</span> <span class="n">STI</span><span class="o">-&gt;</span><span class="n">getInstrInfo</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">TM</span><span class="p">.</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="o">!</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegFixed</span><span class="p">()))</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">MachineFunction</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MFI</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">MFE</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
       <span class="n">MFI</span> <span class="o">!=</span> <span class="n">MFE</span><span class="p">;</span> <span class="o">++</span><span class="n">MFI</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MachineBasicBlock</span><span class="o">&amp;</span> <span class="n">MBB</span> <span class="o">=</span> <span class="o">*</span><span class="n">MFI</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
    
    <span class="c1">/// IsLandingPad - Indicate that this basic block is entered via an</span>
    <span class="c1">/// exception handler.</span>
    <span class="c1">// If MBB is a landing pad, insert instruction that restores $gp after</span>
    <span class="c1">// EH_LABEL.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MBB</span><span class="p">.</span><span class="n">isLandingPad</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// Find EH_LABEL first.</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">TargetOpcode</span><span class="o">::</span><span class="n">EH_LABEL</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">;</span>

      <span class="c1">// Insert ld.</span>
      <span class="o">++</span><span class="n">I</span><span class="p">;</span>
      <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">()</span> <span class="o">:</span> <span class="n">DebugLoc</span><span class="p">();</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LD</span><span class="p">),</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">).</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">)</span>
                                                       <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">Changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JALR</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">I</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
      <span class="c1">// emit ld $gp, ($gp save slot on stack) after jalr</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LD</span><span class="p">),</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">).</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">)</span>
                                                         <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">Changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// createCpu0EmitGPRestorePass - Returns a pass that emits instructions that</span>
<span class="c1">/// restores $gp clobbered by jalr instructions.</span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0EmitGPRestorePass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Inserter</span><span class="p">(</span><span class="n">tm</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>
<div class="section" id="variable-number-of-arguments">
<h3><a class="toc-backref" href="#id29">Variable number of arguments</a><a class="headerlink" href="#variable-number-of-arguments" title="Permalink to this headline">¶</a></h3>
<p>Until now, we support fixed number of arguments in formal function definition
(Incoming Arguments).
This subsection support variable number of arguments since C language support
this feature.</p>
<p>Run Chapter9_3/ with ch9_3_vararg.cpp as well as clang option,
<strong>clang -target mips-unknown-linux-gnu</strong>, to get the following result,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3_vararg.cpp -emit-llvm -o ch9_3_vararg.bc
118-165-76-131:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -cpu0-s32-calls<span class="o">=</span><span class="nb">false</span>
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_3_vararg.bc -o ch9_3_vararg.cpu0.s
118-165-76-131:input Jonathan<span class="nv">$ </span>cat ch9_3_vararg.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch9_3_vararg.bc&quot;</span>
  .text
  .globl  _Z5sum_iiz
  .align  2
  .type _Z5sum_iiz,@function
  .ent  _Z5sum_iiz              <span class="c"># @_Z5sum_iiz</span>
_Z5sum_iiz:
  .frame  <span class="nv">$fp</span>,24,<span class="nv">$lr</span>
  .mask   0x00001000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
  st  <span class="nv">$fp</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  move    <span class="nv">$fp</span>, <span class="nv">$sp</span>
  ld  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>     // amount
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>     // amount
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>     // i
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>     // val
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>      // sum
  addiu <span class="nv">$3</span>, <span class="nv">$fp</span>, 28
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>      // <span class="nv">arg_ptr</span> <span class="o">=</span> 2nd <span class="nv">argument</span> <span class="o">=</span> &amp;arg<span class="o">[</span>1<span class="o">]</span>,
              // since &amp;arg<span class="o">[</span>0<span class="o">]</span> <span class="o">=</span> 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_1</span>:                                 <span class="c"># =&gt;This Inner Loop Header: Depth=1</span>
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>        // compare<span class="o">(</span>i, amount<span class="o">)</span>
  jge <span class="nv">$BB0_4</span>
  nop
  jmp <span class="nv">$BB0_2</span>
  nop
<span class="nv">$BB0_2</span>:                                 <span class="c">#   in Loop: Header=BB0_1 Depth=1</span>
              // i &lt; amount
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$2</span>, 4   // arg_ptr  + 4
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>     // *arg_ptr
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>      // sum
  add <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>      // sum +<span class="o">=</span> *arg_ptr
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="c"># BB#3:                                 #   in Loop: Header=BB0_1 Depth=1</span>
              // i &gt;<span class="o">=</span> amount
  ld  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1   // i++
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  jmp <span class="nv">$BB0_1</span>
  nop
<span class="nv">$BB0_4</span>:
  ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  move    <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$fp</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z5sum_iiz
<span class="nv">$tmp1</span>:
  .size _Z5sum_iiz, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z5sum_iiz

  .globl  _Z11test_varargv
  .align  2
  .type _Z11test_varargv,@function
  .ent  _Z11test_varargv                    <span class="c"># @_Z11test_varargv</span>
_Z11test_varargv:
  .frame  <span class="nv">$sp</span>,88,<span class="nv">$lr</span>
  .mask   0x00004000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -48
  st  <span class="nv">$lr</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$fp</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  move    <span class="nv">$fp</span>, <span class="nv">$sp</span>
  .cprestore  32
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_iiz<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  nop
  ld  <span class="nv">$gp</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  move    <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$fp</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  ld  <span class="nv">$lr</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 48
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z11test_varargv
<span class="nv">$tmp1</span>:
  .size _Z11test_varargv, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z11test_varargv
</pre></div>
</div>
<p>The analysis of output ch9_3_vararg.cpu0.s as above in comment.
As above code, in # BB#0, we get the first argument <strong>“amount”</strong> from
<strong>“ld $2, 24($fp)”</strong> since the stack size of the callee function
<strong>“_Z5sum_iiz()”</strong> is 24. And then set argument pointer, arg_ptr, to 0($fp),
&amp;arg[1].
Next, check i &lt; amount in block $BB0_1. If  i &lt; amount, than enter into $BB0_2.
In $BB0_2, it do sum += *arg_ptr as well as arg_ptr+=4.
In # BB#3, do i+=1.</p>
<p>To support variable number of arguments, the following code needed to
add in Chapter9_3/.
The ch9_3_template.cpp is C++ template example code, it can be translated into cpu0
backend code too.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">/// Cpu0CC - This class provides methods used to analyze formal and call</span>
    <span class="c1">/// arguments and inquire about calling convention information.</span>
    <span class="k">class</span> <span class="nc">Cpu0CC</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="c1">/// Return the function that analyzes variable argument list functions.</span>
      <span class="n">llvm</span><span class="o">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">varArgFn</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="p">...</span>
<span class="p">.</span>   <span class="p">};</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">SDValue</span> <span class="n">lowerVASTART</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">SDValue</span> <span class="n">lowerADD</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">/// writeVarArgRegs - Write variable function arguments passed in registers</span>
    <span class="c1">/// to the stack. Also create a stack frame object for the first variable</span>
    <span class="c1">/// argument.</span>
    <span class="kt">void</span> <span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span> <span class="k">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span>
                         <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="p">...</span>
<span class="p">.</span> <span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">VASTART</span><span class="p">,</span>            <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Support va_arg(): variable numbers (not fixed numbers) of arguments </span>
  <span class="c1">//  (parameters) for function all</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">VAARG</span><span class="p">,</span>             <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">VACOPY</span><span class="p">,</span>            <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">VAEND</span><span class="p">,</span>             <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  
  <span class="c1">//@llvm.stacksave</span>
  <span class="c1">// Use the default for now</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">STACKSAVE</span><span class="p">,</span>         <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">STACKRESTORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">VASTART</span><span class="o">:</span>            <span class="k">return</span> <span class="n">lowerVASTART</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">}</span>
  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">lowerVASTART</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">FuncInfo</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">SDLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">SDLoc</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FuncInfo</span><span class="o">-&gt;</span><span class="n">getVarArgsFrameIndex</span><span class="p">(),</span>
                                 <span class="n">getPointerTy</span><span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()));</span>

  <span class="c1">// vastart just stores the address of the VarArgsFrameIndex slot into the</span>
  <span class="c1">// memory location argument.</span>
  <span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">SV</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">SrcValueSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                      <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">SV</span><span class="p">),</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerFormalArguments - transform physical registers into virtual registers</span>
<span class="c1">/// and generate load operations for arguments places on the stack.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">IsVarArg</span><span class="p">)</span>
    <span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">OutChains</span><span class="p">,</span> <span class="n">Cpu0CCInfo</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span>
<span class="n">analyzeCallOperands</span><span class="p">(</span><span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Args</span><span class="p">,</span>
                    <span class="kt">bool</span> <span class="n">IsVarArg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsSoftFloat</span><span class="p">,</span> <span class="k">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">CallNode</span><span class="p">,</span>
                    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ArgListEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">FuncArgs</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">llvm</span><span class="o">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">VarFn</span> <span class="o">=</span> <span class="n">varArgFn</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">NumOpnds</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="k">if</span> <span class="p">(</span><span class="n">IsVarArg</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Args</span><span class="p">[</span><span class="n">I</span><span class="p">].</span><span class="n">IsFixed</span><span class="p">)</span>
      <span class="n">R</span> <span class="o">=</span> <span class="n">VarFn</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">ArgVT</span><span class="p">,</span> <span class="n">ArgVT</span><span class="p">,</span> <span class="n">CCValAssign</span><span class="o">::</span><span class="n">Full</span><span class="p">,</span> <span class="n">ArgFlags</span><span class="p">,</span> <span class="n">CCInfo</span><span class="p">);</span>
    <span class="k">else</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">llvm</span><span class="o">::</span><span class="n">CCAssignFn</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0CC</span><span class="o">::</span><span class="n">varArgFn</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsO32</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CC_Cpu0O32</span><span class="p">;</span>
  <span class="k">else</span> <span class="c1">// IsS32</span>
    <span class="k">return</span> <span class="n">CC_Cpu0S32</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">writeVarArgRegs</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">Cpu0CC</span> <span class="o">&amp;</span><span class="n">CC</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">NumRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="p">.</span><span class="n">numIntArgRegs</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="n">MCPhysReg</span><span class="o">&gt;</span> <span class="n">ArgRegs</span> <span class="o">=</span> <span class="n">CC</span><span class="p">.</span><span class="n">intArgRegs</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">CCState</span> <span class="o">&amp;</span><span class="n">CCInfo</span> <span class="o">=</span> <span class="n">CC</span><span class="p">.</span><span class="n">getCCInfo</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">CCInfo</span><span class="p">.</span><span class="n">getFirstUnallocated</span><span class="p">(</span><span class="n">ArgRegs</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">RegSize</span> <span class="o">=</span> <span class="n">CC</span><span class="p">.</span><span class="n">regSize</span><span class="p">();</span>
  <span class="n">MVT</span> <span class="n">RegTy</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">getIntegerVT</span><span class="p">(</span><span class="n">RegSize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">RegTy</span><span class="p">);</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// Offset of the first variable argument from stack pointer.</span>
  <span class="kt">int</span> <span class="n">VaArgOffset</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">NumRegs</span> <span class="o">==</span> <span class="n">Idx</span><span class="p">)</span>
    <span class="n">VaArgOffset</span> <span class="o">=</span> <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">CCInfo</span><span class="p">.</span><span class="n">getNextStackOffset</span><span class="p">(),</span> <span class="n">RegSize</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">VaArgOffset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">CC</span><span class="p">.</span><span class="n">reservedArgArea</span><span class="p">()</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">RegSize</span> <span class="o">*</span> <span class="p">(</span><span class="n">NumRegs</span> <span class="o">-</span> <span class="n">Idx</span><span class="p">));</span>

  <span class="c1">// Record the frame index of the first variable argument</span>
  <span class="c1">// which is a value necessary to VASTART.</span>
  <span class="kt">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">RegSize</span><span class="p">,</span> <span class="n">VaArgOffset</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setVarArgsFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">);</span>

  <span class="c1">// Copy the integer registers that have not been used for argument passing</span>
  <span class="c1">// to the argument register save area. For O32, the save area is allocated</span>
  <span class="c1">// in the caller&#39;s stack frame, while for N32/64, it is allocated in the</span>
  <span class="c1">// callee&#39;s stack frame.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="n">Idx</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">NumRegs</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="n">VaArgOffset</span> <span class="o">+=</span> <span class="n">RegSize</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">addLiveIn</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">ArgRegs</span><span class="p">[</span><span class="n">I</span><span class="p">],</span> <span class="n">RC</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">ArgValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">RegTy</span><span class="p">);</span>
    <span class="n">FI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">RegSize</span><span class="p">,</span> <span class="n">VaArgOffset</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">PtrOff</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()));</span>
    <span class="n">SDValue</span> <span class="n">Store</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">ArgValue</span><span class="p">,</span> <span class="n">PtrOff</span><span class="p">,</span>
                                 <span class="n">MachinePointerInfo</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">cast</span><span class="o">&lt;</span><span class="n">StoreSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Store</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span><span class="o">-&gt;</span><span class="n">getMemOperand</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">setValue</span><span class="p">(</span>
        <span class="p">(</span><span class="n">Value</span> <span class="o">*</span><span class="p">)</span><span class="n">nullptr</span><span class="p">);</span>
    <span class="n">OutChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Store</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_template.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="kt">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="n">test_template</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mips qemu reference <a class="footnote-reference" href="#mipsqemu" id="id10">[8]</a>, you can download and run it with gcc to
verify the result with printf() function at this point.
We will verify the correction of the code in chapter &#8220;Verify backend on
Verilog simulator&#8221; through the CPU0 Verilog language machine.</p>
</div>
<div class="section" id="dynamic-stack-allocation-support">
<h3><a class="toc-backref" href="#id30">Dynamic stack allocation support</a><a class="headerlink" href="#dynamic-stack-allocation-support" title="Permalink to this headline">¶</a></h3>
<p>Even though C language very rare to use dynamic stack allocation, there are
languages use it frequently. The following C example code uses it.</p>
<p>Chapter9_3 supports dynamic stack allocation with the following code added.</p>
<p class="rubric">lbdex/chapters/Chapter9_2/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Eliminate ADJCALLSTACKDOWN, ADJCALLSTACKUP pseudo instructions</span>
<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span>
<span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                              <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="cp">#if CH &gt;= CH9_3 </span><span class="c1">// dynamic alloc</span>
  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hasReservedCallFrame</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">int64_t</span> <span class="n">Amount</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getImm</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADJCALLSTACKDOWN</span><span class="p">)</span>
      <span class="n">Amount</span> <span class="o">=</span> <span class="o">-</span><span class="n">Amount</span><span class="p">;</span>

    <span class="n">STI</span><span class="p">.</span><span class="n">getInstrInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">adjustStackPtr</span><span class="p">(</span><span class="n">SP</span><span class="p">,</span> <span class="n">Amount</span><span class="p">,</span> <span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span>
  <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// dynamic alloc</span>

  <span class="n">MBB</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDu</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// if framepointer enabled, set it to point to the stack pointer.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhDwarf</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
        <span class="p">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="o">::</span><span class="n">FrameSetup</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">//@ Insert instruction &quot;move $fp, $sp&quot; at this location.</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">FP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
      <span class="p">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="o">::</span><span class="n">FrameSetup</span><span class="p">);</span>

    <span class="c1">// emit &quot;.cfi_def_cfa_register $fp&quot;</span>
    <span class="kt">unsigned</span> <span class="n">CFIIndex</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">addFrameInst</span><span class="p">(</span><span class="n">MCCFIInstruction</span><span class="o">::</span><span class="n">createDefCfaRegister</span><span class="p">(</span>
        <span class="n">nullptr</span><span class="p">,</span> <span class="n">MRI</span><span class="o">-&gt;</span><span class="n">getDwarfRegNum</span><span class="p">(</span><span class="n">FP</span><span class="p">,</span> <span class="nb">true</span><span class="p">)));</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">CFI_INSTRUCTION</span><span class="p">))</span>
        <span class="p">.</span><span class="n">addCFIIndex</span><span class="p">(</span><span class="n">CFIIndex</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDu</span><span class="p">;</span>

  <span class="c1">// if framepointer enabled, restore the stack pointer.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Find the first instruction that restores a callee-saved register.</span>
    <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBBI</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">--</span><span class="n">I</span><span class="p">;</span>

    <span class="c1">// Insert instruction &quot;move $sp, $fp&quot; at this location.</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">;</span>

  <span class="c1">// Mark $fp as used if function has dedicated frame pointer.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span>
    <span class="n">setAliasRegs</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">SavedRegs</span><span class="p">,</span> <span class="n">FP</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">DYNAMIC_STACKALLOC</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>  <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">setStackPointerRegisterToSaveRestore</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Reserve FP if this function should have a dedicated frame pointer register.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getSubtarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Reserved</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- If no eliminateFrameIndex(), it will hang on run. </span>
<span class="c1">// pure virtual method</span>
<span class="c1">// FrameIndex represent objects inside a abstract stack.</span>
<span class="c1">// We must replace FrameIndex with an stack/frame pointer</span>
<span class="c1">// direct reference.</span>
<span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="cp">#if CH &gt;= CH3_5</span>
  <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span> <span class="o">=</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="o">*</span><span class="n">MI</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">isFI</span><span class="p">())</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="p">.</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="s">&quot;Instr doesn&#39;t have FrameIndex operand!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Function : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MI</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">FrameIndex</span> <span class="o">=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">getIndex</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>
  <span class="kt">int64_t</span> <span class="n">spOffset</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">);</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FrameIndex : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">FrameIndex</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;spOffset   : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">spOffset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;stackSize  : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">stackSize</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">MinCSFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">MinCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
    <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// The following stack frame objects are always referenced relative to $sp:</span>
  <span class="c1">//  1. Outgoing arguments.</span>
  <span class="c1">//  2. Pointer to dynamically allocated stack space.</span>
  <span class="c1">//  3. Locations for callee-saved registers.</span>
  <span class="c1">// Everything else is referenced relative to whatever register</span>
  <span class="c1">// getFrameRegister() returns.</span>
  <span class="kt">unsigned</span> <span class="n">FrameReg</span><span class="p">;</span>

<span class="cp">#if CH &gt;= CH9_3 </span><span class="c1">//3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">FrameIndex</span> <span class="o">&gt;=</span> <span class="n">MinCSFI</span> <span class="o">&amp;&amp;</span> <span class="n">FrameIndex</span> <span class="o">&lt;=</span> <span class="n">MaxCSFI</span><span class="p">))</span>
    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>
<span class="cp">#else</span>
  <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">//#if CH &gt;= CH9_3 //3</span>

  <span class="c1">// Calculate final offset.</span>
  <span class="c1">// - There is no need to change the offset if the frame object is one of the</span>
  <span class="c1">//   following: an outgoing argument, pointer to a dynamically allocated</span>
  <span class="c1">//   stack space or a $gp restore location,</span>
  <span class="c1">// - If the frame object is any of the following, its offset must be adjusted</span>
  <span class="c1">//   by adding the size of the stack:</span>
  <span class="c1">//   incoming argument, callee-saved register location or local variable.</span>
  <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">;</span>
<span class="cp">#if CH &gt;= CH9_3 </span><span class="c1">//1</span>
<span class="cp">#ifdef ENABLE_GPRESTORE </span><span class="c1">//2</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
  <span class="k">else</span>
<span class="cp">#endif</span>
<span class="cp">#endif </span><span class="c1">//#if CH &gt;= CH9_3 //1</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">stackSize</span><span class="p">;</span>

  <span class="n">Offset</span>    <span class="o">+=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">();</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Offset     : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// If MI is not a debug value, make sure Offset fits in the 16-bit immediate</span>
  <span class="c1">// field.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">isDebugValue</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">assert</span><span class="p">(</span><span class="s">&quot;(!MI.isDebugValue() &amp;&amp; !isInt&lt;16&gt;(Offset))&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ChangeToRegister</span><span class="p">(</span><span class="n">FrameReg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">ChangeToImmediate</span><span class="p">(</span><span class="n">Offset</span><span class="p">);</span>
<span class="cp">#endif </span><span class="c1">// #if CH &gt;= CH3_5</span>
<span class="p">}</span>
<span class="c1">//}</span>

<span class="kt">bool</span>
<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">requiresRegisterScavenging</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span>
<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">trackLivenessAfterRegAlloc</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="kt">unsigned</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getFrameRegister</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">TFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getSubtarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">TFI</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">)</span> <span class="o">:</span>
                          <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// #if CH &gt;= CH3_1</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
  <span class="k">else</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p>Run Chapter9_3 with ch9_3_alloc.cpp will get the following correct result.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-72-242:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3_alloc.cpp -emit-llvm -o ch9_3_alloc.bc
118-165-72-242:input Jonathan<span class="nv">$ </span>llvm-dis ch9_3_alloc.bc -o ch9_3_alloc.ll
118-165-72-242:input Jonathan<span class="nv">$ </span>cat ch9_3_alloc.ll
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch9_3_alloc.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-</span>
<span class="s2">f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:</span>
<span class="s2">32:64-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;x86_64-apple-macosx10.8.0&quot;</span>

define i32 @_Z5sum_iiiiiii<span class="o">(</span>i32 %x1, i32 %x2, i32 %x3, i32 %x4, i32 %x5, i32 %x6<span class="o">)</span>
 nounwind uwtable ssp <span class="o">{</span>
  ...
  %9 <span class="o">=</span> alloca i8, i32 %8      // int* <span class="nv">b</span> <span class="o">=</span> <span class="o">(</span>int*<span class="o">)</span>__builtin_alloca<span class="o">(</span>sizeof<span class="o">(</span>int<span class="o">)</span> * 1 * x1<span class="o">)</span>;
  %10 <span class="o">=</span> bitcast i8* %9 to i32*
  store i32* %10, i32** %b, align 4
  ...
<span class="o">}</span>
...

118-165-72-242:input Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
Debug/bin/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -cpu0-s32-calls<span class="o">=</span><span class="nb">false</span>
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_3_alloc.bc -o ch9_3_alloc.cpu0.s
118-165-72-242:input Jonathan<span class="nv">$ </span>cat ch9_3_alloc.cpu0.s
...
    .globl  _Z10weight_sumiiiiii
  .align  2
  .type _Z10weight_sumiiiiii,@function
  .ent  _Z10weight_sumiiiiii    <span class="c"># @_Z10weight_sumiiiiii</span>
_Z10weight_sumiiiiii:
  .frame  <span class="nv">$fp</span>,48,<span class="nv">$lr</span>
  .mask   0x00005000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -48
  st  <span class="nv">$lr</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$fp</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  move   <span class="nv">$fp</span>, <span class="nv">$sp</span>
  .cprestore  24
  ld  <span class="nv">$2</span>, 68<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 64<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, 60<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$7</span>, 56<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$5</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$7</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$t9</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 2    // <span class="nv">$2</span> <span class="o">=</span> sizeof<span class="o">(</span>int<span class="o">)</span> * 1 * x2;
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 7
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, -8
  and <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 0
  subu  <span class="nv">$2</span>, <span class="nv">$sp</span>, <span class="nv">$2</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$zero</span>, <span class="nv">$2</span>  // <span class="nb">set </span>sp to the bottom of alloca area
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 0
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>    // *b <span class="o">=</span> x3
  ld  <span class="nv">$5</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$7</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
  st  <span class="nv">$7</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$t9</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  shl <span class="nv">$3</span>, <span class="nv">$3</span>, 1
  st  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 3
  mul <span class="nv">$4</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z3sumiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  nop
  ld  <span class="nv">$gp</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  move   <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$fp</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  ld  <span class="nv">$lr</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 48
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z10weight_sumiiiiii
<span class="nv">$func_end1</span>:
  .size _Z10weight_sumiiiiii, <span class="o">(</span><span class="nv">$func_end1</span><span class="o">)</span>-_Z10weight_sumiiiiii
...
</pre></div>
</div>
<p>As you can see, the dynamic stack allocation needs frame pointer register <strong>fp</strong>
support. As above assembly, the sp is adjusted to (sp - 40) when it
entered the function as usual by instruction <strong>addiu $sp, $sp, -40</strong>.
Next, the fp is set to sp where is the position just above alloca() spaces area
as <a class="pageref" href="#funccall-f4">Figure  8</a> when meet instruction <strong>addu $fp, $sp, $zero</strong>.
After that, the sp is changed to the area just below of alloca().
Remind, the alloca() area which the b point to,
<strong>&#8220;*b = (int*)__builtin_alloca(sizeof(int) * 2 * x6)&#8221;</strong>, is
allocated at run time since the spaces is variable size which depend on x1
variable and cannot be calculated at link time.</p>
<p><a class="pageref" href="#funccall-f5">Figure  9</a> depicted how the stack pointer changes back to the
caller stack bottom. As above, the <strong>fp</strong> is set to the address just above of
alloca().
The first step is changing the sp to fp by instruction <strong>move $sp, $fp</strong>.
Next, sp is changed back to caller stack bottom by instruction
<strong>addiu $sp, $sp, 40</strong>.</p>
<div class="figure align-center" id="funccall-f4">
<a class="reference internal image-reference" href="_images/4.png"><img alt="_images/4.png" src="_images/4.png" style="width: 267.5px; height: 139.5px;" /></a>
<p class="caption">Figure 8: Frame pointer changes when enter function</p>
</div>
<div class="figure align-center" id="funccall-f5">
<a class="reference internal image-reference" href="_images/5.png"><img alt="_images/5.png" src="_images/5.png" style="width: 264.0px; height: 132.0px;" /></a>
<p class="caption">Figure 9: Stack pointer changes when exit function</p>
</div>
<div class="figure align-center" id="funccall-f6">
<a class="reference internal image-reference" href="_images/6.png"><img alt="_images/6.png" src="_images/6.png" style="width: 269.5px; height: 197.0px;" /></a>
<p class="caption">Figure 10: fp and sp access areas</p>
</div>
<p>Use fp to keep the old stack pointer value is not the only solution.
Actually, we can keep the alloca() spaces size on a specific memory address
and the sp can back to the the old sp by add the alloca() spaces size.
Most ABI like Mips
and ARM access the above area of alloca() by fp and the below area of alloca()
by sp, as <a class="pageref" href="#funccall-f6">Figure  10</a> depicted. The reason for this definition
is the speed for local variable access. Since the RISC CPU use immediate offset
for load and store as below, using fp and sp for access both areas of
local variables have better performance compare to use the sp only.</p>
<div class="highlight-bash"><div class="highlight"><pre>ld      <span class="nv">$2</span>, 64<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
st      <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
</pre></div>
</div>
<p>Cpu0 uses fp and sp to access the above and below areas of alloca() too.
As ch9_3_alloc.cpu0.s, it access local variable (above of alloca()) by fp offset
and outgoing arguments (below of alloca()) by sp offset.</p>
<p>And more, the &#8220;move $sp, $fp&#8221; is the alias instruction of &#8220;addu $fp, $sp, $zero&#8221;.
The machine code is the latter, and the former is only for easy understand by
user only. This alias come from added code in Chapter3_2 and Chapter3_5 as
follows,</p>
<p class="rubric">lbdex/chapters/Chapter3_2/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printInst</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span>
                                <span class="n">StringRef</span> <span class="n">Annot</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Try to print any aliases first.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">printAliasInstr</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">O</span><span class="p">))</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0InstAlias</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">Asm</span><span class="p">,</span> <span class="n">dag</span> <span class="n">Result</span><span class="p">,</span> <span class="n">bit</span> <span class="n">Emit</span> <span class="o">=</span> <span class="mi">0</span><span class="n">b1</span><span class="o">&gt;</span> <span class="o">:</span>
  <span class="n">InstAlias</span><span class="o">&lt;</span><span class="n">Asm</span><span class="p">,</span> <span class="n">Result</span><span class="p">,</span> <span class="n">Emit</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><pre>let Predicates = [Ch3_5] in {
//===----------------------------------------------------------------------===//
// Instruction aliases
//===----------------------------------------------------------------------===//
def : Cpu0InstAlias&lt;"move $dst, $src",
                    (ADDu GPROut:$dst, GPROut:$src,ZERO), 1&gt;;
}
</pre>
</div>
<p>Finally the MFI-&gt;hasVarSizedObjects() defined in hasReservedCallFrame() of
Cpu0SEFrameLowering.cpp is true when it meets &#8220;%9 = alloca i8, i32 %8&#8221; of IR
which corresponding &#8220;(int*)__builtin_alloca(sizeof(int) * 1 * x1);&#8221; of C.
It will generate asm &#8220;addiu     $sp, $sp, -24&#8221; for ch9_3_alloc.cpp by calling
&#8220;adjustStackPtr()&#8221; in eliminateCallFramePseudoInstr() of Cpu0FrameLowering.cpp.</p>
<p>File ch9_3_longlongshift.cpp which is for type &#8220;long long shift operations&#8221;
support can be tested now as follows.</p>
<p class="rubric">lbdex/input/ch9_3_longlongshift.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;debug.h&quot;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">test_longlong_shift1</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x12</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">c</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">d</span><span class="p">;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span>  <span class="c1">// cc = 0x1</span>
  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">);</span>  <span class="c1">// cc = 0x120</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">);</span> <span class="c1">// 0x121 = 289</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">test_longlong_shift2</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">48</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="mh">0x001666660000000a</span><span class="p">;</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">c</span><span class="p">;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="n">a</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">;</span> <span class="c1">// 22</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>114-37-150-209:input Jonathan<span class="nv">$ </span>clang -O0 -target mips-unknown-linux-gnu
-c ch9_3_longlongshift.cpp -emit-llvm -o ch9_3_longlongshift.bc

114-37-150-209:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/
llvm-dis ch9_3_longlongshift.bc -o -
...
; Function Attrs: nounwind
define i64 @_Z19test_longlong_shiftv<span class="o">()</span> <span class="c">#0 {</span>
  %a <span class="o">=</span> alloca i64, align 8
  %b <span class="o">=</span> alloca i64, align 8
  %c <span class="o">=</span> alloca i64, align 8
  %d <span class="o">=</span> alloca i64, align 8
  store i64 4, i64* %a, align 8
  store i64 18, i64* %b, align 8
  %1 <span class="o">=</span> load i64* %b, align 8
  %2 <span class="o">=</span> load i64* %a, align 8
  %3 <span class="o">=</span> ashr i64 %1, %2
  store i64 %3, i64* %c, align 8
  %4 <span class="o">=</span> load i64* %b, align 8
  %5 <span class="o">=</span> load i64* %a, align 8
  %6 <span class="o">=</span> shl i64 %4, %5
  store i64 %6, i64* %d, align 8
  %7 <span class="o">=</span> load i64* %c, align 8
  %8 <span class="o">=</span> load i64* %d, align 8
  %9 <span class="o">=</span> add nsw i64 %7, %8
  ret i64 %9
<span class="o">}</span>
...
114-37-150-209:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/llc
-march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch9_3_longlongshift.bc -o -
  .text
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch9_3_longlongshift.bc&quot;</span>
  .globl  _Z20test_longlong_shift1v
  .align  2
  .type _Z20test_longlong_shift1v,@function
  .ent  _Z20test_longlong_shift1v <span class="c"># @_Z20test_longlong_shift1v</span>
_Z20test_longlong_shift1v:
  .frame  <span class="nv">$fp</span>,56,<span class="nv">$lr</span>
  .mask   0x00005000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -56
  st  <span class="nv">$lr</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$fp</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  move   <span class="nv">$fp</span>, <span class="nv">$sp</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
  st  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$4</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$5</span>, <span class="nv">$zero</span>, 18
  st  <span class="nv">$5</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jsub  __lshrdi3
  nop
  st  <span class="nv">$3</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$5</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  jsub  __ashldi3
  nop
  st  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$4</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  cmp <span class="nv">$sw</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  andi  <span class="nv">$3</span>, <span class="nv">$sw</span>, 1
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  ld  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  addu  <span class="nv">$3</span>, <span class="nv">$zero</span>, <span class="nv">$4</span>
  move   <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$fp</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  ld  <span class="nv">$lr</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 56
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z20test_longlong_shift1v
<span class="nv">$tmp0</span>:
  .size _Z20test_longlong_shift1v, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z20test_longlong_shift1v

  .globl  _Z20test_longlong_shift2v
  .align  2
  .type _Z20test_longlong_shift2v,@function
  .ent  _Z20test_longlong_shift2v <span class="c"># @_Z20test_longlong_shift2v</span>
_Z20test_longlong_shift2v:
  .frame  <span class="nv">$fp</span>,48,<span class="nv">$lr</span>
  .mask   0x00005000,-4
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -48
  st  <span class="nv">$lr</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$fp</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  move   <span class="nv">$fp</span>, <span class="nv">$sp</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 48
  st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$5</span>, <span class="nv">$zero</span>, 10
  st  <span class="nv">$5</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  lui <span class="nv">$2</span>, 22
  ori <span class="nv">$4</span>, <span class="nv">$2</span>, 26214
  st  <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jsub  __lshrdi3
  nop
  st  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  move   <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$fp</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  ld  <span class="nv">$lr</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 48
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z20test_longlong_shift2v
<span class="nv">$tmp1</span>:
  .size _Z20test_longlong_shift2v, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z20test_longlong_shift2v
</pre></div>
</div>
</div>
<div class="section" id="variable-sized-array-support">
<h3><a class="toc-backref" href="#id31">Variable sized array support</a><a class="headerlink" href="#variable-sized-array-support" title="Permalink to this headline">¶</a></h3>
<p>LLVM support variable sized arrays in C99 <a class="footnote-reference" href="#stacksave" id="id11">[9]</a>. The following code
added with this support. Set them to expand, meaning llvm uses other DAGs
replace them.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Use the default for now</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">STACKSAVE</span><span class="p">,</span>         <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">STACKRESTORE</span><span class="p">,</span>      <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_stacksave.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_stacksaverestore</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// CHECK: call i8* @llvm.stacksave()</span>
  <span class="kt">char</span> <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
  <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">s1</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
  <span class="c1">// CHECK: call void @llvm.stackrestore(i8*</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3_stacksave.cpp -emit-llvm -o ch9_3_stacksave.bc
JonathantekiiMac:input Jonathan<span class="nv">$ </span>llvm-dis ch9_3_stacksave.bc -o -

define i32 @_Z21test_stacksaverestorej<span class="o">(</span>i32 zeroext %x<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> alloca i32, align 4
  %2 <span class="o">=</span> alloca i8*
  %3 <span class="o">=</span> alloca i32
  store i32 %x, i32* %1, align 4
  %4 <span class="o">=</span> load i32, i32* %1, align 4
  %5 <span class="o">=</span> call i8* @llvm.stacksave<span class="o">()</span>
  store i8* %5, i8** %2
  %6 <span class="o">=</span> alloca i8, i32 %4, align 1
  %7 <span class="o">=</span> load i32, i32* %1, align 4
  %8 <span class="o">=</span> getelementptr inbounds i8, i8* %6, i32 %7
  store i8 5, i8* %8, align 1
  %9 <span class="o">=</span> load i32, i32* %1, align 4
  %10 <span class="o">=</span> getelementptr inbounds i8, i8* %6, i32 %9
  %11 <span class="o">=</span> load i8, i8* %10, align 1
  %12 <span class="o">=</span> sext i8 %11 to i32
  store i32 1, i32* %3
  %13 <span class="o">=</span> load i8*, i8** %2
  call void @llvm.stackrestore<span class="o">(</span>i8* %13<span class="o">)</span>
  ret i32 %12
<span class="o">}</span>

JonathantekiiMac:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/llc
-march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch9_3_stacksave.bc -o -
...
</pre></div>
</div>
</div>
<div class="section" id="function-related-intrinsics-support">
<h3><a class="toc-backref" href="#id32">Function related Intrinsics support</a><a class="headerlink" href="#function-related-intrinsics-support" title="Permalink to this headline">¶</a></h3>
<p>I think these llvm instinsic IRs are for exception handling implementation
<a class="footnote-reference" href="#excepthandle" id="id12">[10]</a> [#returnaddr]. With these IRs, programmer can recording the
frame address and return address to be used in implementing program of
exception handler by C++ as the example below. In order to support these llvm
intrinsic IRs, the following code added to Cpu0 backend.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">EH_RETURN</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span>                <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">FRAMEADDR</span><span class="o">:</span>          <span class="k">return</span> <span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">RETURNADDR</span><span class="o">:</span>         <span class="k">return</span> <span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">EH_RETURN</span><span class="o">:</span>          <span class="k">return</span> <span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">ADD</span><span class="o">:</span>                <span class="k">return</span> <span class="n">lowerADD</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">lowerFRAMEADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// check the depth</span>
  <span class="n">assert</span><span class="p">((</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Frame address can only be determined for current frame.&quot;</span><span class="p">);</span>

  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setFrameAddressIsTaken</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
  <span class="n">SDLoc</span> <span class="nf">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FrameAddr</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span>
      <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">FrameAddr</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">lowerRETURNADDR</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                            <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">verifyReturnAddressArgumentIsConstant</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>

  <span class="c1">// check the depth</span>
  <span class="n">assert</span><span class="p">((</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Return address can be determined only for current frame.&quot;</span><span class="p">);</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">MVT</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getSimpleValueType</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">LR</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">;</span>
  <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setReturnAddressIsTaken</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

  <span class="c1">// Return LR, which contains the return address. Mark it an implicit live-in.</span>
  <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">LR</span><span class="p">,</span> <span class="n">getRegClassFor</span><span class="p">(</span><span class="n">VT</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">SDLoc</span><span class="p">(</span><span class="n">Op</span><span class="p">),</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// An EH_RETURN is the result of lowering llvm.eh.return which in turn is</span>
<span class="c1">// generated from __builtin_eh_return (offset, handler)</span>
<span class="c1">// The effect of this is to adjust the stack pointer by &quot;offset&quot;</span>
<span class="c1">// and then branch to &quot;handler&quot;.</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">lowerEH_RETURN</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span>
                                                                     <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setCallsEhReturn</span><span class="p">();</span>
  <span class="n">SDValue</span> <span class="n">Chain</span>     <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">Offset</span>    <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">Handler</span>   <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">SDLoc</span> <span class="nf">DL</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">;</span>

  <span class="c1">// Store stack offset in V1, store jump target in V0. Glue CopyToReg and</span>
  <span class="c1">// EH_RETURN nodes, so that instructions are emitted back-to-back.</span>
  <span class="kt">unsigned</span> <span class="n">OffsetReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">V1</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">AddrReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">;</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">OffsetReg</span><span class="p">,</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SDValue</span><span class="p">());</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">AddrReg</span><span class="p">,</span> <span class="n">Handler</span><span class="p">,</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">EH_RETURN</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span>
                     <span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">OffsetReg</span><span class="p">,</span> <span class="n">Ty</span><span class="p">),</span>
                     <span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">AddrReg</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">())),</span>
                     <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">lowerADD</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ISD</span><span class="o">::</span><span class="n">FRAMEADDR</span>
      <span class="o">||</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span>
        <span class="p">(</span><span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">0</span>
      <span class="o">||</span> <span class="n">Op</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">ISD</span><span class="o">::</span><span class="n">FRAME_TO_ARGS_OFFSET</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setCallsEhDwarf</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="section" id="frameaddress-and-returnaddress-intrinsics">
<h4><a class="toc-backref" href="#id33">frameaddress and returnaddress intrinsics</a><a class="headerlink" href="#frameaddress-and-returnaddress-intrinsics" title="Permalink to this headline">¶</a></h4>
<p>Run with the following input to get the following result.</p>
<p class="rubric">lbdex/input/ch9_3_frame_return_addr.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">display_frameaddress</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">__builtin_frame_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="nf">fn</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">display_returnaddress</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">fn</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/
llvm-dis ch9_3_frame_return_addr.bc -o -
...
; Function Attrs: nounwind
define i32 @_Z20display_frameaddressv<span class="o">()</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> call i8* @llvm.frameaddress<span class="o">(</span>i32 0<span class="o">)</span>
  %2 <span class="o">=</span> ptrtoint i8* %1 to i32
  ret i32 %2
<span class="o">}</span>

; Function Attrs: nounwind readnone
<span class="nb">declare </span>i8* @llvm.frameaddress<span class="o">(</span>i32<span class="o">)</span> <span class="c">#1</span>

define i32 @_Z22display_returnaddressv<span class="o">()</span> <span class="c">#2 {</span>
  %a <span class="o">=</span> alloca i32, align 4
  %1 <span class="o">=</span> call i8* @llvm.returnaddress<span class="o">(</span>i32 0<span class="o">)</span>
  %2 <span class="o">=</span> ptrtoint i8* %1 to i32
  store i32 %2, i32* %a, align 4
  %3 <span class="o">=</span> call i32 @_Z2fnv<span class="o">()</span>
  %4 <span class="o">=</span> load i32, i32* %a, align 4
  ret i32 %4
<span class="o">}</span>

JonathantekiiMac:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/llc
-march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch9_3_frame_return_addr.bc
-o -
      .text
      .section .mdebug.abiO32
      .previous
      .file <span class="s2">&quot;ch9_3_frame_return_addr.bc&quot;</span>
      .globl  _Z20display_frameaddressv
      .align  2
      .type _Z20display_frameaddressv,@function
      .ent    _Z20display_frameaddressv <span class="c"># @_Z20display_frameaddressv</span>
_Z20display_frameaddressv:
      .frame  <span class="nv">$fp</span>,8,<span class="nv">$lr</span>
      .mask           0x00001000,-4
      .set    noreorder
      .set    nomacro
<span class="c"># BB#0:</span>
      addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
      st      <span class="nv">$fp</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>                                                     <span class="c"># 4-byte Folded Spill</span>
      move     <span class="nv">$fp</span>, <span class="nv">$sp</span>
      addu    <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$fp</span>
      move     <span class="nv">$sp</span>, <span class="nv">$fp</span>
      ld      <span class="nv">$fp</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>                                                     <span class="c"># 4-byte Folded Reload</span>
      addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
      ret <span class="nv">$lr</span>
      nop
      .set    macro
      .set    reorder
      .end    _Z20display_frameaddressv
<span class="nv">$func_end0</span>:
      .size _Z20display_frameaddressv, <span class="o">(</span><span class="nv">$func_end0</span><span class="o">)</span>-_Z20display_frameaddressv

      .globl  _Z22display_returnaddress1v
      .align  2
      .type _Z22display_returnaddress1v,@function
      .ent    _Z22display_returnaddress1v <span class="c"># @_Z22display_returnaddress1v</span>
_Z22display_returnaddress1v:
      .cfi_startproc
      .frame  <span class="nv">$fp</span>,24,<span class="nv">$lr</span>
      .mask           0x00005000,-4
      .set    noreorder
      .set    nomacro
<span class="c"># BB#0:</span>
      addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
<span class="nv">$tmp0</span>:
      .cfi_def_cfa_offset 24
      st      <span class="nv">$lr</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>                                            <span class="c"># 4-byte Folded Spill</span>
      st      <span class="nv">$fp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>                                            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp1</span>:
      .cfi_offset 14, -4
<span class="nv">$tmp2</span>:
      .cfi_offset 12, -8
      move     <span class="nv">$fp</span>, <span class="nv">$sp</span>
<span class="nv">$tmp3</span>:
      .cfi_def_cfa_register 12
      st      <span class="nv">$lr</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      jsub    _Z2fnv
      nop
      ld      <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      move     <span class="nv">$sp</span>, <span class="nv">$fp</span>
      ld      <span class="nv">$fp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>                                            <span class="c"># 4-byte Folded Reload</span>
      ld      <span class="nv">$lr</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>                                            <span class="c"># 4-byte Folded Reload</span>
      addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
      ret <span class="nv">$lr</span>
      nop
      .set    macro
      .set    reorder
      .end    _Z22display_returnaddress1v
<span class="nv">$func_end1</span>:
      .size _Z22display_returnaddress1v, <span class="o">(</span><span class="nv">$func_end1</span><span class="o">)</span>-_Z22display_returnaddress1v
      .cfi_endproc
</pre></div>
</div>
<p>The asm &#8220;ld     $2, 12($fp)&#8221; in function _Z22display_returnaddress1v reload $lr
to $2 after &#8220;jsub _Z3fnv&#8221;. Cpu0 doesn&#8217;t produce &#8220;addiu $2, $zero, $lr&#8221; because
if _Z3fnv change $lr value without following ABI then it will get the wrong $lr
to $2. The following code kills $lr register and make the reference to $lr by
loading from stack slot rather than uses register directly.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span>
<span class="n">spillCalleeSavedRegisters</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                          <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span><span class="p">,</span>
                          <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Add the callee-saved register as live-in. Do not add if the register is</span>
    <span class="c1">// LR and return address is taken, because it has already been added in</span>
    <span class="c1">// method Cpu0TargetLowering::LowerRETURNADDR.</span>
    <span class="c1">// It&#39;s killed at the spill, unless the register is LR and return address</span>
    <span class="c1">// is taken.</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getReg</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="n">IsRAAndRetAddrIsTaken</span> <span class="o">=</span> <span class="p">(</span><span class="n">Reg</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">)</span>
        <span class="o">&amp;&amp;</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isReturnAddressTaken</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsRAAndRetAddrIsTaken</span><span class="p">)</span>
      <span class="n">EntryBlock</span><span class="o">-&gt;</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>

    <span class="c1">// Insert the spill to the stack frame.</span>
    <span class="kt">bool</span> <span class="n">IsKill</span> <span class="o">=</span> <span class="o">!</span><span class="n">IsRAAndRetAddrIsTaken</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="n">TRI</span><span class="o">-&gt;</span><span class="n">getMinimalPhysRegClass</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="n">TII</span><span class="p">.</span><span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="o">*</span><span class="n">EntryBlock</span><span class="p">,</span> <span class="n">MI</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">IsKill</span><span class="p">,</span>
                            <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">(),</span> <span class="n">RC</span><span class="p">,</span> <span class="n">TRI</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="eh-return-intrinsic">
<h4><a class="toc-backref" href="#id34">eh.return intrinsic</a><a class="headerlink" href="#eh-return-intrinsic" title="Permalink to this headline">¶</a></h4>
<p>Beside lowerRETURNADDR() in Cpu0ISelLowering, the following code is for
eh.return supporting only, and it can run with input ch9_3_detect_exception.cpp
as below.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                       <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhReturn</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Insert instructions that spill eh data registers.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">ABI</span><span class="p">.</span><span class="n">EhDataRegSize</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MBB</span><span class="p">.</span><span class="n">isLiveIn</span><span class="p">(</span><span class="n">ABI</span><span class="p">.</span><span class="n">GetEhDataReg</span><span class="p">(</span><span class="n">I</span><span class="p">)))</span>
        <span class="n">MBB</span><span class="p">.</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">ABI</span><span class="p">.</span><span class="n">GetEhDataReg</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
      <span class="n">TII</span><span class="p">.</span><span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">ABI</span><span class="p">.</span><span class="n">GetEhDataReg</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="nb">false</span><span class="p">,</span>
                              <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEhDataRegFI</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="n">RC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RegInfo</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// Emit .cfi_offset directives for eh data registers.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">ABI</span><span class="p">.</span><span class="n">EhDataRegSize</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int64_t</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEhDataRegFI</span><span class="p">(</span><span class="n">I</span><span class="p">));</span>
      <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">MRI</span><span class="o">-&gt;</span><span class="n">getDwarfRegNum</span><span class="p">(</span><span class="n">ABI</span><span class="p">.</span><span class="n">GetEhDataReg</span><span class="p">(</span><span class="n">I</span><span class="p">),</span> <span class="nb">true</span><span class="p">);</span>
      <span class="kt">unsigned</span> <span class="n">CFIIndex</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">addFrameInst</span><span class="p">(</span>
          <span class="n">MCCFIInstruction</span><span class="o">::</span><span class="n">createOffset</span><span class="p">(</span><span class="n">nullptr</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">Offset</span><span class="p">));</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">CFI_INSTRUCTION</span><span class="p">))</span>
          <span class="p">.</span><span class="n">addCFIIndex</span><span class="p">(</span><span class="n">CFIIndex</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhReturn</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">GPROutRegClass</span><span class="p">;</span>

    <span class="c1">// Find first instruction that restores a callee-saved register.</span>
    <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBBI</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">--</span><span class="n">I</span><span class="p">;</span>

    <span class="c1">// Insert instructions that restore eh data registers.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">J</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">J</span> <span class="o">&lt;</span> <span class="n">ABI</span><span class="p">.</span><span class="n">EhDataRegSize</span><span class="p">();</span> <span class="o">++</span><span class="n">J</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">TII</span><span class="p">.</span><span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">ABI</span><span class="p">.</span><span class="n">GetEhDataReg</span><span class="p">(</span><span class="n">J</span><span class="p">),</span>
                               <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEhDataRegFI</span><span class="p">(</span><span class="n">J</span><span class="p">),</span> <span class="n">RC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RegInfo</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// This method is called immediately before PrologEpilogInserter scans the </span>
<span class="c1">//  physical registers used to determine what callee saved registers should be </span>
<span class="c1">//  spilled. This method is optional. </span>
<span class="kt">void</span> <span class="n">Cpu0SEFrameLowering</span><span class="o">::</span><span class="n">determineCalleeSaves</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                               <span class="n">BitVector</span> <span class="o">&amp;</span><span class="n">SavedRegs</span><span class="p">,</span>
                                               <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Create spill slots for eh data registers if function calls eh_return.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhReturn</span><span class="p">())</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">createEhDataRegsFI</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Exception handling related node and instructions.
// The conversion sequence is:
// ISD::EH_RETURN -&gt; Cpu0ISD::EH_RETURN -&gt;
// CPU0eh_return -&gt; (stack change + indirect branch)
//
// CPU0eh_return takes the place of regular return instruction
// but takes two arguments (V1, V0) which are used for storing
// the offset and return address respectively.
def SDT_Cpu0EHRET : SDTypeProfile&lt;0, 2, [SDTCisInt&lt;0&gt;, SDTCisPtrTy&lt;1&gt;]&gt;;

def CPU0ehret : SDNode&lt;"Cpu0ISD::EH_RETURN", SDT_Cpu0EHRET,
                      [SDNPHasChain, SDNPOptInGlue, SDNPVariadic]&gt;;

let Uses = [V0, V1], isTerminator = 1, isReturn = 1, isBarrier = 1 in {
  def CPU0eh_return32 : Cpu0Pseudo&lt;(outs), (ins GPROut:$spoff, GPROut:$dst), "",
                                [(CPU0ehret GPROut:$spoff, GPROut:$dst)]&gt;;
}
</pre>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEInstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">expandEhReturn</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                      <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEInstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Expand Pseudo instructions into real backend instructions</span>
<span class="kt">bool</span> <span class="n">Cpu0SEInstrInfo</span><span class="o">::</span><span class="n">expandPostRAPseudo</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">CPU0eh_return32</span><span class="o">:</span>
    <span class="n">expandEhReturn</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MI</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0SEInstrInfo</span><span class="o">::</span><span class="n">expandEhReturn</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                     <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// This pseudo instruction is generated as part of the lowering of</span>
  <span class="c1">// ISD::EH_RETURN. We convert it to a stack increment by OffsetReg, and</span>
  <span class="c1">// indirect jump to TargetReg</span>
  <span class="kt">unsigned</span> <span class="n">ADDU</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDu</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">LR</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">T9</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">T9</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">OffsetReg</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getReg</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">TargetReg</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getReg</span><span class="p">();</span>

  <span class="c1">// addu $lr, $v0, $zero</span>
  <span class="c1">// addu $sp, $sp, $v1</span>
  <span class="c1">// jr   $lr (via RetLR)</span>
  <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">(),</span> <span class="n">get</span><span class="p">(</span><span class="n">ADDU</span><span class="p">),</span> <span class="n">T9</span><span class="p">)</span>
        <span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">TargetReg</span><span class="p">)</span>
        <span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">);</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">(),</span> <span class="n">get</span><span class="p">(</span><span class="n">ADDU</span><span class="p">),</span> <span class="n">LR</span><span class="p">)</span>
      <span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">TargetReg</span><span class="p">)</span>
      <span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">);</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">(),</span> <span class="n">get</span><span class="p">(</span><span class="n">ADDU</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">OffsetReg</span><span class="p">);</span>
  <span class="n">expandRetLR</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_detect_exception.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
<span class="kt">void</span><span class="o">*</span> <span class="n">returnAddr</span><span class="p">;</span>

<span class="c1">// Even though __builtin_frame_address is useless in this example, I believe</span>
<span class="c1">// it will be used in real exception handler implementation. Because in real</span>
<span class="c1">// implementation, the exception handler keeps a table and decide which function</span>
<span class="c1">// should be triggered for a specific exception and hand over to it.</span>
<span class="c1">// The hand over process needs unwinding the stack frame. The stack frame address</span>
<span class="c1">// can be gotten by calling __builtin_frame_address in the charged function.</span>
<span class="kt">void</span> <span class="nf">exception_handler</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">frameaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">__builtin_frame_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">__builtin_eh_return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">returnAddr</span><span class="p">);</span> <span class="c1">// no warning, eh_return never returns.</span>
<span class="p">}</span>

<span class="n">__attribute__</span> <span class="p">((</span><span class="n">weak</span><span class="p">))</span> 
<span class="kt">int</span> <span class="n">test_detect_exception</span><span class="p">(</span><span class="kt">bool</span> <span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">exceptionOccur</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">void</span><span class="o">*</span> <span class="n">handler</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">exception_handler</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">exception</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">returnAddr</span> <span class="o">=</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">__builtin_eh_return</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">handler</span><span class="p">);</span> <span class="c1">// no warning, eh_return never returns.</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>114-37-150-48:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3_detect_exception.cpp -emit-llvm -o ch9_3_detect_exception.bc
114-37-150-48:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/llvm-dis
ch9_3_detect_exception.bc -o -
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch9_3_detect_exception.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;E-m:m-p:32:32-i8:8:32-i16:16:32-i64:64-n32-S64&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;mips-unknown-linux-gnu&quot;</span>

@exceptionOccur <span class="o">=</span> global i8 0, align 1
@returnAddr <span class="o">=</span> global i8* null, align 4

; Function Attrs: nounwind
define void @_Z17exception_handlerv<span class="o">()</span> <span class="c">#0 {</span>
  %frameaddr <span class="o">=</span> alloca i32, align 4
  store i8 1, i8* @exceptionOccur, align 1
  %1 <span class="o">=</span> call i8* @llvm.frameaddress<span class="o">(</span>i32 0<span class="o">)</span>
  %2 <span class="o">=</span> ptrtoint i8* %1 to i32
  store i32 %2, i32* %frameaddr, align 4
  %3 <span class="o">=</span> load i8*, i8** @returnAddr, align 4
  call void @llvm.eh.return.i32<span class="o">(</span>i32 0, i8* %3<span class="o">)</span>
  unreachable
                                                  ; No predecessors!
  ret void
<span class="o">}</span>

; Function Attrs: nounwind readnone
<span class="nb">declare </span>i8* @llvm.frameaddress<span class="o">(</span>i32<span class="o">)</span> <span class="c">#1</span>

; Function Attrs: nounwind
<span class="nb">declare </span>void @llvm.eh.return.i32<span class="o">(</span>i32, i8*<span class="o">)</span> <span class="c">#2</span>

define weak i32 @_Z21test_detect_exceptionb<span class="o">(</span>i1 zeroext %exception<span class="o">)</span> <span class="c">#3 {</span>
  %1 <span class="o">=</span> alloca i8, align 1
  %handler <span class="o">=</span> alloca i8*, align 4
  %2 <span class="o">=</span> zext i1 %exception to i8
  store i8 %2, i8* %1, align 1
  store i8 0, i8* @exceptionOccur, align 1
  store i8* bitcast <span class="o">(</span>void <span class="o">()</span>* @_Z17exception_handlerv to i8*<span class="o">)</span>, i8** %handler, align 4
  %3 <span class="o">=</span> load i8, i8* %1, align 1
  %4 <span class="o">=</span> trunc i8 %3 to i1
  br i1 %4, label %5, label %8

; &lt;label&gt;:5                                       ; <span class="nv">preds</span> <span class="o">=</span> %0
  %6 <span class="o">=</span> call i8* @llvm.returnaddress<span class="o">(</span>i32 0<span class="o">)</span>
  store i8* %6, i8** @returnAddr, align 4
  %7 <span class="o">=</span> load i8*, i8** %handler, align 4
  call void @llvm.eh.return.i32<span class="o">(</span>i32 0, i8* %7<span class="o">)</span>
  unreachable

; &lt;label&gt;:8                                       ; <span class="nv">preds</span> <span class="o">=</span> %0
  ret i32 0
<span class="o">}</span>

; Function Attrs: nounwind readnone
<span class="nb">declare </span>i8* @llvm.returnaddress<span class="o">(</span>i32<span class="o">)</span> <span class="c">#1</span>

attributes <span class="c">#0 = { nounwind ... }</span>
attributes <span class="c">#1 = { nounwind readnone }</span>
attributes <span class="c">#2 = { nounwind }</span>
attributes <span class="c">#3 = { &quot;less-precise-fpmad&quot;=&quot;false&quot; ... }</span>
...

114-37-150-48:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/llc
-march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch9_3_detect_exception.bc -o -
  .text
  .section .mdebug.abiO32
  .previous
  .file <span class="s2">&quot;ch9_3_detect_exception.bc&quot;</span>
  .globl  _Z17exception_handlerv
  .align  2
  .type _Z17exception_handlerv,@function
  .ent  _Z17exception_handlerv  <span class="c"># @_Z17exception_handlerv</span>
_Z17exception_handlerv:
  .frame  <span class="nv">$fp</span>,16,<span class="nv">$lr</span>
  .mask   0x00001000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
  st  <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$5</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  move   <span class="nv">$fp</span>, <span class="nv">$sp</span>
  lui <span class="nv">$2</span>, %got_hi<span class="o">(</span>exceptionOccur<span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$gp</span>
  ld  <span class="nv">$2</span>, %got_lo<span class="o">(</span>exceptionOccur<span class="o">)(</span><span class="nv">$2</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 1
  sb  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$fp</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  lui <span class="nv">$2</span>, %got_hi<span class="o">(</span>returnAddr<span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$gp</span>
  ld  <span class="nv">$2</span>, %got_lo<span class="o">(</span>returnAddr<span class="o">)(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
  move   <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$5</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  move   <span class="nv">$t9</span>, <span class="nv">$2</span>
  move   <span class="nv">$lr</span>, <span class="nv">$2</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$sp</span>, <span class="nv">$3</span>
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z17exception_handlerv
<span class="nv">$func_end0</span>:
  .size _Z17exception_handlerv, <span class="o">(</span><span class="nv">$func_end0</span><span class="o">)</span>-_Z17exception_handlerv

  .weak _Z21test_detect_exceptionb
  .align  2
  .type _Z21test_detect_exceptionb,@function
  .ent  _Z21test_detect_exceptionb <span class="c"># @_Z21test_detect_exceptionb</span>
_Z21test_detect_exceptionb:
  .cfi_startproc
  .frame  <span class="nv">$fp</span>,24,<span class="nv">$lr</span>
  .mask   0x00001000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
<span class="nv">$tmp0</span>:
  .cfi_def_cfa_offset 24
  st  <span class="nv">$fp</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp1</span>:
  .cfi_offset 12, -4
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  st  <span class="nv">$5</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$tmp2</span>:
  .cfi_offset 4, -16
<span class="nv">$tmp3</span>:
  .cfi_offset 5, -20
  move   <span class="nv">$fp</span>, <span class="nv">$sp</span>
<span class="nv">$tmp4</span>:
  .cfi_def_cfa_register 12
  sb  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  lui <span class="nv">$2</span>, %got_hi<span class="o">(</span>exceptionOccur<span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$gp</span>
  ld  <span class="nv">$2</span>, %got_lo<span class="o">(</span>exceptionOccur<span class="o">)(</span><span class="nv">$2</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
  sb  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  lui <span class="nv">$2</span>, %got_hi<span class="o">(</span>_Z17exception_handlerv<span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$gp</span>
  ld  <span class="nv">$2</span>, %got_lo<span class="o">(</span>_Z17exception_handlerv<span class="o">)(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  lbu <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  andi  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  beq <span class="nv">$2</span>, <span class="nv">$zero</span>, .LBB1_2
  nop
  jmp .LBB1_1
  nop
.LBB1_2:
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  move   <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$5</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$fp</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
  ret <span class="nv">$lr</span>
  nop
.LBB1_1:
  lui <span class="nv">$2</span>, %got_hi<span class="o">(</span>returnAddr<span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$gp</span>
  ld  <span class="nv">$2</span>, %got_lo<span class="o">(</span>returnAddr<span class="o">)(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$lr</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
  move   <span class="nv">$sp</span>, <span class="nv">$fp</span>
  ld  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$5</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ld  <span class="nv">$fp</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
  move   <span class="nv">$t9</span>, <span class="nv">$2</span>
  move   <span class="nv">$lr</span>, <span class="nv">$2</span>
  addu  <span class="nv">$sp</span>, <span class="nv">$sp</span>, <span class="nv">$3</span>
  ret <span class="nv">$lr</span>
  nop
  .set  macro
  .set  reorder
  .end  _Z21test_detect_exceptionb
<span class="nv">$func_end1</span>:
  .size _Z21test_detect_exceptionb, <span class="o">(</span><span class="nv">$func_end1</span><span class="o">)</span>-_Z21test_detect_exceptionb
  .cfi_endproc

  .type exceptionOccur,@object  <span class="c"># @exceptionOccur</span>
  .bss
  .globl  exceptionOccur
exceptionOccur:
  .byte 0                       <span class="c"># 0x0</span>
  .size exceptionOccur, 1

  .type returnAddr,@object      <span class="c"># @returnAddr</span>
  .globl  returnAddr
  .align  2
returnAddr:
  .4byte  0
  .size returnAddr, 4
  ...
</pre></div>
</div>
<p>If you disable &#8220;__attribute__ ((weak))&#8221; in the c file, then the IR will has
&#8220;nounwind&#8221; in attributes #3. The side effect in asm output is &#8220;No .cfi_offset
issued&#8221; like function exception_handler().</p>
<p>This example code of exception handler implementation can get frame, return and
call exception handler by call __builtin_xxx in clang in C language, without
introduces any assembly instruction.
And this example can be verified in the Chapter &#8220;Cpu0 ELF linker&#8221; of my the other
book &#8220;llvm tool chain for Cpu0&#8221; <a class="footnote-reference" href="#cpu0lld" id="id13">[12]</a>.
Through global variable, exceptionOccur, is true or false, whether the control
flow to exception_handler() or not can be identified.</p>
</div>
<div class="section" id="eh-dwarf-intrinsic">
<h4><a class="toc-backref" href="#id35">eh.dwarf intrinsic</a><a class="headerlink" href="#eh-dwarf-intrinsic" title="Permalink to this headline">¶</a></h4>
<p>Beside lowerADD() in Cpu0ISelLowering, the following code is for the eh.dwarf
supporting only, and it can run with input eh-dwarf-cfa.ll as below.</p>
<p class="rubric">lbdex/chapters/Chapter9_3/Cpu0SEFrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// if framepointer enabled, set it to point to the stack pointer.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">callsEhDwarf</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">)</span>
        <span class="p">.</span><span class="n">setMIFlag</span><span class="p">(</span><span class="n">MachineInstr</span><span class="o">::</span><span class="n">FrameSetup</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/eh-dwarf-cfa.ll</p>
<div class="highlight-c++"><pre>; RUN: llc -march=cpu0el -mcpu=cpu032II &lt; %s | FileCheck %s

declare i8* @llvm.eh.dwarf.cfa(i32) nounwind
declare i8* @llvm.frameaddress(i32) nounwind readnone

define i8* @f1() nounwind {
entry:
  %x = alloca [32 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  ret i8* %0

; CHECK:        addiu   $sp, $sp, -40
; CHECK:        addu    $2,  $zero, $fp
}


define i8* @f2() nounwind {
entry:
  %x = alloca [65536 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  ret i8* %0

; check stack size (65536 + 8)
; CHECK:        lui     $[[R0:[a-z0-9]+]], 65535
; CHECK:        addiu   $[[R0]], $[[R0]], -8
; CHECK:        addu    $sp, $sp, $[[R0]]

; check return value ($sp + stack size)
; CHECK:        addu    $2,  $zero, $fp
}


define i32 @f3() nounwind {
entry:
  %x = alloca [32 x i8], align 1
  %0 = call i8* @llvm.eh.dwarf.cfa(i32 0)
  %1 = ptrtoint i8* %0 to i32
  %2 = call i8* @llvm.frameaddress(i32 0)
  %3 = ptrtoint i8* %2 to i32
  %add = add i32 %1, %3
  ret i32 %add

; CHECK:        addiu   $sp, $sp, -40

; check return value ($fp + stack size + $fp)
; CHECK:        move     $fp, $sp
; CHECK:        addu    $2, $fp, $fp
}

</pre>
</div>
</div>
<div class="section" id="bswap-intrinsic">
<h4><a class="toc-backref" href="#id36">bswap intrinsic</a><a class="headerlink" href="#bswap-intrinsic" title="Permalink to this headline">¶</a></h4>
<p>Cpu0 supports llvm instrinsics bswap intrinsic <a class="footnote-reference" href="#bswapintrnsic" id="id14">[13]</a>.</p>
<p class="rubric">lbdex/chapters/Chapter12_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">STI</span><span class="p">),</span> <span class="n">ABI</span><span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getABI</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">BSWAP</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">BSWAP</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i64</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/input/ch9_3_bswap.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_bswap16</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap16</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x3412</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_bswap32</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap32</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x34120000</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_bswap64</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mh">0x1234</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">__builtin_bswap64</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">^</span> <span class="mh">0x3412000000000000</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_bswap</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">test_bswap16</span><span class="p">()</span> <span class="o">+</span> <span class="n">test_bswap32</span><span class="p">()</span> <span class="o">+</span> <span class="n">test_bswap64</span><span class="p">();</span>
  
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>114-37-150-48:input Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3_bswap.cpp -emit-llvm -o ch9_3_bswap.bc
114-37-150-48:input Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/Debug/bin/llvm-dis
ch9_3_bswap.bc -o -
...
define i32 @_Z12test_bswap16v<span class="o">()</span> <span class="c">#0 {</span>
  %a <span class="o">=</span> alloca i32, align 4
  %result <span class="o">=</span> alloca i32, align 4
  store volatile i32 4660, i32* %a, align 4
  %1 <span class="o">=</span> load volatile i32, i32* %a, align 4
  %2 <span class="o">=</span> trunc i32 %1 to i16
  %3 <span class="o">=</span> call i16 @llvm.bswap.i16<span class="o">(</span>i16 %2<span class="o">)</span>
  %4 <span class="o">=</span> zext i16 %3 to i32
  %5 <span class="o">=</span> xor i32 %4, 13330
  store i32 %5, i32* %result, align 4
  %6 <span class="o">=</span> load i32, i32* %result, align 4
  ret i32 %6
<span class="o">}</span>
...
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="summary">
<h2><a class="toc-backref" href="#id37">Summary</a><a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<p>Now, Cpu0 backend code now can take care the integer function call and control
statement just like the llvm front end tutorial example code.
It can translate some of the C++ OOP language into Cpu0 instructions also
without much effort in backend,
because the most complex things in language, such as C++ syntex, is handled by
front end.
LLVM is a real structure following the compiler theory, any backend of LLVM can
benefit from this structure.
The best part of 3 tiers compiler structure is that backend will grow up
automatically through the front end support languages more and more if the
frontend has not add any new IR for a new language.</p>
<table class="docutils footnote" frame="void" id="computer-arch-interface" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Computer Organization and Design: The Hardware/Software Interface 1st edition (The Morgan Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mipsasm" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[2]</td><td><em>(<a class="fn-backref" href="#id3">1</a>, <a class="fn-backref" href="#id9">2</a>)</em> <a class="reference external" href="http://math-atlas.sourceforge.net/devel/assembly/007-2418-003.pdf">http://math-atlas.sourceforge.net/devel/assembly/007-2418-003.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="abi" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> <a class="reference external" href="http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf">http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="secglobal" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/globalvar.html#global-variable">http://jonathan2251.github.io/lbd/globalvar.html#global-variable</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="wikitailcall" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Tail_call">http://en.wikipedia.org/wiki/Tail_call</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="tailcallopt" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html#tail-call-optimization">http://llvm.org/docs/CodeGenerator.html#tail-call-optimization</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="callconv" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#calling-conventions">http://llvm.org/docs/LangRef.html#calling-conventions</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="mipsqemu" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[8]</a></td><td><a class="reference external" href="http://developer.mips.com/clang-llvm/">http://developer.mips.com/clang-llvm/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="stacksave" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[9]</a></td><td><a class="reference external" href="http://www.llvm.org/docs/LangRef.html#llvm-stacksave-intrinsic">http://www.llvm.org/docs/LangRef.html#llvm-stacksave-intrinsic</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="excepthandle" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[10]</a></td><td><a class="reference external" href="http://llvm.org/docs/ExceptionHandling.html#overview">http://llvm.org/docs/ExceptionHandling.html#overview</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="returnaddr" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[11]</td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-returnaddress-intrinsic">http://llvm.org/docs/LangRef.html#llvm-returnaddress-intrinsic</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="cpu0lld" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[12]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbt/lld.html">http://jonathan2251.github.io/lbt/lld.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="bswapintrnsic" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[13]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html#llvm-bswap-intrinsics">http://llvm.org/docs/LangRef.html#llvm-bswap-intrinsics</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statements</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="elf.html">ELF Support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>